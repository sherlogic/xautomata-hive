{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Python integration with Xautomata API</p>"},{"location":"#xautomata-api","title":"Xautomata API","text":"<p>Pacchetto che fornisca una interfaccia semplice per usare le API di Xautomata in python</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"hive.api/","title":"Hive.api","text":""},{"location":"hive.api/#hive.api.ApiManager","title":"<code>ApiManager</code>","text":"<p>Class to interact with Xautomata REST APIs.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>root uri</p> required <code>user</code> <code>str</code> <p>username</p> required <code>password</code> <code>str</code> <p>password</p> required <p>Attributes:</p> Name Type Description <code>credentials</code> <code>tuple</code> <p>(user, password), tupla che estrae le credenziali da server_endpoint</p> <code>token</code> <code>str</code> <p>token di autenticazione delle api</p> Source code in <code>hive/api.py</code> <pre><code>class ApiManager:\n    \"\"\"\n    Class to interact with Xautomata REST APIs.\n\n    Args:\n        root (str): root uri\n        user (str): username\n        password (str): password\n\n    Attributes:\n        credentials (tuple): (user, password), tupla che estrae le credenziali da server_endpoint\n        token (str): token di autenticazione delle api\n    \"\"\"\n\n    _timeout = 150\n    _timeout_get_session_retry = 5\n    _timeout_get_session_backoff_factor = 5\n    _timeout_retry = 1  # di default non si fanno retry sui timeout\n    _timeout_sleep_time = 120  # tempo di attesa tra un retry e quello successivo in caso di timeout\n    _silence_warning = False  # da implementare\n    _rate_limit_per_minute = 1000  # numero di chiamate al minuto consentite prima di un delay per rallentare il numero di chimate\n    num_items = None  # serve per quando si mette la count a True, di default vale 0\n    response = []  # variabile in cui mettere la risposta degli endpoing per poter accedere alla versione originale\n\n    def __init__(self, root, user, password, ssl_verify: bool = True):\n\n        if 'api/v' not in root: logger.warning(f'{root} does not have the api/v* in the root, mandatory to point at the API')\n\n        self._SSL_verify = ssl_verify\n        self.root = root.rstrip('/')\n        self.credentials = (user, password)\n        self.token = 'UNDEFINED'\n        self.authenticate()\n        self._get_only = False\n\n        if not self._SSL_verify: warnings.filterwarnings(\"ignore\", category=InsecureRequestWarning)\n\n    ################################################################################################################\n\n    def authenticate(self):\n        \"\"\"\n        Metodo che compie l'autenticazione e ottiene il token per la sessione\n        \"\"\"\n        user, password = self.credentials\n        auth_date = {\"grant_type\": \"password\", \"username\": user, \"password\": password}\n        response = get_session(self._timeout, self._timeout_get_session_retry, self._timeout_get_session_backoff_factor).post(f'{self.root}/login/access-token', auth_date, verify=self._SSL_verify)\n        response.raise_for_status()\n        self.token = json.loads(response.content.decode('utf-8'))['access_token']\n        logger.debug('authenticated')\n\n    def openapi(self):\n        \"\"\"metodo che restituisce gli schema degli end point\"\"\"\n        response = get_session(self._timeout, self._timeout_get_session_retry, self._timeout_get_session_backoff_factor).request('GET', url=f'{self.root}/openapi.js',\n                                                      headers={'Authorization': f'Bearer {self.token}'}, verify=self._SSL_verify)\n        data = json.loads(response.content[15:].decode('utf-8'))\n        return data\n\n    @refresh\n    def execute(self, mode: Literal['GET', 'POST', 'DELETE', 'PUT'], path, headers: Dict = None, single_page: bool = False,\n                page_size: int = 5000, payload: Dict or List[dict] = None, warm_start: bool = False,\n                params: Dict = None, **kwargs):\n        \"\"\"\n        metodo che chiama la API richiesta nella modalita richiesta.\n\n        Args:\n            mode (['GET', 'POST']): get o post\n            path (str): url dell'api\n            headers (dict, optional): dict of headers. Default to None.\n            payload (dict or list[dict], optional): contenuto della richiesta, valido solo per la post. Default to False.\n            warm_start (bool, optional): activates the warm start mode. Defailt to False.\n            params (dict, optional): skip, limit, count, like, sort_by, null_fileds, join. Default to None\n                - skip (int, optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0.\n                - limit (int, optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000.\n                - count (bool, optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False.\n                - like (bool, optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True.\n                - sort_by (str, optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\".\n                - null_fileds (str, optional): Stringa separata da virgole di campi di cui si vuole rimuovere, o imporre, un valore nullo nel result set. Esempio \"campo:nullable\". Default to \"\".\n                - join (bool, optional): Se join = true, ogni riga restituita conterr\u00e0 chiavi aggiuntive che fanno riferimento ad altre entit\u00e0, con cui la riga ha relazioni 1:1. Default to False\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n\n            **kwargs: additional parameters for the API\n\n        Returns:\n            response (list): risposta dell'API selezionata\n        \"\"\"\n\n        bulk = True if isinstance(payload, list) else False\n        bulk = True if 'bulk' in path else bulk  # verifico dalla path se \u00e8 una api bulk\n        bulk = True if path == '/metric_ingest/' else bulk  # il metric_ingest e' una bulk ma non compare nel nome\n        bulk = True if path == '/probes_log_ingest/' else bulk  # il metric_ingest e' una bulk ma non compare nel nome\n        read = True if 'read' in path else False  # verifico dalla path se \u00e8 una api get, valido solo per le bulk\n        query = True if 'query' in path else False  # verifico dalla path se \u00e8 una api get, valido solo per le bulk\n        query = True if path == '/last_status' and mode == 'POST' else query  # caso specifico della last_status che non ha features riconoscibili\n\n        authentication = {'Authorization': f'Bearer {self.token}'}\n        _headers_ = headers.copy().update(authentication) if headers else authentication\n\n        _payload_ = payload.copy() if payload is not None else None  # va lasciato in questa dicitura perche in se si usa if payload quando arriva un {} viene considerato False\n        _params_ = params.copy() if params else {}\n\n        _params_['skip'] = _params_.get('skip', 0)\n        _params_['limit'] = _params_.get('limit', 1_000_000)\n        _params_['count'] = _params_.get('count', False)\n\n        if _params_['count']:\n            single_page = True\n            warm_start = False\n\n        if mode == 'POST' or mode == 'DELETE' or mode == 'PUT':\n\n            # il controllo qui impedisce di fare chiamate se in modalita POST DELETE PUT se in modalita test,\n            # con l'eccezione della presenza della parola read nel path che indica una bulk in lettura\n            if self._get_only and not (read and bulk) and not query:\n                raise ValueError('you are trying to access a not get_only API')\n\n            # tutto quello che non \u00e8 bulk e query gli viene impedito di paginare\n            # mentre le bulk e query post/delete possono paginare come le get\n            if not bulk and not query:\n                single_page = True\n                warm_start = False\n                _params_.pop('count')\n\n            # le bulk post/delete non devono poter fare warm_start mai, se viene impostato a True \u00e8 per errore e qui viene forzato a False\n            if bulk and not read: warm_start = False\n\n        url = f'{self.root}{path}'\n\n        self.response = []  # reset dell'attributo responce, cosi da non accodare risposte proveninenti da richieste diverse\n\n        @warmstart(active=warm_start, args_ex=[2], verbose=False)\n        @paginate(single_page=single_page, page_size=page_size, skip=_params_['skip'], limit=_params_['limit'], bulk=bulk)\n        @timeout_retry(max_tries=self._timeout_retry, sleep_time=self._timeout_sleep_time)\n        @ratelimiter(per_minute=self._rate_limit_per_minute)\n        def run_request(_mode, _url, _headers, _payload, _params, **_kwargs):\n            self.num_items = None  # inizializzo a 0 il valore della count, cosi che non possa leggere il numero sbagliato dopo una richiesta non corretta\n\n            logger.debug(f'request url: {_url}')\n            logger.debug(f'request params (skip and limit may differ from your setting due pagination): {_params}')\n            logger.debug(f'request payload: {_payload}')\n\n            response = get_session(\n                self._timeout,\n                self._timeout_get_session_retry,\n                self._timeout_get_session_backoff_factor\n                ).request(\n                          _mode,\n                          url=_url,\n                          json=_payload,\n                          params=_params,\n                          headers=_headers,\n                          verify=self._SSL_verify,\n                          **_kwargs)\n\n            if response.status_code == 401: raise UnauthorizedException\n\n            # 504 non e' gestito dalle API per cui la responce non sarebbe json serializable\n            # 204 e' semplicemente vuoto\n            if response.status_code != 200 and response.status_code != 504 and response.status_code != 204:\n                try:\n                    logger.error(response.json())\n                except ValueError:\n                    logger.error(f'Non-JSON error response: {response.text}')\n\n            response.raise_for_status()\n\n            if response.status_code == 200 and _params.get('count', False):\n                self.num_items = response.headers.get('x-num-items', None)\n\n            # 204 rappresenta risposta vuota ma se non mi viene dato il type del content viene matenuto dentro alla risposta una stringa 'b'\n            # che rappresenta la fine di uno streaming di dati vuoto. Per evitare questo problema, in assenza di Content-Type, lo aggiorno\n            # a text, cosi che poi venga gestito correttamente dal response.text che toglie la 'b' di chiusura streaming.\n            if response.status_code == 204 and response.headers.get('Content-Type', None) is None:\n                response.headers['Content-Type'] = 'text/plain'\n\n            # Decodifica della risposta in base al tipo di contenuto\n            content_type = response.headers.get('Content-Type', '')\n            if 'application/json' in content_type:\n                body = response.json()\n            elif 'text/html' in content_type or 'text/plain' in content_type:\n                body = response.text\n            else:\n                # fallback per contenuti non gestiti esplicitamente\n                logger.warning(f'Unknown content type \"{content_type}\", returning raw content.')\n                body = response.content\n\n            logger.debug(f'Response: {body}')\n            logger.debug(f'header: {response.headers}')\n\n            self.response.append(response)  # sotto forma di lista perche se la risposta viene paginata questa viene spezzata su piu risposte\n\n            # viene inviato il codice della chiamata cosi che in fase di paginazione possa gestire alcune casisteche speciali\n            return body, response.status_code\n\n        return run_request(mode, url, _headers_, _payload_, _params_, **kwargs)\n\n    def get_post(self, url_get: str, url_post: str = None, get_params: dict = None, post_params: dict = None,\n                 prefix: str = None, add_post_params: dict = None, silence_put: bool = False) -&gt; Tuple[str, int, int, int]:\n        \"\"\"\n        metodo che prova a fare una get con i parametri selezionati, se la get fallisce perche mancavano i dati\n        richiesti allora viene fatta una post per creare il dato cercato\n\n        Args:\n            url_get (str): url dell'api di get\n            url_post (str, optional): url dell'api di post, se non viene fornito nessun url, viene usato quello della\n                get. Default to None.\n            get_params (dict, optional): parametri della api di get. Default to None.\n            post_params (dict, optional): parametri della api di post. Default to None.\n            prefix (str, optional): nel caso la get fornisse un risposta con piu elementi, il prefix rappresenta la\n                parte del nome che ci si aspetta sia presente nell'elemento da usare. Default to None.\n            add_post_params (dict, optional): parametri della post, put che non rientrano nel payload\n            silence_put (bool, optional): se a True le put non vengono fatte.\n\n        Returns:\n            uuid (str): uuid dell'oggetto richiesto\n            get_count (int): 1 se il metodo e' risultato in una get e 0 se e' risultato in una post\n            post_count (int): 1 se il metodo e' risutltato in una post e 0 se e' risultato in una get\n        \"\"\"\n        if get_params is None: get_params = {}\n        if post_params is None: post_params = {}\n        url_post = url_get if url_post is None else url_post\n        get_count, post_count, put_count = 0, 0, 0\n\n        # se uno passa lo stesso dizionario sia per get che per post, con la seguente riga impedisce di applicare le modifiche fatte alla get anche alla post\n        get_params = get_params.copy()\n        post_params = post_params.copy()\n\n        # a meno di definizioni diverse le chiamate get vengono sempre fatte in like = False\n        get_params['like'] = get_params.get('like', False)\n\n        try:\n            # il primo tentativo e' di chiedere l'oggetto con una get\n            response_content = self.execute('GET', url_get, params=get_params)\n            # se e' stato inserito un prefisso questo viene usato per selezionare solo la riposta con quel prefisso\n            if prefix is not None:\n                response_content = [g for g in response_content if g['name'].startswith(prefix)]\n            # se la risposta e' un vettore a lunghezza 0 allora viene postato un elemento con le caratteristiche cercate\n            if len(response_content) == 0:\n                # in fase di testing non viene postato nulla\n                if self._get_only:\n                    response_content = [{'uuid': 'F4FF'+str(uuid4())[4:]}]\n                else:\n                    # viene postato l'elemento con le caratteristiche richieste\n                    response_content = self.execute('POST', url_post, payload=post_params, params=add_post_params)\n                post_count = 1\n            else:\n                # se post_params \u00e8 vuoto o se siamo in modalita silence, la put non viene provata\n                if post_params and not silence_put:\n                    # se l'oggetto esiste controllo le sue chiavi\n                    for chiave in post_params:  # ciclo sulle chiavi dei parametri postabili\n                        # se incontro un parametro di quelli decisi per il post che \u00e8 abbinato ad un valore diverso rispetto\n                        # a quello che \u00e8 nella risposta, allora faccio una put\n                        if post_params[chiave] != response_content[0][chiave]:\n                            # estraggo lo uuid dell'oggetto\n                            uuid = response_content[0]['uuid']\n                            # compio la put con il nuovo set di parametri\n                            if not self._get_only:\n                                response_content = self.execute('PUT', url_post+uuid, payload=post_params, params=add_post_params)\n                            # alzo il contatore delle put\n                            put_count = 1\n                            # se ho fatto una put non continuo con il ciclo\n                            break\n                # se ho fatto una put non alzo anche il contatore delle get\n                get_count = 1 if put_count == 0 else 0\n\n        # se la risposta alla prima get era un errore questo viene catturato qui\n        except HTTPError as e:\n            # se l'errore era un 404 o un 405 significa che l'oggetto non esiste e viene quindi postato come sopra\n            if e.response.status_code in [404, 405]:\n                if self._get_only:\n                    response_content = [{'uuid': 'F4FF'+str(uuid4())[4:]}]\n                else:\n                    response_content = self.execute('POST', url_post, payload=post_params)\n                post_count = 1\n            else:\n                # ogni altro errore viene restituito come tale\n                print(e.response.json())\n                raise ValueError(e)\n\n        return response_content[0]['uuid'], get_count, post_count, put_count\n\n    def get_post_bulk(self, post_params: List[dict], url_get: str, url_post: str = None, url_put: str = None,\n                      add_get_params: dict = None, add_post_params: dict = None, silence_put: bool = False,\n                      page_size: int = 5000) -&gt; Tuple[List[str], int, int, int]:\n        \"\"\"\n        metodo che prova a fare una get con i parametri selezionati, se la get fallisce perche mancavano i dati\n        richiesti allora viene fatta una post per creare il dato cercato. La risposta ha lo stesso ordine della lista\n        post_params\n\n        Args:\n            post_params (list[dict], optional): parametri della api di post. Default to None.\n            url_get (str): url dell'api di get\n            url_post (str, optional): url dell'api di post, se non viene fornito nessun url, viene usato quello della\n                get. Default to None.\n            url_put (str): url dell'api di put\n            add_get_params (dict, optional): parametri della get che non rientrano nel payload. Default to None.\n            add_post_params (dict, optional): parametri della post, put che non rientrano nel payload\n            silence_put (bool, optional): se a True le put non vengono fatte.\n            page_size (int, optional): numero di elementi che vengono caricati in un unica chiamata\n\n        Returns:\n            uuid (list[str]): lista di tutti gli uuid degli oggetti richiesti, ordinati come il vettore post_params\n            get_count (int): 1 se il metodo e' risultato in una get e 0 se e' risultato in una post\n            post_count (int): 1 se il metodo e' risutltato in una post e 0 se e' risultato in una get\n            put_count (int): 1 se il metodo e' risutlato in una put e 0 se e' risultato in una put\n        \"\"\"\n\n        # se viene dato il solo elemento dell'url, questo viene convertito nella sua versione bulk\n        if 'bulk/read' not in url_get: url_get = '/' + url_get.lstrip('/').rstrip('/') + '/bulk/read_by/'\n        else:                          url_get = '/' + url_get.lstrip('/').rstrip('/') + '/'\n\n        # inizializzo url post se non viene passato\n        if url_post is None: url_post = url_get.split('bulk/read')[0]\n        if 'bulk/create' not in url_post: url_post = '/' + url_post.lstrip('/').rstrip('/') + '/bulk/create/'\n        else:                             url_post = '/' + url_post.lstrip('/').rstrip('/') + '/'\n\n        # inizializzo url put se non viene passato\n        url_put = url_get.split('bulk')[0] if url_put is None else url_put\n        url_put = '/' + url_put.lstrip('/').rstrip('/') + '/'\n\n        method = url_get.split('/')[1]\n        if method not in ['customers', 'virtual_domains', 'sites', 'groups', 'objects', 'metric_types', 'metrics', 'services']:\n            raise NotImplementedError(f'the {method} has not been implemented')\n\n        get_count, post_count, put_count = 0, 0, 0\n\n        # se uno passa lo stesso dizionario sia per get che per post, con la seguente riga impedisce di applicare le modifiche fatte alla get anche alla post\n        post_params = post_params.copy()\n\n        # ottengo le chiavi univoche da un dizionario\n        chiavi_dict = {'customers': Keys.customer_keys, 'virtual_domains': Keys.virtual_domain_keys, 'sites': Keys.site_keys,\n                       'groups': Keys.group_keys, 'objects': Keys.object_keys, 'metric_types': Keys.metric_type_keys,\n                       'metrics': Keys.metric_keys, 'services': Keys.service_keys}\n        chiavi = chiavi_dict[method]['univocal']\n\n        # si chiedono tutti gli oggetti in con la get e si ottiene una lista di riposta con gli uuid di quelli trovati e dei None per quelli non trovati\n        # non serve filtrare le richieste alla get con le sole chiavi primarie perche l'API fa il filtro internamente\n        response_content_temp = self.execute('POST', url_get, payload=post_params, params=add_get_params, page_size=page_size)  # questo metodo puo introdurre dei duplicati se lo stesso oggetto viene chiesto piu volte e si sta paginando\n\n        # creo un dizionario con gli elementi primari come chiavi e le rispote come valori\n        response_content_temp_dict = dict()\n        for cont in response_content_temp:\n            # creo le chiavi con il risultato dei valori degli elementi primari\n            chiave = tuple(cont[k] for k in chiavi)\n            # abbino a questa chiave il contenuto della risposta\n            response_content_temp_dict[chiave] = cont\n\n        # precrea una lista vuota\n        response_content = [None for _ in range(len(post_params))]\n        # seleziono dalla lista postata gli indici degli elementi che hanno dato un None come risultato dalla get\n        id_element_to_post, id_element_getted, key_post = [], [], []\n\n        # creo un dizionario con gli elementi primari come chiavi e le rispote come valori\n        post_params_dict = dict()\n        # cicla su tutti gli elementi e discrimino quelli che sono gia stati ottenuti da quelli che mancano\n        for i, ele in enumerate(post_params):\n            # creo le chiavi con il risultato dei valori degli elementi primari\n            chiave = tuple(ele[k] for k in chiavi)\n            # abbino a questa chiave il contenuto della risposta\n            post_params_dict[chiave] = ele\n\n            # vado a cercare nella risposta se presente la chiave cercata, in caso positivo inserisco quel valore come elemento del vettore risposte\n            # questo mi garantisce di mantenere lo stesso ordine delle richieste\n            # se una richiesta genera piu risposte viene considerata solo l'ultima\n            # se una richiesta non genera nessuna risposta viene abbinato il None\n            # se vengono fatte piu richieste uguali vengono abbinati sempre gli stessi risultati tutte le volte che sono stati chiesti\n            # a senconda se il responce e' None o meno popolo un vettore diverso dell'incide\n            if chiave in response_content_temp_dict:\n                response_content[i] = response_content_temp_dict[chiave]\n                id_element_getted.append(i)\n            else:\n                response_content[i] = chiave\n                id_element_to_post.append(i)\n                # mi creo una lista che contiene le chiavi primarie degli oggetti da postare\n                key_post.append(tuple(ele[k] for k in chiavi))\n\n        # ottendo le chiavi univoche per postare gli elementi, eliminando eventuali ripetizioni\n        key_post = set(key_post)\n        # il numero delle post sono tutti gli elementi che non sono tornati da una get\n        post_count = len(key_post)\n\n        ###################################################\n        put_count = self._put_cicle(add_post_params, chiavi, post_params_dict, put_count, response_content_temp_dict, silence_put, url_put)\n        # il numero delle get reali sono il numero di chiavi uniche presenti nella riposta delle get, meno quelli su cui e' stata fatta una put\n        get_count = len(response_content_temp_dict) - put_count\n        ###################################################\n\n        # prese le chiavi univoche degli elementi da postare, vengono recuperati gli oggetti da postare dal dizionario dei parametri da postare\n        element_to_post = [post_params_dict[id_key] for id_key in key_post]\n\n        # faccio la post di tutti gli elementi che hanno dato None nella get\n        # se in modalita test genero gli uuid\n        if len(element_to_post) &gt; 0:\n            if self._get_only: response_content_post = ['F4FF' + str(uuid4())[4:] for _ in range(len(element_to_post))]\n            else:\n                response_content_post_raw = self.execute('POST', url_post, payload=element_to_post, params=add_post_params,\n                                                         page_size=page_size)\n                # la risposta di una post e' costituita da [{success: num, failed: num, uuids: [uuid1, uuid2]} , {}, ...]\n                # per mettere assieme tutti gli uuid presenti su piu pagine va aperto ogni json e messi gli uuid in un vettore\n                response_content_post = []\n                for item in response_content_post_raw:\n                    response_content_post += item[\"uuids\"]\n\n                del response_content_post_raw\n\n            post_to_key_res_dict = dict()\n            for i, id_key in enumerate(key_post):\n                post_to_key_res_dict[id_key] = response_content_post[i]\n\n            # inserisco i nuovi uuid trovati nella risposta originale\n            for i, _id in enumerate(id_element_to_post):\n                chiave = response_content[_id]\n                response_content[_id] = {'uuid': post_to_key_res_dict[chiave]}\n\n        # seleziono dalla lista postata gli indici degli elementi che hanno dato un None come risultato dalla get\n        uuid_res = []\n        none_count = 0\n        for val in response_content:\n            if val is None:\n                uuid_res.append(val)\n                none_count += 1\n            else:\n                uuid_res.append(val['uuid'])\n\n        if none_count &gt; 0:\n            logger.warning(f'{none_count} elements have not been matched with a uuid and can be found as None in the resutl list')\n\n        return uuid_res, get_count, post_count, put_count\n\n    def _put_cicle(self, add_post_params, chiavi, post_params_dict, put_count, response_content_temp_dict, silence_put, url_put):\n        # se post_params \u00e8 vuoto o se siamo in modalita silence, la put non viene provata\n        if not silence_put:\n            # ciclo sulla risposta della get con i soli oggetti trovati dalla get\n            for res_get_i in response_content_temp_dict:\n                # seleziono l'iesimo elemento del dizionario delle rispote get\n                # non uso il vettore delle risposte perche se la risposta viene paginata rischio di avere dei duplicati, mentre con il dizionario della risposta stessa non puo succedere\n                res_get = response_content_temp_dict[res_get_i]\n\n                # creo le chiavi con il risultato dei valori degli elementi primari dentro alle risposte ottenute\n                chiave = tuple(res_get[k] for k in chiavi)\n\n                # se l'oggetto esiste controllo le sue chiavi\n                for chiave_getted in res_get:  # ciclo sulle chiavi dei parametri ottenuti\n\n                    # se incontro un parametro di quelli decisi per il post che \u00e8 abbinato ad un valore diverso rispetto\n                    # a quello che \u00e8 nella risposta, allora faccio una put\n\n                    # vado a prendere il valore delle post che combacia con il risultato ottenuto dalle get\n                    # la chiave viene chiesta con il metodo get su post_params perche non necessariamente i parametri data dall'utente hanno tutte le chiavi\n                    if res_get[chiave_getted] != post_params_dict[chiave].get(chiave_getted, res_get[chiave_getted]):\n\n                        # estraggo lo uuid dell'oggetto\n                        uuid = res_get['uuid']\n                        # compio la put con il nuovo set di parametri\n                        # la put va a modificare il dato sul db ma non mi serve che venga poi inserito il valore nello script\n                        if not self._get_only: self.execute('PUT', url_put + uuid, payload=post_params_dict[chiave], params=add_post_params)\n                        # alzo il contatore delle put e riduco le get\n                        put_count += 1\n                        break\n        return put_count\n</code></pre>"},{"location":"hive.api/#hive.api.ApiManager.authenticate","title":"<code>authenticate()</code>","text":"<p>Metodo che compie l'autenticazione e ottiene il token per la sessione</p> Source code in <code>hive/api.py</code> <pre><code>def authenticate(self):\n    \"\"\"\n    Metodo che compie l'autenticazione e ottiene il token per la sessione\n    \"\"\"\n    user, password = self.credentials\n    auth_date = {\"grant_type\": \"password\", \"username\": user, \"password\": password}\n    response = get_session(self._timeout, self._timeout_get_session_retry, self._timeout_get_session_backoff_factor).post(f'{self.root}/login/access-token', auth_date, verify=self._SSL_verify)\n    response.raise_for_status()\n    self.token = json.loads(response.content.decode('utf-8'))['access_token']\n    logger.debug('authenticated')\n</code></pre>"},{"location":"hive.api/#hive.api.ApiManager.execute","title":"<code>execute(mode, path, headers=None, single_page=False, page_size=5000, payload=None, warm_start=False, params=None, **kwargs)</code>","text":"<p>metodo che chiama la API richiesta nella modalita richiesta.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>[GET, POST]</code> <p>get o post</p> required <code>path</code> <code>str</code> <p>url dell'api</p> required <code>headers</code> <code>dict</code> <p>dict of headers. Default to None.</p> <code>None</code> <code>payload</code> <code>dict or list[dict]</code> <p>contenuto della richiesta, valido solo per la post. Default to False.</p> <code>None</code> <code>warm_start</code> <code>bool</code> <p>activates the warm start mode. Defailt to False.</p> <code>False</code> <code>params</code> <code>dict</code> <p>skip, limit, count, like, sort_by, null_fileds, join. Default to None - skip (int, optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - limit (int, optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - count (bool, optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - like (bool, optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - sort_by (str, optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - null_fileds (str, optional): Stringa separata da virgole di campi di cui si vuole rimuovere, o imporre, un valore nullo nel result set. Esempio \"campo:nullable\". Default to \"\". - join (bool, optional): Se join = true, ogni riga restituita conterr\u00e0 chiavi aggiuntive che fanno riferimento ad altre entit\u00e0, con cui la riga ha relazioni 1:1. Default to False</p> <code>None</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>**kwargs</code> <p>additional parameters for the API</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>response</code> <code>list</code> <p>risposta dell'API selezionata</p> Source code in <code>hive/api.py</code> <pre><code>@refresh\ndef execute(self, mode: Literal['GET', 'POST', 'DELETE', 'PUT'], path, headers: Dict = None, single_page: bool = False,\n            page_size: int = 5000, payload: Dict or List[dict] = None, warm_start: bool = False,\n            params: Dict = None, **kwargs):\n    \"\"\"\n    metodo che chiama la API richiesta nella modalita richiesta.\n\n    Args:\n        mode (['GET', 'POST']): get o post\n        path (str): url dell'api\n        headers (dict, optional): dict of headers. Default to None.\n        payload (dict or list[dict], optional): contenuto della richiesta, valido solo per la post. Default to False.\n        warm_start (bool, optional): activates the warm start mode. Defailt to False.\n        params (dict, optional): skip, limit, count, like, sort_by, null_fileds, join. Default to None\n            - skip (int, optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0.\n            - limit (int, optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000.\n            - count (bool, optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False.\n            - like (bool, optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True.\n            - sort_by (str, optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\".\n            - null_fileds (str, optional): Stringa separata da virgole di campi di cui si vuole rimuovere, o imporre, un valore nullo nel result set. Esempio \"campo:nullable\". Default to \"\".\n            - join (bool, optional): Se join = true, ogni riga restituita conterr\u00e0 chiavi aggiuntive che fanno riferimento ad altre entit\u00e0, con cui la riga ha relazioni 1:1. Default to False\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n\n        **kwargs: additional parameters for the API\n\n    Returns:\n        response (list): risposta dell'API selezionata\n    \"\"\"\n\n    bulk = True if isinstance(payload, list) else False\n    bulk = True if 'bulk' in path else bulk  # verifico dalla path se \u00e8 una api bulk\n    bulk = True if path == '/metric_ingest/' else bulk  # il metric_ingest e' una bulk ma non compare nel nome\n    bulk = True if path == '/probes_log_ingest/' else bulk  # il metric_ingest e' una bulk ma non compare nel nome\n    read = True if 'read' in path else False  # verifico dalla path se \u00e8 una api get, valido solo per le bulk\n    query = True if 'query' in path else False  # verifico dalla path se \u00e8 una api get, valido solo per le bulk\n    query = True if path == '/last_status' and mode == 'POST' else query  # caso specifico della last_status che non ha features riconoscibili\n\n    authentication = {'Authorization': f'Bearer {self.token}'}\n    _headers_ = headers.copy().update(authentication) if headers else authentication\n\n    _payload_ = payload.copy() if payload is not None else None  # va lasciato in questa dicitura perche in se si usa if payload quando arriva un {} viene considerato False\n    _params_ = params.copy() if params else {}\n\n    _params_['skip'] = _params_.get('skip', 0)\n    _params_['limit'] = _params_.get('limit', 1_000_000)\n    _params_['count'] = _params_.get('count', False)\n\n    if _params_['count']:\n        single_page = True\n        warm_start = False\n\n    if mode == 'POST' or mode == 'DELETE' or mode == 'PUT':\n\n        # il controllo qui impedisce di fare chiamate se in modalita POST DELETE PUT se in modalita test,\n        # con l'eccezione della presenza della parola read nel path che indica una bulk in lettura\n        if self._get_only and not (read and bulk) and not query:\n            raise ValueError('you are trying to access a not get_only API')\n\n        # tutto quello che non \u00e8 bulk e query gli viene impedito di paginare\n        # mentre le bulk e query post/delete possono paginare come le get\n        if not bulk and not query:\n            single_page = True\n            warm_start = False\n            _params_.pop('count')\n\n        # le bulk post/delete non devono poter fare warm_start mai, se viene impostato a True \u00e8 per errore e qui viene forzato a False\n        if bulk and not read: warm_start = False\n\n    url = f'{self.root}{path}'\n\n    self.response = []  # reset dell'attributo responce, cosi da non accodare risposte proveninenti da richieste diverse\n\n    @warmstart(active=warm_start, args_ex=[2], verbose=False)\n    @paginate(single_page=single_page, page_size=page_size, skip=_params_['skip'], limit=_params_['limit'], bulk=bulk)\n    @timeout_retry(max_tries=self._timeout_retry, sleep_time=self._timeout_sleep_time)\n    @ratelimiter(per_minute=self._rate_limit_per_minute)\n    def run_request(_mode, _url, _headers, _payload, _params, **_kwargs):\n        self.num_items = None  # inizializzo a 0 il valore della count, cosi che non possa leggere il numero sbagliato dopo una richiesta non corretta\n\n        logger.debug(f'request url: {_url}')\n        logger.debug(f'request params (skip and limit may differ from your setting due pagination): {_params}')\n        logger.debug(f'request payload: {_payload}')\n\n        response = get_session(\n            self._timeout,\n            self._timeout_get_session_retry,\n            self._timeout_get_session_backoff_factor\n            ).request(\n                      _mode,\n                      url=_url,\n                      json=_payload,\n                      params=_params,\n                      headers=_headers,\n                      verify=self._SSL_verify,\n                      **_kwargs)\n\n        if response.status_code == 401: raise UnauthorizedException\n\n        # 504 non e' gestito dalle API per cui la responce non sarebbe json serializable\n        # 204 e' semplicemente vuoto\n        if response.status_code != 200 and response.status_code != 504 and response.status_code != 204:\n            try:\n                logger.error(response.json())\n            except ValueError:\n                logger.error(f'Non-JSON error response: {response.text}')\n\n        response.raise_for_status()\n\n        if response.status_code == 200 and _params.get('count', False):\n            self.num_items = response.headers.get('x-num-items', None)\n\n        # 204 rappresenta risposta vuota ma se non mi viene dato il type del content viene matenuto dentro alla risposta una stringa 'b'\n        # che rappresenta la fine di uno streaming di dati vuoto. Per evitare questo problema, in assenza di Content-Type, lo aggiorno\n        # a text, cosi che poi venga gestito correttamente dal response.text che toglie la 'b' di chiusura streaming.\n        if response.status_code == 204 and response.headers.get('Content-Type', None) is None:\n            response.headers['Content-Type'] = 'text/plain'\n\n        # Decodifica della risposta in base al tipo di contenuto\n        content_type = response.headers.get('Content-Type', '')\n        if 'application/json' in content_type:\n            body = response.json()\n        elif 'text/html' in content_type or 'text/plain' in content_type:\n            body = response.text\n        else:\n            # fallback per contenuti non gestiti esplicitamente\n            logger.warning(f'Unknown content type \"{content_type}\", returning raw content.')\n            body = response.content\n\n        logger.debug(f'Response: {body}')\n        logger.debug(f'header: {response.headers}')\n\n        self.response.append(response)  # sotto forma di lista perche se la risposta viene paginata questa viene spezzata su piu risposte\n\n        # viene inviato il codice della chiamata cosi che in fase di paginazione possa gestire alcune casisteche speciali\n        return body, response.status_code\n\n    return run_request(mode, url, _headers_, _payload_, _params_, **kwargs)\n</code></pre>"},{"location":"hive.api/#hive.api.ApiManager.get_post","title":"<code>get_post(url_get, url_post=None, get_params=None, post_params=None, prefix=None, add_post_params=None, silence_put=False)</code>","text":"<p>metodo che prova a fare una get con i parametri selezionati, se la get fallisce perche mancavano i dati richiesti allora viene fatta una post per creare il dato cercato</p> <p>Parameters:</p> Name Type Description Default <code>url_get</code> <code>str</code> <p>url dell'api di get</p> required <code>url_post</code> <code>str</code> <p>url dell'api di post, se non viene fornito nessun url, viene usato quello della get. Default to None.</p> <code>None</code> <code>get_params</code> <code>dict</code> <p>parametri della api di get. Default to None.</p> <code>None</code> <code>post_params</code> <code>dict</code> <p>parametri della api di post. Default to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>nel caso la get fornisse un risposta con piu elementi, il prefix rappresenta la parte del nome che ci si aspetta sia presente nell'elemento da usare. Default to None.</p> <code>None</code> <code>add_post_params</code> <code>dict</code> <p>parametri della post, put che non rientrano nel payload</p> <code>None</code> <code>silence_put</code> <code>bool</code> <p>se a True le put non vengono fatte.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>uuid</code> <code>str</code> <p>uuid dell'oggetto richiesto</p> <code>get_count</code> <code>int</code> <p>1 se il metodo e' risultato in una get e 0 se e' risultato in una post</p> <code>post_count</code> <code>int</code> <p>1 se il metodo e' risutltato in una post e 0 se e' risultato in una get</p> Source code in <code>hive/api.py</code> <pre><code>def get_post(self, url_get: str, url_post: str = None, get_params: dict = None, post_params: dict = None,\n             prefix: str = None, add_post_params: dict = None, silence_put: bool = False) -&gt; Tuple[str, int, int, int]:\n    \"\"\"\n    metodo che prova a fare una get con i parametri selezionati, se la get fallisce perche mancavano i dati\n    richiesti allora viene fatta una post per creare il dato cercato\n\n    Args:\n        url_get (str): url dell'api di get\n        url_post (str, optional): url dell'api di post, se non viene fornito nessun url, viene usato quello della\n            get. Default to None.\n        get_params (dict, optional): parametri della api di get. Default to None.\n        post_params (dict, optional): parametri della api di post. Default to None.\n        prefix (str, optional): nel caso la get fornisse un risposta con piu elementi, il prefix rappresenta la\n            parte del nome che ci si aspetta sia presente nell'elemento da usare. Default to None.\n        add_post_params (dict, optional): parametri della post, put che non rientrano nel payload\n        silence_put (bool, optional): se a True le put non vengono fatte.\n\n    Returns:\n        uuid (str): uuid dell'oggetto richiesto\n        get_count (int): 1 se il metodo e' risultato in una get e 0 se e' risultato in una post\n        post_count (int): 1 se il metodo e' risutltato in una post e 0 se e' risultato in una get\n    \"\"\"\n    if get_params is None: get_params = {}\n    if post_params is None: post_params = {}\n    url_post = url_get if url_post is None else url_post\n    get_count, post_count, put_count = 0, 0, 0\n\n    # se uno passa lo stesso dizionario sia per get che per post, con la seguente riga impedisce di applicare le modifiche fatte alla get anche alla post\n    get_params = get_params.copy()\n    post_params = post_params.copy()\n\n    # a meno di definizioni diverse le chiamate get vengono sempre fatte in like = False\n    get_params['like'] = get_params.get('like', False)\n\n    try:\n        # il primo tentativo e' di chiedere l'oggetto con una get\n        response_content = self.execute('GET', url_get, params=get_params)\n        # se e' stato inserito un prefisso questo viene usato per selezionare solo la riposta con quel prefisso\n        if prefix is not None:\n            response_content = [g for g in response_content if g['name'].startswith(prefix)]\n        # se la risposta e' un vettore a lunghezza 0 allora viene postato un elemento con le caratteristiche cercate\n        if len(response_content) == 0:\n            # in fase di testing non viene postato nulla\n            if self._get_only:\n                response_content = [{'uuid': 'F4FF'+str(uuid4())[4:]}]\n            else:\n                # viene postato l'elemento con le caratteristiche richieste\n                response_content = self.execute('POST', url_post, payload=post_params, params=add_post_params)\n            post_count = 1\n        else:\n            # se post_params \u00e8 vuoto o se siamo in modalita silence, la put non viene provata\n            if post_params and not silence_put:\n                # se l'oggetto esiste controllo le sue chiavi\n                for chiave in post_params:  # ciclo sulle chiavi dei parametri postabili\n                    # se incontro un parametro di quelli decisi per il post che \u00e8 abbinato ad un valore diverso rispetto\n                    # a quello che \u00e8 nella risposta, allora faccio una put\n                    if post_params[chiave] != response_content[0][chiave]:\n                        # estraggo lo uuid dell'oggetto\n                        uuid = response_content[0]['uuid']\n                        # compio la put con il nuovo set di parametri\n                        if not self._get_only:\n                            response_content = self.execute('PUT', url_post+uuid, payload=post_params, params=add_post_params)\n                        # alzo il contatore delle put\n                        put_count = 1\n                        # se ho fatto una put non continuo con il ciclo\n                        break\n            # se ho fatto una put non alzo anche il contatore delle get\n            get_count = 1 if put_count == 0 else 0\n\n    # se la risposta alla prima get era un errore questo viene catturato qui\n    except HTTPError as e:\n        # se l'errore era un 404 o un 405 significa che l'oggetto non esiste e viene quindi postato come sopra\n        if e.response.status_code in [404, 405]:\n            if self._get_only:\n                response_content = [{'uuid': 'F4FF'+str(uuid4())[4:]}]\n            else:\n                response_content = self.execute('POST', url_post, payload=post_params)\n            post_count = 1\n        else:\n            # ogni altro errore viene restituito come tale\n            print(e.response.json())\n            raise ValueError(e)\n\n    return response_content[0]['uuid'], get_count, post_count, put_count\n</code></pre>"},{"location":"hive.api/#hive.api.ApiManager.get_post_bulk","title":"<code>get_post_bulk(post_params, url_get, url_post=None, url_put=None, add_get_params=None, add_post_params=None, silence_put=False, page_size=5000)</code>","text":"<p>metodo che prova a fare una get con i parametri selezionati, se la get fallisce perche mancavano i dati richiesti allora viene fatta una post per creare il dato cercato. La risposta ha lo stesso ordine della lista post_params</p> <p>Parameters:</p> Name Type Description Default <code>post_params</code> <code>list[dict]</code> <p>parametri della api di post. Default to None.</p> required <code>url_get</code> <code>str</code> <p>url dell'api di get</p> required <code>url_post</code> <code>str</code> <p>url dell'api di post, se non viene fornito nessun url, viene usato quello della get. Default to None.</p> <code>None</code> <code>url_put</code> <code>str</code> <p>url dell'api di put</p> <code>None</code> <code>add_get_params</code> <code>dict</code> <p>parametri della get che non rientrano nel payload. Default to None.</p> <code>None</code> <code>add_post_params</code> <code>dict</code> <p>parametri della post, put che non rientrano nel payload</p> <code>None</code> <code>silence_put</code> <code>bool</code> <p>se a True le put non vengono fatte.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>numero di elementi che vengono caricati in un unica chiamata</p> <code>5000</code> <p>Returns:</p> Name Type Description <code>uuid</code> <code>list[str]</code> <p>lista di tutti gli uuid degli oggetti richiesti, ordinati come il vettore post_params</p> <code>get_count</code> <code>int</code> <p>1 se il metodo e' risultato in una get e 0 se e' risultato in una post</p> <code>post_count</code> <code>int</code> <p>1 se il metodo e' risutltato in una post e 0 se e' risultato in una get</p> <code>put_count</code> <code>int</code> <p>1 se il metodo e' risutlato in una put e 0 se e' risultato in una put</p> Source code in <code>hive/api.py</code> <pre><code>def get_post_bulk(self, post_params: List[dict], url_get: str, url_post: str = None, url_put: str = None,\n                  add_get_params: dict = None, add_post_params: dict = None, silence_put: bool = False,\n                  page_size: int = 5000) -&gt; Tuple[List[str], int, int, int]:\n    \"\"\"\n    metodo che prova a fare una get con i parametri selezionati, se la get fallisce perche mancavano i dati\n    richiesti allora viene fatta una post per creare il dato cercato. La risposta ha lo stesso ordine della lista\n    post_params\n\n    Args:\n        post_params (list[dict], optional): parametri della api di post. Default to None.\n        url_get (str): url dell'api di get\n        url_post (str, optional): url dell'api di post, se non viene fornito nessun url, viene usato quello della\n            get. Default to None.\n        url_put (str): url dell'api di put\n        add_get_params (dict, optional): parametri della get che non rientrano nel payload. Default to None.\n        add_post_params (dict, optional): parametri della post, put che non rientrano nel payload\n        silence_put (bool, optional): se a True le put non vengono fatte.\n        page_size (int, optional): numero di elementi che vengono caricati in un unica chiamata\n\n    Returns:\n        uuid (list[str]): lista di tutti gli uuid degli oggetti richiesti, ordinati come il vettore post_params\n        get_count (int): 1 se il metodo e' risultato in una get e 0 se e' risultato in una post\n        post_count (int): 1 se il metodo e' risutltato in una post e 0 se e' risultato in una get\n        put_count (int): 1 se il metodo e' risutlato in una put e 0 se e' risultato in una put\n    \"\"\"\n\n    # se viene dato il solo elemento dell'url, questo viene convertito nella sua versione bulk\n    if 'bulk/read' not in url_get: url_get = '/' + url_get.lstrip('/').rstrip('/') + '/bulk/read_by/'\n    else:                          url_get = '/' + url_get.lstrip('/').rstrip('/') + '/'\n\n    # inizializzo url post se non viene passato\n    if url_post is None: url_post = url_get.split('bulk/read')[0]\n    if 'bulk/create' not in url_post: url_post = '/' + url_post.lstrip('/').rstrip('/') + '/bulk/create/'\n    else:                             url_post = '/' + url_post.lstrip('/').rstrip('/') + '/'\n\n    # inizializzo url put se non viene passato\n    url_put = url_get.split('bulk')[0] if url_put is None else url_put\n    url_put = '/' + url_put.lstrip('/').rstrip('/') + '/'\n\n    method = url_get.split('/')[1]\n    if method not in ['customers', 'virtual_domains', 'sites', 'groups', 'objects', 'metric_types', 'metrics', 'services']:\n        raise NotImplementedError(f'the {method} has not been implemented')\n\n    get_count, post_count, put_count = 0, 0, 0\n\n    # se uno passa lo stesso dizionario sia per get che per post, con la seguente riga impedisce di applicare le modifiche fatte alla get anche alla post\n    post_params = post_params.copy()\n\n    # ottengo le chiavi univoche da un dizionario\n    chiavi_dict = {'customers': Keys.customer_keys, 'virtual_domains': Keys.virtual_domain_keys, 'sites': Keys.site_keys,\n                   'groups': Keys.group_keys, 'objects': Keys.object_keys, 'metric_types': Keys.metric_type_keys,\n                   'metrics': Keys.metric_keys, 'services': Keys.service_keys}\n    chiavi = chiavi_dict[method]['univocal']\n\n    # si chiedono tutti gli oggetti in con la get e si ottiene una lista di riposta con gli uuid di quelli trovati e dei None per quelli non trovati\n    # non serve filtrare le richieste alla get con le sole chiavi primarie perche l'API fa il filtro internamente\n    response_content_temp = self.execute('POST', url_get, payload=post_params, params=add_get_params, page_size=page_size)  # questo metodo puo introdurre dei duplicati se lo stesso oggetto viene chiesto piu volte e si sta paginando\n\n    # creo un dizionario con gli elementi primari come chiavi e le rispote come valori\n    response_content_temp_dict = dict()\n    for cont in response_content_temp:\n        # creo le chiavi con il risultato dei valori degli elementi primari\n        chiave = tuple(cont[k] for k in chiavi)\n        # abbino a questa chiave il contenuto della risposta\n        response_content_temp_dict[chiave] = cont\n\n    # precrea una lista vuota\n    response_content = [None for _ in range(len(post_params))]\n    # seleziono dalla lista postata gli indici degli elementi che hanno dato un None come risultato dalla get\n    id_element_to_post, id_element_getted, key_post = [], [], []\n\n    # creo un dizionario con gli elementi primari come chiavi e le rispote come valori\n    post_params_dict = dict()\n    # cicla su tutti gli elementi e discrimino quelli che sono gia stati ottenuti da quelli che mancano\n    for i, ele in enumerate(post_params):\n        # creo le chiavi con il risultato dei valori degli elementi primari\n        chiave = tuple(ele[k] for k in chiavi)\n        # abbino a questa chiave il contenuto della risposta\n        post_params_dict[chiave] = ele\n\n        # vado a cercare nella risposta se presente la chiave cercata, in caso positivo inserisco quel valore come elemento del vettore risposte\n        # questo mi garantisce di mantenere lo stesso ordine delle richieste\n        # se una richiesta genera piu risposte viene considerata solo l'ultima\n        # se una richiesta non genera nessuna risposta viene abbinato il None\n        # se vengono fatte piu richieste uguali vengono abbinati sempre gli stessi risultati tutte le volte che sono stati chiesti\n        # a senconda se il responce e' None o meno popolo un vettore diverso dell'incide\n        if chiave in response_content_temp_dict:\n            response_content[i] = response_content_temp_dict[chiave]\n            id_element_getted.append(i)\n        else:\n            response_content[i] = chiave\n            id_element_to_post.append(i)\n            # mi creo una lista che contiene le chiavi primarie degli oggetti da postare\n            key_post.append(tuple(ele[k] for k in chiavi))\n\n    # ottendo le chiavi univoche per postare gli elementi, eliminando eventuali ripetizioni\n    key_post = set(key_post)\n    # il numero delle post sono tutti gli elementi che non sono tornati da una get\n    post_count = len(key_post)\n\n    ###################################################\n    put_count = self._put_cicle(add_post_params, chiavi, post_params_dict, put_count, response_content_temp_dict, silence_put, url_put)\n    # il numero delle get reali sono il numero di chiavi uniche presenti nella riposta delle get, meno quelli su cui e' stata fatta una put\n    get_count = len(response_content_temp_dict) - put_count\n    ###################################################\n\n    # prese le chiavi univoche degli elementi da postare, vengono recuperati gli oggetti da postare dal dizionario dei parametri da postare\n    element_to_post = [post_params_dict[id_key] for id_key in key_post]\n\n    # faccio la post di tutti gli elementi che hanno dato None nella get\n    # se in modalita test genero gli uuid\n    if len(element_to_post) &gt; 0:\n        if self._get_only: response_content_post = ['F4FF' + str(uuid4())[4:] for _ in range(len(element_to_post))]\n        else:\n            response_content_post_raw = self.execute('POST', url_post, payload=element_to_post, params=add_post_params,\n                                                     page_size=page_size)\n            # la risposta di una post e' costituita da [{success: num, failed: num, uuids: [uuid1, uuid2]} , {}, ...]\n            # per mettere assieme tutti gli uuid presenti su piu pagine va aperto ogni json e messi gli uuid in un vettore\n            response_content_post = []\n            for item in response_content_post_raw:\n                response_content_post += item[\"uuids\"]\n\n            del response_content_post_raw\n\n        post_to_key_res_dict = dict()\n        for i, id_key in enumerate(key_post):\n            post_to_key_res_dict[id_key] = response_content_post[i]\n\n        # inserisco i nuovi uuid trovati nella risposta originale\n        for i, _id in enumerate(id_element_to_post):\n            chiave = response_content[_id]\n            response_content[_id] = {'uuid': post_to_key_res_dict[chiave]}\n\n    # seleziono dalla lista postata gli indici degli elementi che hanno dato un None come risultato dalla get\n    uuid_res = []\n    none_count = 0\n    for val in response_content:\n        if val is None:\n            uuid_res.append(val)\n            none_count += 1\n        else:\n            uuid_res.append(val['uuid'])\n\n    if none_count &gt; 0:\n        logger.warning(f'{none_count} elements have not been matched with a uuid and can be found as None in the resutl list')\n\n    return uuid_res, get_count, post_count, put_count\n</code></pre>"},{"location":"hive.api/#hive.api.ApiManager.openapi","title":"<code>openapi()</code>","text":"<p>metodo che restituisce gli schema degli end point</p> Source code in <code>hive/api.py</code> <pre><code>def openapi(self):\n    \"\"\"metodo che restituisce gli schema degli end point\"\"\"\n    response = get_session(self._timeout, self._timeout_get_session_retry, self._timeout_get_session_backoff_factor).request('GET', url=f'{self.root}/openapi.js',\n                                                  headers={'Authorization': f'Bearer {self.token}'}, verify=self._SSL_verify)\n    data = json.loads(response.content[15:].decode('utf-8'))\n    return data\n</code></pre>"},{"location":"hive.api/#hive.api.XautomataApi","title":"<code>XautomataApi</code>","text":"<p>               Bases: <code>AclDocs</code>, <code>AclOverrides</code>, <code>Calendars</code>, <code>CostTagging</code>, <code>CostTags</code>, <code>CostViews</code>, <code>CostTreeNodes</code>, <code>CostTreeResources</code>, <code>Contacts</code>, <code>Customers</code>, <code>Dashboards</code>, <code>Dispatchers</code>, <code>Downtimes</code>, <code>ExternalTickets</code>, <code>Features</code>, <code>Files</code>, <code>Groups</code>, <code>AutomataIngest</code>, <code>MetricIngest</code>, <code>Microsoft</code>, <code>Google</code>, <code>Apple</code>, <code>Login</code>, <code>QrCode</code>, <code>Jobs</code>, <code>Messages</code>, <code>Metrics</code>, <code>ProbesLogIngest</code>, <code>MetricTypes</code>, <code>NotificationProviders</code>, <code>NotificationProviderTypes</code>, <code>Objects</code>, <code>Probes</code>, <code>ProbeTypes</code>, <code>ProfileTopics</code>, <code>Questions</code>, <code>RetentionRules</code>, <code>Services</code>, <code>Sites</code>, <code>LastStatus</code>, <code>LastObjectStatus</code>, <code>TermsAndConditions</code>, <code>Tests</code>, <code>TreeHierarchy</code>, <code>TsAutomataState</code>, <code>TsCostAzureRaw</code>, <code>TsCostManagement</code>, <code>TsMetricStatus</code>, <code>TsMetricValue</code>, <code>TsNtopFlows</code>, <code>TsServiceStatus</code>, <code>TsServiceValue</code>, <code>Users</code>, <code>UsersNotifications</code>, <code>VirtualDomains</code>, <code>Widgets</code>, <code>Webhooks</code>, <code>WidgetGroups</code></p> <p>Class with each specific API, based on the ApiManager Class created for a more general interaction with Xautomata API</p> Source code in <code>hive/api.py</code> <pre><code>class XautomataApi(AclDocs, AclOverrides, Calendars, CostTagging, CostTags, CostViews, CostTreeNodes, CostTreeResources, Contacts, Customers, Dashboards, Dispatchers, Downtimes, ExternalTickets, Features, Files, Groups, AutomataIngest, MetricIngest, Microsoft, Google, Apple, Login, QrCode, Jobs, Messages, Metrics, ProbesLogIngest, MetricTypes, NotificationProviders, NotificationProviderTypes, Objects, Probes, ProbeTypes, ProfileTopics, Questions, RetentionRules, Services, Sites, LastStatus, LastObjectStatus, TermsAndConditions, Tests, TreeHierarchy, TsAutomataState, TsCostAzureRaw, TsCostManagement, TsMetricStatus, TsMetricValue, TsNtopFlows, TsServiceStatus, TsServiceValue, Users, UsersNotifications, VirtualDomains, Widgets, Webhooks, WidgetGroups):\n    \"\"\"\n    Class with each specific API, based on the ApiManager Class created for a more general interaction with Xautomata API\n    \"\"\"\n\n    active_items = {\n        \"customer_status\": \"A\",\n        \"site_status\": \"A\",\n        \"group_status\": \"A\",\n        \"object_status\": \"A\",\n        \"metric_type_status\": \"A\",\n        \"metric_status\": \"A\",\n        \"service_status\": \"A\"\n    }\n\n    active_items_bulk = {\n        \"customer_status\": [\"A\"],\n        \"site_status\": [\"A\"],\n        \"group_status\": [\"A\"],\n        \"object_status\": [\"A\"],\n        \"metric_type_status\": [\"A\"],\n        \"metric_status\": [\"A\"],\n        \"service_status\": [\"A\"]\n    }\n\n    @staticmethod\n    def multi_method(method, name_to_cicle: str, multi_uuid: list, single_page: bool = False, page_size: int = 5000,\n                     warm_start: bool = False, position: int = 0,  kwargs: dict = None, **params):\n        \"\"\"\n        metodo generico per iterare un metodo selezionato su una lista di parametri scelti.\n\n        Args:\n            method: metodo di XautomataApi\n            name_to_cicle (str): nome dell'argomento del metodo scelto su cui iterare\n            multi_uuid (list): lista di valori su cui iterare\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            position (int, optional): posizione della barra di caricamento. Default to 0.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API\n\n        Returns: list\n\n        \"\"\"\n\n        @warmstart(active=warm_start, verbose=False, kwargs_ex=['_method'])\n        def run_multi(method_name, _method, _name_to_cicle, _multi_uuid, _single_page, _page_size, _kwargs, **_params):\n            # method_name e' correttamente non usato, serve come chiave da usare nel warmstart che riconosce cosi se\n            # e' cambiato il metodo usato\n            _response = []\n            pbar_uuids = tqdm(_multi_uuid, position=position, leave=True, ascii=True, unit=_name_to_cicle)\n            for uuid in pbar_uuids:\n                temp_response = _method(**{_name_to_cicle: uuid}, single_page=_single_page, page_size=_page_size,\n                                        warm_start=False, kwargs=_kwargs, **_params)\n                _response += temp_response\n                del temp_response\n                gc.collect()\n            return _response\n\n        response = run_multi(method.__name__, _method=method, _name_to_cicle=name_to_cicle, _multi_uuid=multi_uuid,\n                             _single_page=single_page, _page_size=page_size, _kwargs=kwargs, **params)\n\n        return response\n\n    @staticmethod\n    def multi_method_put(method, multi_uuid: list, position: int = 0,  kwargs: dict = None, **payload):\n        \"\"\"\n        metodo generico per iterare un metodo selezionato su una lista di parametri scelti.\n\n        Args:\n            method: metodo di XautomataApi\n            multi_uuid (list): lista di valori su cui iterare\n            position (int, optional): posizione della barra di caricamento. Default to 0.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\n\n        \"\"\"\n\n        response = []\n        pbar_uuids = tqdm(multi_uuid, position=position, leave=True, ascii=True, unit=' uuids')\n        for uuid in pbar_uuids:\n            temp_response = method(uuid=uuid, kwargs=kwargs, **payload)\n            response += temp_response\n            del temp_response\n            gc.collect()\n\n        return response\n\n    def dispatcher_linker(self, uuids: list, types: Literal['services', 'metrics', 'metric_types', 'objects', 'groups'],\n                          messages: dict, calendar: dict, dispatcher: dict, notification_provider_types: dict = None, notification_providers: dict = None):\n        \"\"\"\n        create a dispatcher with the entire chain of elements to be used on a specific metric\n\n        Args:\n            uuids (list): list of uuid for the element to be linked with a dispatcher\n            types (Literal['services', 'metrics', 'metric_types', 'objects', 'groups']): type of uuids in the uuid list\n            notification_provider_types (dict): set of parameters to get or create a notification_provider_types\n            notification_providers (dict): set of parameters to get or create a notification_providers\n            messages (dict): set of parameters to get or create a messages\n            calendar (dict): set of parameters to get or create a calendar\n            dispatcher (dict): set of parameters to get or create a dispatcher\n\n        Examples:\n            notification_provider_types = {\n                \"code\": code,\n                \"json_schema\": {}\n            }\n\n            notification_providers = {\n                \"app_name\": app_name,\n                \"endpoint\": {}\n            }\n\n            messages = {\n                \"code\": \"string\",\n                \"description\": \"string\",\n                \"mask\": \"string\",\n                \"mask_mime_type\": \"string\",\n                \"additional_mask\": \"string\",\n                \"additional_mask_mime_type\": \"string\"\n            }\n\n            calendar = {\n                \"name\": name_caledar,\n                \"local_public_holidays\": True,\n                \"mon_int1_start\": \"string\",\n                \"mon_int1_end\": \"string\",\n                \"mon_int2_start\": \"string\",\n                \"mon_int2_end\": \"string\",\n                \"tue_int1_start\": \"string\",\n                \"tue_int1_end\": \"string\",\n                \"tue_int2_start\": \"string\",\n                \"tue_int2_end\": \"string\",\n                \"wed_int1_start\": \"string\",\n                \"wed_int1_end\": \"string\",\n                \"wed_int2_start\": \"string\",\n                \"wed_int2_end\": \"string\",\n                \"thu_int1_start\": \"string\",\n                \"thu_int1_end\": \"string\",\n                \"thu_int2_start\": \"string\",\n                \"thu_int2_end\": \"string\",\n                \"fri_int1_start\": \"string\",\n                \"fri_int1_end\": \"string\",\n                \"fri_int2_start\": \"string\",\n                \"fri_int2_end\": \"string\",\n                \"sat_int1_start\": \"string\",\n                \"sat_int1_end\": \"string\",\n                \"sat_int2_start\": \"string\",\n                \"sat_int2_end\": \"string\",\n                \"sun_int1_start\": \"string\",\n                \"sun_int1_end\": \"string\",\n                \"sun_int2_start\": \"string\",\n                \"sun_int2_end\": \"string\",\n            }\n\n            dispatcher = {\n              \"uuid_opening_reason\": \"string\",\n              \"uuid_reason_for_closure\": \"string\",\n              \"code\": \"string\",\n              \"description\": \"string\",\n              \"delay\": 0,\n              \"status\": \"s\",\n              \"country\": \"st\",\n              \"state_province\": \"string\",\n              \"data_profile\": [\n                \"string\"\n              ],\n                \"remember_it\": True\n            }\n        \"\"\"\n\n        def select_get_params(_params: dict, get_keys: tuple):\n            return dict((k, _params[k]) for k in get_keys)\n\n        uuid_np = 0\n        if notification_provider_types is not None:\n            # notification provider types\n            uuid_npt, _, _, _ = self.get_post(url_get='/notification_provider_types/',\n                                              get_params=select_get_params(notification_provider_types, ('code',)),\n                                              post_params=notification_provider_types)\n            print(f'notification provider type has been set ({uuid_npt})')\n\n            notification_providers['uuid_notification_provider_type'] = uuid_npt\n            # notification providers\n            uuid_np, _, _, _ = self.get_post(url_get='/notification_providers/',\n                                             get_params=select_get_params(notification_providers, ('uuid_notification_provider_type', 'app_name')),\n                                             post_params=notification_providers)\n            print(f'notification provider has been set ({uuid_np})')\n\n        # messages\n        uuid_m, _, _, _ = self.get_post(url_get='/messages/',\n                                        get_params=select_get_params(messages, ('code', 'description', 'mask')),\n                                        post_params=messages)\n        print(f'message has been set ({uuid_m})')\n\n        # calendar\n        # chiedi un calendar per nome\n        # se passi un json post_put del calender in json\n        uuid_calendar, _, _, _ = self.get_post(url_get='/calendar/',\n                                               get_params=select_get_params(calendar, ('name', 'local_public_holidays')),\n                                               post_params=calendar)\n        print(f'calendar has been set ({uuid_calendar})')\n\n        if notification_provider_types is not None: dispatcher['uuid_notification_provider'] = uuid_np\n        dispatcher[\"uuid_calendar\"] = uuid_calendar\n        dispatcher[\"uuid_message\"] = uuid_m\n\n        # dispatcher\n        uuid_d, _, _, _ = self.get_post(url_get='/dispatcher/',\n                                        get_params=select_get_params(dispatcher, ('tuple_required', 'uuid_message', 'code', 'status',)),\n                                        post_params=dispatcher)\n        print(f'dispatcher has been set ({uuid_d})')\n\n        # COLLEGAMENTO\n        # lista degli uuid degli oggetti da legare a questo dispacter\n        for uuid in uuids:\n            self.execute(mode='POST', path=f'/dispatchers/{uuid_d}/{types}/{uuid}')\n        print(f'all the {types} have been linked with the selected dispatcher')\n</code></pre>"},{"location":"hive.api/#hive.api.XautomataApi.dispatcher_linker","title":"<code>dispatcher_linker(uuids, types, messages, calendar, dispatcher, notification_provider_types=None, notification_providers=None)</code>","text":"<p>create a dispatcher with the entire chain of elements to be used on a specific metric</p> <p>Parameters:</p> Name Type Description Default <code>uuids</code> <code>list</code> <p>list of uuid for the element to be linked with a dispatcher</p> required <code>types</code> <code>Literal['services', 'metrics', 'metric_types', 'objects', 'groups']</code> <p>type of uuids in the uuid list</p> required <code>notification_provider_types</code> <code>dict</code> <p>set of parameters to get or create a notification_provider_types</p> <code>None</code> <code>notification_providers</code> <code>dict</code> <p>set of parameters to get or create a notification_providers</p> <code>None</code> <code>messages</code> <code>dict</code> <p>set of parameters to get or create a messages</p> required <code>calendar</code> <code>dict</code> <p>set of parameters to get or create a calendar</p> required <code>dispatcher</code> <code>dict</code> <p>set of parameters to get or create a dispatcher</p> required <p>Examples:</p> <p>notification_provider_types = {     \"code\": code,     \"json_schema\": {} }</p> <p>notification_providers = {     \"app_name\": app_name,     \"endpoint\": {} }</p> <p>messages = {     \"code\": \"string\",     \"description\": \"string\",     \"mask\": \"string\",     \"mask_mime_type\": \"string\",     \"additional_mask\": \"string\",     \"additional_mask_mime_type\": \"string\" }</p> <p>calendar = {     \"name\": name_caledar,     \"local_public_holidays\": True,     \"mon_int1_start\": \"string\",     \"mon_int1_end\": \"string\",     \"mon_int2_start\": \"string\",     \"mon_int2_end\": \"string\",     \"tue_int1_start\": \"string\",     \"tue_int1_end\": \"string\",     \"tue_int2_start\": \"string\",     \"tue_int2_end\": \"string\",     \"wed_int1_start\": \"string\",     \"wed_int1_end\": \"string\",     \"wed_int2_start\": \"string\",     \"wed_int2_end\": \"string\",     \"thu_int1_start\": \"string\",     \"thu_int1_end\": \"string\",     \"thu_int2_start\": \"string\",     \"thu_int2_end\": \"string\",     \"fri_int1_start\": \"string\",     \"fri_int1_end\": \"string\",     \"fri_int2_start\": \"string\",     \"fri_int2_end\": \"string\",     \"sat_int1_start\": \"string\",     \"sat_int1_end\": \"string\",     \"sat_int2_start\": \"string\",     \"sat_int2_end\": \"string\",     \"sun_int1_start\": \"string\",     \"sun_int1_end\": \"string\",     \"sun_int2_start\": \"string\",     \"sun_int2_end\": \"string\", }</p> <p>dispatcher = {   \"uuid_opening_reason\": \"string\",   \"uuid_reason_for_closure\": \"string\",   \"code\": \"string\",   \"description\": \"string\",   \"delay\": 0,   \"status\": \"s\",   \"country\": \"st\",   \"state_province\": \"string\",   \"data_profile\": [     \"string\"   ],     \"remember_it\": True }</p> Source code in <code>hive/api.py</code> <pre><code>def dispatcher_linker(self, uuids: list, types: Literal['services', 'metrics', 'metric_types', 'objects', 'groups'],\n                      messages: dict, calendar: dict, dispatcher: dict, notification_provider_types: dict = None, notification_providers: dict = None):\n    \"\"\"\n    create a dispatcher with the entire chain of elements to be used on a specific metric\n\n    Args:\n        uuids (list): list of uuid for the element to be linked with a dispatcher\n        types (Literal['services', 'metrics', 'metric_types', 'objects', 'groups']): type of uuids in the uuid list\n        notification_provider_types (dict): set of parameters to get or create a notification_provider_types\n        notification_providers (dict): set of parameters to get or create a notification_providers\n        messages (dict): set of parameters to get or create a messages\n        calendar (dict): set of parameters to get or create a calendar\n        dispatcher (dict): set of parameters to get or create a dispatcher\n\n    Examples:\n        notification_provider_types = {\n            \"code\": code,\n            \"json_schema\": {}\n        }\n\n        notification_providers = {\n            \"app_name\": app_name,\n            \"endpoint\": {}\n        }\n\n        messages = {\n            \"code\": \"string\",\n            \"description\": \"string\",\n            \"mask\": \"string\",\n            \"mask_mime_type\": \"string\",\n            \"additional_mask\": \"string\",\n            \"additional_mask_mime_type\": \"string\"\n        }\n\n        calendar = {\n            \"name\": name_caledar,\n            \"local_public_holidays\": True,\n            \"mon_int1_start\": \"string\",\n            \"mon_int1_end\": \"string\",\n            \"mon_int2_start\": \"string\",\n            \"mon_int2_end\": \"string\",\n            \"tue_int1_start\": \"string\",\n            \"tue_int1_end\": \"string\",\n            \"tue_int2_start\": \"string\",\n            \"tue_int2_end\": \"string\",\n            \"wed_int1_start\": \"string\",\n            \"wed_int1_end\": \"string\",\n            \"wed_int2_start\": \"string\",\n            \"wed_int2_end\": \"string\",\n            \"thu_int1_start\": \"string\",\n            \"thu_int1_end\": \"string\",\n            \"thu_int2_start\": \"string\",\n            \"thu_int2_end\": \"string\",\n            \"fri_int1_start\": \"string\",\n            \"fri_int1_end\": \"string\",\n            \"fri_int2_start\": \"string\",\n            \"fri_int2_end\": \"string\",\n            \"sat_int1_start\": \"string\",\n            \"sat_int1_end\": \"string\",\n            \"sat_int2_start\": \"string\",\n            \"sat_int2_end\": \"string\",\n            \"sun_int1_start\": \"string\",\n            \"sun_int1_end\": \"string\",\n            \"sun_int2_start\": \"string\",\n            \"sun_int2_end\": \"string\",\n        }\n\n        dispatcher = {\n          \"uuid_opening_reason\": \"string\",\n          \"uuid_reason_for_closure\": \"string\",\n          \"code\": \"string\",\n          \"description\": \"string\",\n          \"delay\": 0,\n          \"status\": \"s\",\n          \"country\": \"st\",\n          \"state_province\": \"string\",\n          \"data_profile\": [\n            \"string\"\n          ],\n            \"remember_it\": True\n        }\n    \"\"\"\n\n    def select_get_params(_params: dict, get_keys: tuple):\n        return dict((k, _params[k]) for k in get_keys)\n\n    uuid_np = 0\n    if notification_provider_types is not None:\n        # notification provider types\n        uuid_npt, _, _, _ = self.get_post(url_get='/notification_provider_types/',\n                                          get_params=select_get_params(notification_provider_types, ('code',)),\n                                          post_params=notification_provider_types)\n        print(f'notification provider type has been set ({uuid_npt})')\n\n        notification_providers['uuid_notification_provider_type'] = uuid_npt\n        # notification providers\n        uuid_np, _, _, _ = self.get_post(url_get='/notification_providers/',\n                                         get_params=select_get_params(notification_providers, ('uuid_notification_provider_type', 'app_name')),\n                                         post_params=notification_providers)\n        print(f'notification provider has been set ({uuid_np})')\n\n    # messages\n    uuid_m, _, _, _ = self.get_post(url_get='/messages/',\n                                    get_params=select_get_params(messages, ('code', 'description', 'mask')),\n                                    post_params=messages)\n    print(f'message has been set ({uuid_m})')\n\n    # calendar\n    # chiedi un calendar per nome\n    # se passi un json post_put del calender in json\n    uuid_calendar, _, _, _ = self.get_post(url_get='/calendar/',\n                                           get_params=select_get_params(calendar, ('name', 'local_public_holidays')),\n                                           post_params=calendar)\n    print(f'calendar has been set ({uuid_calendar})')\n\n    if notification_provider_types is not None: dispatcher['uuid_notification_provider'] = uuid_np\n    dispatcher[\"uuid_calendar\"] = uuid_calendar\n    dispatcher[\"uuid_message\"] = uuid_m\n\n    # dispatcher\n    uuid_d, _, _, _ = self.get_post(url_get='/dispatcher/',\n                                    get_params=select_get_params(dispatcher, ('tuple_required', 'uuid_message', 'code', 'status',)),\n                                    post_params=dispatcher)\n    print(f'dispatcher has been set ({uuid_d})')\n\n    # COLLEGAMENTO\n    # lista degli uuid degli oggetti da legare a questo dispacter\n    for uuid in uuids:\n        self.execute(mode='POST', path=f'/dispatchers/{uuid_d}/{types}/{uuid}')\n    print(f'all the {types} have been linked with the selected dispatcher')\n</code></pre>"},{"location":"hive.api/#hive.api.XautomataApi.multi_method","title":"<code>multi_method(method, name_to_cicle, multi_uuid, single_page=False, page_size=5000, warm_start=False, position=0, kwargs=None, **params)</code>  <code>staticmethod</code>","text":"<p>metodo generico per iterare un metodo selezionato su una lista di parametri scelti.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>metodo di XautomataApi</p> required <code>name_to_cicle</code> <code>str</code> <p>nome dell'argomento del metodo scelto su cui iterare</p> required <code>multi_uuid</code> <code>list</code> <p>lista di valori su cui iterare</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>position</code> <code>int</code> <p>posizione della barra di caricamento. Default to 0.</p> <code>0</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API</p> <code>{}</code> <p>Returns: list</p> Source code in <code>hive/api.py</code> <pre><code>@staticmethod\ndef multi_method(method, name_to_cicle: str, multi_uuid: list, single_page: bool = False, page_size: int = 5000,\n                 warm_start: bool = False, position: int = 0,  kwargs: dict = None, **params):\n    \"\"\"\n    metodo generico per iterare un metodo selezionato su una lista di parametri scelti.\n\n    Args:\n        method: metodo di XautomataApi\n        name_to_cicle (str): nome dell'argomento del metodo scelto su cui iterare\n        multi_uuid (list): lista di valori su cui iterare\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        position (int, optional): posizione della barra di caricamento. Default to 0.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API\n\n    Returns: list\n\n    \"\"\"\n\n    @warmstart(active=warm_start, verbose=False, kwargs_ex=['_method'])\n    def run_multi(method_name, _method, _name_to_cicle, _multi_uuid, _single_page, _page_size, _kwargs, **_params):\n        # method_name e' correttamente non usato, serve come chiave da usare nel warmstart che riconosce cosi se\n        # e' cambiato il metodo usato\n        _response = []\n        pbar_uuids = tqdm(_multi_uuid, position=position, leave=True, ascii=True, unit=_name_to_cicle)\n        for uuid in pbar_uuids:\n            temp_response = _method(**{_name_to_cicle: uuid}, single_page=_single_page, page_size=_page_size,\n                                    warm_start=False, kwargs=_kwargs, **_params)\n            _response += temp_response\n            del temp_response\n            gc.collect()\n        return _response\n\n    response = run_multi(method.__name__, _method=method, _name_to_cicle=name_to_cicle, _multi_uuid=multi_uuid,\n                         _single_page=single_page, _page_size=page_size, _kwargs=kwargs, **params)\n\n    return response\n</code></pre>"},{"location":"hive.api/#hive.api.XautomataApi.multi_method_put","title":"<code>multi_method_put(method, multi_uuid, position=0, kwargs=None, **payload)</code>  <code>staticmethod</code>","text":"<p>metodo generico per iterare un metodo selezionato su una lista di parametri scelti.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>metodo di XautomataApi</p> required <code>multi_uuid</code> <code>list</code> <p>lista di valori su cui iterare</p> required <code>position</code> <code>int</code> <p>posizione della barra di caricamento. Default to 0.</p> <code>0</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/api.py</code> <pre><code>@staticmethod\ndef multi_method_put(method, multi_uuid: list, position: int = 0,  kwargs: dict = None, **payload):\n    \"\"\"\n    metodo generico per iterare un metodo selezionato su una lista di parametri scelti.\n\n    Args:\n        method: metodo di XautomataApi\n        multi_uuid (list): lista di valori su cui iterare\n        position (int, optional): posizione della barra di caricamento. Default to 0.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\n\n    \"\"\"\n\n    response = []\n    pbar_uuids = tqdm(multi_uuid, position=position, leave=True, ascii=True, unit=' uuids')\n    for uuid in pbar_uuids:\n        temp_response = method(uuid=uuid, kwargs=kwargs, **payload)\n        response += temp_response\n        del temp_response\n        gc.collect()\n\n    return response\n</code></pre>"},{"location":"hive.api/#hive.api.get_session","title":"<code>get_session(timeout=150, total=5, backoff_factor=5)</code>","text":"<p>Add retry logic and policies about methods and statuses for requests</p> Source code in <code>hive/api.py</code> <pre><code>def get_session(timeout=150, total=5, backoff_factor=5):\n    \"\"\"\n    Add retry logic and policies about methods and statuses for requests\n    \"\"\"\n    ss = requests.Session()\n    retry_strategy = Retry(total=total, status_forcelist=FORCE_STATUS, backoff_factor=backoff_factor)\n    ss.request = functools.partial(ss.request, timeout=timeout, verify=True)\n    ss.mount('https://', HTTPAdapter(max_retries=retry_strategy))\n    ss.mount('http://', HTTPAdapter(max_retries=retry_strategy))\n    return ss\n</code></pre>"},{"location":"hive.api/#hive.api.handling_single_page_methods","title":"<code>handling_single_page_methods(kwargs, params)</code>","text":"<p>metodo per gestire gli kwargs e params dei metodi il cui single_page deve essere forzato a True</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>kwargs</p> required <code>params</code> <p>params</p> required <p>Returns: kwargs, params</p> Source code in <code>hive/api.py</code> <pre><code>def handling_single_page_methods(kwargs, params):\n    \"\"\"\n    metodo per gestire gli kwargs e params dei metodi il cui single_page deve essere forzato a True\n\n    Args:\n        kwargs: kwargs\n        params: params\n\n    Returns: kwargs, params\n    \"\"\"\n    kwargs['single_page'] = True\n    if 'single_page' in list(params.keys()): params.pop('single_page')\n    if 'page_size' in list(params.keys()): params.pop('page_size')\n    return kwargs, params\n</code></pre>"},{"location":"hive.cookbook.acl_docs/","title":"Hive.cookbook.acl docs","text":""},{"location":"hive.cookbook.acl_docs/#hive.cookbook.acl_docs.AclDocs","title":"<code>AclDocs</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata acl_docs APIs</p> Source code in <code>hive/cookbook/acl_docs.py</code> <pre><code>class AclDocs(ApiManager):\n    \"\"\"Class that handles all the XAutomata acl_docs APIs\"\"\"\n\n    def acl_docs(self, warm_start: bool = False, kwargs: dict = None) -&gt; list:\n        \"\"\"Read Acl Docs\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/acl_docs/', warm_start=\n            warm_start, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.acl_docs/#hive.cookbook.acl_docs.AclDocs.acl_docs","title":"<code>acl_docs(warm_start=False, kwargs=None)</code>","text":"<p>Read Acl Docs</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_docs.py</code> <pre><code>def acl_docs(self, warm_start: bool = False, kwargs: dict = None) -&gt; list:\n    \"\"\"Read Acl Docs\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/acl_docs/', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/","title":"Hive.cookbook.acl overrides","text":""},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides","title":"<code>AclOverrides</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata acl_overrides APIs</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>class AclOverrides(ApiManager):\n    \"\"\"Class that handles all the XAutomata acl_overrides APIs\"\"\"\n\n    def acl_overrides(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Acl Overrides\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            json_schema (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code',\n            'json_schema', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('json_schema'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.acl_overrides.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/acl_overrides/', single_page\n            =single_page, page_size=page_size, warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def acl_overrides_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Acl Override\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            acl_override (array object required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'acl_override']\n        payload.get('code'), payload.get('acl_override')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.acl_overrides_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/acl_overrides/', payload=\n            payload, **kwargs)\n        return response\n\n    def acl_override(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Acl Override By Uuid\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/acl_overrides/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def acl_overrides_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Acl Override\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            acl_override (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'acl_override']\n        payload.get('code'), payload.get('acl_override')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.acl_overrides_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/acl_overrides/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def acl_overrides_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Acl Override\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/acl_overrides/{uuid}', **\n            kwargs)\n        return response\n\n    def acl_overrides_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Acl Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.acl_overrides_users.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/acl_overrides/{uuid}/users',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def acl_overrides_users_create(self, uuid: str, name: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Create Acl Override Link With User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/acl_overrides/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def acl_overrides_users_delete(self, uuid: str, name: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Acl Override Link With User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/acl_overrides/{uuid}/users/{name}', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_override","title":"<code>acl_override(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Acl Override By Uuid</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_override(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Acl Override By Uuid\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/acl_overrides/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides","title":"<code>acl_overrides(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Acl Overrides</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>json_schema</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Acl Overrides\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        json_schema (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code',\n        'json_schema', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('json_schema'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.acl_overrides.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/acl_overrides/', single_page\n        =single_page, page_size=page_size, warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides_create","title":"<code>acl_overrides_create(kwargs=None, **payload)</code>","text":"<p>Create Acl Override</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>acl_override</code> <code>array object required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Acl Override\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        acl_override (array object required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'acl_override']\n    payload.get('code'), payload.get('acl_override')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.acl_overrides_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/acl_overrides/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides_delete","title":"<code>acl_overrides_delete(uuid, kwargs=None)</code>","text":"<p>Delete Acl Override</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Acl Override\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/acl_overrides/{uuid}', **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides_put","title":"<code>acl_overrides_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Acl Override</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>acl_override</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Acl Override\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        acl_override (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'acl_override']\n    payload.get('code'), payload.get('acl_override')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.acl_overrides_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/acl_overrides/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides_users","title":"<code>acl_overrides_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Acl Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Acl Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.acl_overrides_users.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/acl_overrides/{uuid}/users',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides_users_create","title":"<code>acl_overrides_users_create(uuid, name, kwargs=None)</code>","text":"<p>Create Acl Override Link With User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides_users_create(self, uuid: str, name: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Create Acl Override Link With User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/acl_overrides/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.acl_overrides/#hive.cookbook.acl_overrides.AclOverrides.acl_overrides_users_delete","title":"<code>acl_overrides_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Delete Acl Override Link With User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/acl_overrides.py</code> <pre><code>def acl_overrides_users_delete(self, uuid: str, name: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Acl Override Link With User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/acl_overrides/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.analytics/","title":"Hive.cookbook.analytics","text":""},{"location":"hive.cookbook.analytics/#hive.cookbook.analytics.Analytics","title":"<code>Analytics</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata analytics APIs</p> Source code in <code>hive/cookbook/analytics.py</code> <pre><code>class Analytics(ApiManager):\n    \"\"\"Class that handles all the XAutomata analytics APIs\"\"\"\n\n    def analytic(self, uuid_customer: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Analytics By Customer\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'date_start',\n            'date_end', 'metric_profile', 'metric_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'date_start'), params.get('date_end'), params.get('metric_profile'\n            ), params.get('metric_name'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.analytic.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/analytics/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.analytics/#hive.cookbook.analytics.Analytics.analytic","title":"<code>analytic(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Analytics By Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/analytics.py</code> <pre><code>def analytic(self, uuid_customer: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Analytics By Customer\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'date_start',\n        'date_end', 'metric_profile', 'metric_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'date_start'), params.get('date_end'), params.get('metric_profile'\n        ), params.get('metric_name'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.analytic.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/analytics/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/","title":"Hive.cookbook.anomalies","text":""},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies","title":"<code>Anomalies</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata anomalies APIs</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>class Anomalies(ApiManager):\n    \"\"\"Class that handles all the XAutomata anomalies APIs\"\"\"\n\n    def anomalies(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Anomalies\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            value (string optional): additional filter - parameter\n            sampling (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'date_start',\n            'date_end', 'uuid_customer', 'type', 'value', 'sampling',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'date_start'), params.get('date_end'), params.get('uuid_customer'\n            ), params.get('type'), params.get('value'), params.get('sampling'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.anomalies.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/anomalies/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def anomalies_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Anomalies Multi\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            date_anomaly_start (string required): additional filter - payload\n            date_anomaly (string required): additional filter - payload\n            uuid_customer (string required): additional filter - payload\n            type (string required): additional filter - payload\n            value (string required): additional filter - payload\n            sampling (string required): additional filter - payload\n            parameters (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['date_anomaly_start', 'date_anomaly',\n            'uuid_customer', 'type', 'value', 'sampling', 'parameters']\n        payload.get('date_anomaly_start'), payload.get('date_anomaly'\n            ), payload.get('uuid_customer'), payload.get('type'), payload.get(\n            'value'), payload.get('sampling'), payload.get('parameters')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.anomalies_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/anomalies/', payload=\n            payload, **kwargs)\n        return response\n\n    def anomalie(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Anomaly\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.anomalie.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/anomalies/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def anomalies_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Anomaly\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/anomalies/{uuid}', **kwargs)\n        return response\n\n    def anomalies_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Anomalies\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.anomalies_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/anomalies/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def anomalies_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Anomalies\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"date_anomaly_start\": \"string\", required\n            \"date_anomaly\": \"string\", required\n            \"uuid_customer\": \"string\", required\n            \"type\": \"string\", required\n            \"value\": \"string\", required\n            \"sampling\": \"string\", required\n            \"parameters\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.anomalies_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/anomalies/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def anomalies_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Anomalies\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/anomalies/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalie","title":"<code>anomalie(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Anomaly</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalie(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Anomaly\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.anomalie.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/anomalies/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalies","title":"<code>anomalies(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Anomalies</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>value</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sampling</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalies(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Anomalies\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        value (string optional): additional filter - parameter\n        sampling (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'date_start',\n        'date_end', 'uuid_customer', 'type', 'value', 'sampling',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'date_start'), params.get('date_end'), params.get('uuid_customer'\n        ), params.get('type'), params.get('value'), params.get('sampling'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.anomalies.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/anomalies/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalies_bulk","title":"<code>anomalies_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Anomalies</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalies_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Anomalies\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.anomalies_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/anomalies/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalies_create","title":"<code>anomalies_create(kwargs=None, **payload)</code>","text":"<p>Create Anomalies Multi</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_anomaly_start</code> <code>string required</code> <p>additional filter - payload</p> <code>date_anomaly</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>type</code> <code>string required</code> <p>additional filter - payload</p> <code>value</code> <code>string required</code> <p>additional filter - payload</p> <code>sampling</code> <code>string required</code> <p>additional filter - payload</p> <code>parameters</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalies_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Anomalies Multi\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        date_anomaly_start (string required): additional filter - payload\n        date_anomaly (string required): additional filter - payload\n        uuid_customer (string required): additional filter - payload\n        type (string required): additional filter - payload\n        value (string required): additional filter - payload\n        sampling (string required): additional filter - payload\n        parameters (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['date_anomaly_start', 'date_anomaly',\n        'uuid_customer', 'type', 'value', 'sampling', 'parameters']\n    payload.get('date_anomaly_start'), payload.get('date_anomaly'\n        ), payload.get('uuid_customer'), payload.get('type'), payload.get(\n        'value'), payload.get('sampling'), payload.get('parameters')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.anomalies_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/anomalies/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalies_create_bulk","title":"<code>anomalies_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Anomalies</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"date_anomaly_start\": \"string\", required     \"date_anomaly\": \"string\", required     \"uuid_customer\": \"string\", required     \"type\": \"string\", required     \"value\": \"string\", required     \"sampling\": \"string\", required     \"parameters\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalies_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Anomalies\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"date_anomaly_start\": \"string\", required\n        \"date_anomaly\": \"string\", required\n        \"uuid_customer\": \"string\", required\n        \"type\": \"string\", required\n        \"value\": \"string\", required\n        \"sampling\": \"string\", required\n        \"parameters\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.anomalies_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/anomalies/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalies_delete","title":"<code>anomalies_delete(uuid, kwargs=None)</code>","text":"<p>Delete Anomaly</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalies_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Anomaly\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/anomalies/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.anomalies/#hive.cookbook.anomalies.Anomalies.anomalies_delete_bulk","title":"<code>anomalies_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Anomalies</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/anomalies.py</code> <pre><code>def anomalies_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Anomalies\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/anomalies/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.apple/","title":"Hive.cookbook.apple","text":""},{"location":"hive.cookbook.apple/#hive.cookbook.apple.Apple","title":"<code>Apple</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata apple APIs</p> Source code in <code>hive/cookbook/apple.py</code> <pre><code>class Apple(ApiManager):\n    \"\"\"Class that handles all the XAutomata apple APIs\"\"\"\n\n    def apple_login(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Apple Login\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/apple/login', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def apple_callback_create(self, kwargs: dict = None) -&gt; list:\n        \"\"\"Apple Callback\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/apple/callback', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.apple/#hive.cookbook.apple.Apple.apple_callback_create","title":"<code>apple_callback_create(kwargs=None)</code>","text":"<p>Apple Callback</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/apple.py</code> <pre><code>def apple_callback_create(self, kwargs: dict = None) -&gt; list:\n    \"\"\"Apple Callback\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/apple/callback', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.apple/#hive.cookbook.apple.Apple.apple_login","title":"<code>apple_login(warm_start=False, kwargs=None)</code>","text":"<p>Apple Login</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/apple.py</code> <pre><code>def apple_login(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Apple Login\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/apple/login', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.automata_ingest/","title":"Hive.cookbook.automata ingest","text":""},{"location":"hive.cookbook.automata_ingest/#hive.cookbook.automata_ingest.AutomataIngest","title":"<code>AutomataIngest</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata automata_ingest APIs</p> Source code in <code>hive/cookbook/automata_ingest.py</code> <pre><code>class AutomataIngest(ApiManager):\n    \"\"\"Class that handles all the XAutomata automata_ingest APIs\"\"\"\n\n    def automata_ingest_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Insert Automata\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            extended_attributes (string optional): additional filter - payload\n            uuid_automata_instance (string required): additional filter - payload\n            timestamp (integer required): additional filter - payload\n            group_label (string optional): additional filter - payload\n            xal_name (string optional): additional filter - payload\n            automata_name (string optional): additional filter - payload\n            automata_version (string optional): additional filter - payload\n            current_state (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['extended_attributes',\n            'uuid_automata_instance', 'timestamp', 'group_label',\n            'xal_name', 'automata_name', 'automata_version', 'current_state']\n        payload.get('extended_attributes'), payload.get(\n            'uuid_automata_instance'), payload.get('timestamp'), payload.get(\n            'group_label'), payload.get('xal_name'), payload.get(\n            'automata_name'), payload.get('automata_version'), payload.get(\n            'current_state')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.automata_ingest_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/automata_ingest/', payload=\n            payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.automata_ingest/#hive.cookbook.automata_ingest.AutomataIngest.automata_ingest_create","title":"<code>automata_ingest_create(kwargs=None, **payload)</code>","text":"<p>Insert Automata</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extended_attributes</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_automata_instance</code> <code>string required</code> <p>additional filter - payload</p> <code>timestamp</code> <code>integer required</code> <p>additional filter - payload</p> <code>group_label</code> <code>string optional</code> <p>additional filter - payload</p> <code>xal_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>automata_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>automata_version</code> <code>string optional</code> <p>additional filter - payload</p> <code>current_state</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/automata_ingest.py</code> <pre><code>def automata_ingest_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Insert Automata\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        extended_attributes (string optional): additional filter - payload\n        uuid_automata_instance (string required): additional filter - payload\n        timestamp (integer required): additional filter - payload\n        group_label (string optional): additional filter - payload\n        xal_name (string optional): additional filter - payload\n        automata_name (string optional): additional filter - payload\n        automata_version (string optional): additional filter - payload\n        current_state (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['extended_attributes',\n        'uuid_automata_instance', 'timestamp', 'group_label',\n        'xal_name', 'automata_name', 'automata_version', 'current_state']\n    payload.get('extended_attributes'), payload.get(\n        'uuid_automata_instance'), payload.get('timestamp'), payload.get(\n        'group_label'), payload.get('xal_name'), payload.get(\n        'automata_name'), payload.get('automata_version'), payload.get(\n        'current_state')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.automata_ingest_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/automata_ingest/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/","title":"Hive.cookbook.calendars","text":""},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars","title":"<code>Calendars</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata calendars APIs</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>class Calendars(ApiManager):\n    \"\"\"Class that handles all the XAutomata calendars APIs\"\"\"\n\n    def calendars(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Calendars\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            local_public_holidays (boolean optional): additional filter - parameter\n            timezone (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            mon_int1_start (string optional): additional filter - parameter\n            mon_int1_end (string optional): additional filter - parameter\n            mon_int2_start (string optional): additional filter - parameter\n            mon_int2_end (string optional): additional filter - parameter\n            tue_int1_start (string optional): additional filter - parameter\n            tue_int1_end (string optional): additional filter - parameter\n            tue_int2_start (string optional): additional filter - parameter\n            tue_int2_end (string optional): additional filter - parameter\n            wed_int1_start (string optional): additional filter - parameter\n            wed_int1_end (string optional): additional filter - parameter\n            wed_int2_start (string optional): additional filter - parameter\n            wed_int2_end (string optional): additional filter - parameter\n            thu_int1_start (string optional): additional filter - parameter\n            thu_int1_end (string optional): additional filter - parameter\n            thu_int2_start (string optional): additional filter - parameter\n            thu_int2_end (string optional): additional filter - parameter\n            fri_int1_start (string optional): additional filter - parameter\n            fri_int1_end (string optional): additional filter - parameter\n            fri_int2_start (string optional): additional filter - parameter\n            fri_int2_end (string optional): additional filter - parameter\n            sat_int1_start (string optional): additional filter - parameter\n            sat_int1_end (string optional): additional filter - parameter\n            sat_int2_start (string optional): additional filter - parameter\n            sat_int2_end (string optional): additional filter - parameter\n            sun_int1_start (string optional): additional filter - parameter\n            sun_int1_end (string optional): additional filter - parameter\n            sun_int2_start (string optional): additional filter - parameter\n            sun_int2_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'name',\n            'local_public_holidays', 'timezone', 'type', 'mon_int1_start',\n            'mon_int1_end', 'mon_int2_start', 'mon_int2_end',\n            'tue_int1_start', 'tue_int1_end', 'tue_int2_start',\n            'tue_int2_end', 'wed_int1_start', 'wed_int1_end',\n            'wed_int2_start', 'wed_int2_end', 'thu_int1_start',\n            'thu_int1_end', 'thu_int2_start', 'thu_int2_end',\n            'fri_int1_start', 'fri_int1_end', 'fri_int2_start',\n            'fri_int2_end', 'sat_int1_start', 'sat_int1_end',\n            'sat_int2_start', 'sat_int2_end', 'sun_int1_start',\n            'sun_int1_end', 'sun_int2_start', 'sun_int2_end', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('name'\n            ), params.get('local_public_holidays'), params.get('timezone'\n            ), params.get('type'), params.get('mon_int1_start'), params.get(\n            'mon_int1_end'), params.get('mon_int2_start'), params.get(\n            'mon_int2_end'), params.get('tue_int1_start'), params.get(\n            'tue_int1_end'), params.get('tue_int2_start'), params.get(\n            'tue_int2_end'), params.get('wed_int1_start'), params.get(\n            'wed_int1_end'), params.get('wed_int2_start'), params.get(\n            'wed_int2_end'), params.get('thu_int1_start'), params.get(\n            'thu_int1_end'), params.get('thu_int2_start'), params.get(\n            'thu_int2_end'), params.get('fri_int1_start'), params.get(\n            'fri_int1_end'), params.get('fri_int2_start'), params.get(\n            'fri_int2_end'), params.get('sat_int1_start'), params.get(\n            'sat_int1_end'), params.get('sat_int2_start'), params.get(\n            'sat_int2_end'), params.get('sun_int1_start'), params.get(\n            'sun_int1_end'), params.get('sun_int2_start'), params.get(\n            'sun_int2_end'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/calendars/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def calendars_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Calendar\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string required): additional filter - payload\n            timezone (string required): additional filter - payload\n            local_public_holidays (boolean required): additional filter - payload\n            mon_int1_start (string optional): additional filter - payload\n            mon_int1_end (string optional): additional filter - payload\n            mon_int2_start (string optional): additional filter - payload\n            mon_int2_end (string optional): additional filter - payload\n            tue_int1_start (string optional): additional filter - payload\n            tue_int1_end (string optional): additional filter - payload\n            tue_int2_start (string optional): additional filter - payload\n            tue_int2_end (string optional): additional filter - payload\n            wed_int1_start (string optional): additional filter - payload\n            wed_int1_end (string optional): additional filter - payload\n            wed_int2_start (string optional): additional filter - payload\n            wed_int2_end (string optional): additional filter - payload\n            thu_int1_start (string optional): additional filter - payload\n            thu_int1_end (string optional): additional filter - payload\n            thu_int2_start (string optional): additional filter - payload\n            thu_int2_end (string optional): additional filter - payload\n            fri_int1_start (string optional): additional filter - payload\n            fri_int1_end (string optional): additional filter - payload\n            fri_int2_start (string optional): additional filter - payload\n            fri_int2_end (string optional): additional filter - payload\n            sat_int1_start (string optional): additional filter - payload\n            sat_int1_end (string optional): additional filter - payload\n            sat_int2_start (string optional): additional filter - payload\n            sat_int2_end (string optional): additional filter - payload\n            sun_int1_start (string optional): additional filter - payload\n            sun_int1_end (string optional): additional filter - payload\n            sun_int2_start (string optional): additional filter - payload\n            sun_int2_end (string optional): additional filter - payload\n            ical (string optional): additional filter - payload\n            type ( optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'timezone',\n            'local_public_holidays', 'mon_int1_start', 'mon_int1_end',\n            'mon_int2_start', 'mon_int2_end', 'tue_int1_start',\n            'tue_int1_end', 'tue_int2_start', 'tue_int2_end',\n            'wed_int1_start', 'wed_int1_end', 'wed_int2_start',\n            'wed_int2_end', 'thu_int1_start', 'thu_int1_end',\n            'thu_int2_start', 'thu_int2_end', 'fri_int1_start',\n            'fri_int1_end', 'fri_int2_start', 'fri_int2_end',\n            'sat_int1_start', 'sat_int1_end', 'sat_int2_start',\n            'sat_int2_end', 'sun_int1_start', 'sun_int1_end',\n            'sun_int2_start', 'sun_int2_end', 'ical', 'type']\n        payload.get('name'), payload.get('timezone'), payload.get(\n            'local_public_holidays'), payload.get('mon_int1_start'\n            ), payload.get('mon_int1_end'), payload.get('mon_int2_start'\n            ), payload.get('mon_int2_end'), payload.get('tue_int1_start'\n            ), payload.get('tue_int1_end'), payload.get('tue_int2_start'\n            ), payload.get('tue_int2_end'), payload.get('wed_int1_start'\n            ), payload.get('wed_int1_end'), payload.get('wed_int2_start'\n            ), payload.get('wed_int2_end'), payload.get('thu_int1_start'\n            ), payload.get('thu_int1_end'), payload.get('thu_int2_start'\n            ), payload.get('thu_int2_end'), payload.get('fri_int1_start'\n            ), payload.get('fri_int1_end'), payload.get('fri_int2_start'\n            ), payload.get('fri_int2_end'), payload.get('sat_int1_start'\n            ), payload.get('sat_int1_end'), payload.get('sat_int2_start'\n            ), payload.get('sat_int2_end'), payload.get('sun_int1_start'\n            ), payload.get('sun_int1_end'), payload.get('sun_int2_start'\n            ), payload.get('sun_int2_end'), payload.get('ical'), payload.get(\n            'type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/calendars/', payload=\n            payload, **kwargs)\n        return response\n\n    def calendar(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Calendar\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/calendars/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def calendars_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Calendar\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string optional): additional filter - payload\n            timezone (string optional): additional filter - payload\n            local_public_holidays (boolean optional): additional filter - payload\n            mon_int1_start (string optional): additional filter - payload\n            mon_int1_end (string optional): additional filter - payload\n            mon_int2_start (string optional): additional filter - payload\n            mon_int2_end (string optional): additional filter - payload\n            tue_int1_start (string optional): additional filter - payload\n            tue_int1_end (string optional): additional filter - payload\n            tue_int2_start (string optional): additional filter - payload\n            tue_int2_end (string optional): additional filter - payload\n            wed_int1_start (string optional): additional filter - payload\n            wed_int1_end (string optional): additional filter - payload\n            wed_int2_start (string optional): additional filter - payload\n            wed_int2_end (string optional): additional filter - payload\n            thu_int1_start (string optional): additional filter - payload\n            thu_int1_end (string optional): additional filter - payload\n            thu_int2_start (string optional): additional filter - payload\n            thu_int2_end (string optional): additional filter - payload\n            fri_int1_start (string optional): additional filter - payload\n            fri_int1_end (string optional): additional filter - payload\n            fri_int2_start (string optional): additional filter - payload\n            fri_int2_end (string optional): additional filter - payload\n            sat_int1_start (string optional): additional filter - payload\n            sat_int1_end (string optional): additional filter - payload\n            sat_int2_start (string optional): additional filter - payload\n            sat_int2_end (string optional): additional filter - payload\n            sun_int1_start (string optional): additional filter - payload\n            sun_int1_end (string optional): additional filter - payload\n            sun_int2_start (string optional): additional filter - payload\n            sun_int2_end (string optional): additional filter - payload\n            ical (string optional): additional filter - payload\n            type ( optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'timezone',\n            'local_public_holidays', 'mon_int1_start', 'mon_int1_end',\n            'mon_int2_start', 'mon_int2_end', 'tue_int1_start',\n            'tue_int1_end', 'tue_int2_start', 'tue_int2_end',\n            'wed_int1_start', 'wed_int1_end', 'wed_int2_start',\n            'wed_int2_end', 'thu_int1_start', 'thu_int1_end',\n            'thu_int2_start', 'thu_int2_end', 'fri_int1_start',\n            'fri_int1_end', 'fri_int2_start', 'fri_int2_end',\n            'sat_int1_start', 'sat_int1_end', 'sat_int2_start',\n            'sat_int2_end', 'sun_int1_start', 'sun_int1_end',\n            'sun_int2_start', 'sun_int2_end', 'ical', 'type']\n        payload.get('name'), payload.get('timezone'), payload.get(\n            'local_public_holidays'), payload.get('mon_int1_start'\n            ), payload.get('mon_int1_end'), payload.get('mon_int2_start'\n            ), payload.get('mon_int2_end'), payload.get('tue_int1_start'\n            ), payload.get('tue_int1_end'), payload.get('tue_int2_start'\n            ), payload.get('tue_int2_end'), payload.get('wed_int1_start'\n            ), payload.get('wed_int1_end'), payload.get('wed_int2_start'\n            ), payload.get('wed_int2_end'), payload.get('thu_int1_start'\n            ), payload.get('thu_int1_end'), payload.get('thu_int2_start'\n            ), payload.get('thu_int2_end'), payload.get('fri_int1_start'\n            ), payload.get('fri_int1_end'), payload.get('fri_int2_start'\n            ), payload.get('fri_int2_end'), payload.get('sat_int1_start'\n            ), payload.get('sat_int1_end'), payload.get('sat_int2_start'\n            ), payload.get('sat_int2_end'), payload.get('sun_int1_start'\n            ), payload.get('sun_int1_end'), payload.get('sun_int2_start'\n            ), payload.get('sun_int2_end'), payload.get('ical'), payload.get(\n            'type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/calendars/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def calendars_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Calendar\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/calendars/{uuid}', **kwargs)\n        return response\n\n    def calendars_downtimes(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/calendars/{uuid}/downtimes',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def calendars_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['tag', 'skip', 'limit', 'like', 'join', 'count'\n            ]\n        params.get('tag'), params.get('skip'), params.get('limit'), params.get(\n            'like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/calendars/{uuid}/dispatchers', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def calendars_is_local_holiday_create(self, kwargs: dict = None, **params\n        ) -&gt; list:\n        \"\"\"Is Local Holiday\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            country (string required): additional filter - parameter\n            ts (string required): additional filter - parameter\n            timezone (string required): additional filter - parameter\n            state_province (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['country', 'ts', 'timezone', 'state_province']\n        params.get('country'), params.get('ts'), params.get('timezone'\n            ), params.get('state_province')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars_is_local_holiday_create\n                .__name__, params, official_params_list)\n        response = self.execute('POST', path=f'/calendars/is_local_holiday',\n            params=params, **kwargs)\n        return response\n\n    def calendars_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Calendars\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/calendars/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def calendars_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Calendars\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"name\": \"string\", required\n            \"timezone\": \"string\", required\n            \"local_public_holidays\": \"boolean\", required\n            \"mon_int1_start\": \"string\", optional\n            \"mon_int1_end\": \"string\", optional\n            \"mon_int2_start\": \"string\", optional\n            \"mon_int2_end\": \"string\", optional\n            \"tue_int1_start\": \"string\", optional\n            \"tue_int1_end\": \"string\", optional\n            \"tue_int2_start\": \"string\", optional\n            \"tue_int2_end\": \"string\", optional\n            \"wed_int1_start\": \"string\", optional\n            \"wed_int1_end\": \"string\", optional\n            \"wed_int2_start\": \"string\", optional\n            \"wed_int2_end\": \"string\", optional\n            \"thu_int1_start\": \"string\", optional\n            \"thu_int1_end\": \"string\", optional\n            \"thu_int2_start\": \"string\", optional\n            \"thu_int2_end\": \"string\", optional\n            \"fri_int1_start\": \"string\", optional\n            \"fri_int1_end\": \"string\", optional\n            \"fri_int2_start\": \"string\", optional\n            \"fri_int2_end\": \"string\", optional\n            \"sat_int1_start\": \"string\", optional\n            \"sat_int1_end\": \"string\", optional\n            \"sat_int2_start\": \"string\", optional\n            \"sat_int2_end\": \"string\", optional\n            \"sun_int1_start\": \"string\", optional\n            \"sun_int1_end\": \"string\", optional\n            \"sun_int2_start\": \"string\", optional\n            \"sun_int2_end\": \"string\", optional\n            \"ical\": \"string\", optional\n            \"type\": \"\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.calendars_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/calendars/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def calendars_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Calendars\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/calendars/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendar","title":"<code>calendar(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Calendar</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendar(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Calendar\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/calendars/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars","title":"<code>calendars(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Calendars</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>local_public_holidays</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>timezone</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mon_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mon_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mon_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mon_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tue_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tue_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tue_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tue_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>wed_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>wed_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>wed_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>wed_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>thu_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>thu_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>thu_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>thu_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fri_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fri_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fri_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fri_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sat_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sat_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sat_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sat_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sun_int1_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sun_int1_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sun_int2_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sun_int2_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Calendars\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        local_public_holidays (boolean optional): additional filter - parameter\n        timezone (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        mon_int1_start (string optional): additional filter - parameter\n        mon_int1_end (string optional): additional filter - parameter\n        mon_int2_start (string optional): additional filter - parameter\n        mon_int2_end (string optional): additional filter - parameter\n        tue_int1_start (string optional): additional filter - parameter\n        tue_int1_end (string optional): additional filter - parameter\n        tue_int2_start (string optional): additional filter - parameter\n        tue_int2_end (string optional): additional filter - parameter\n        wed_int1_start (string optional): additional filter - parameter\n        wed_int1_end (string optional): additional filter - parameter\n        wed_int2_start (string optional): additional filter - parameter\n        wed_int2_end (string optional): additional filter - parameter\n        thu_int1_start (string optional): additional filter - parameter\n        thu_int1_end (string optional): additional filter - parameter\n        thu_int2_start (string optional): additional filter - parameter\n        thu_int2_end (string optional): additional filter - parameter\n        fri_int1_start (string optional): additional filter - parameter\n        fri_int1_end (string optional): additional filter - parameter\n        fri_int2_start (string optional): additional filter - parameter\n        fri_int2_end (string optional): additional filter - parameter\n        sat_int1_start (string optional): additional filter - parameter\n        sat_int1_end (string optional): additional filter - parameter\n        sat_int2_start (string optional): additional filter - parameter\n        sat_int2_end (string optional): additional filter - parameter\n        sun_int1_start (string optional): additional filter - parameter\n        sun_int1_end (string optional): additional filter - parameter\n        sun_int2_start (string optional): additional filter - parameter\n        sun_int2_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'name',\n        'local_public_holidays', 'timezone', 'type', 'mon_int1_start',\n        'mon_int1_end', 'mon_int2_start', 'mon_int2_end',\n        'tue_int1_start', 'tue_int1_end', 'tue_int2_start',\n        'tue_int2_end', 'wed_int1_start', 'wed_int1_end',\n        'wed_int2_start', 'wed_int2_end', 'thu_int1_start',\n        'thu_int1_end', 'thu_int2_start', 'thu_int2_end',\n        'fri_int1_start', 'fri_int1_end', 'fri_int2_start',\n        'fri_int2_end', 'sat_int1_start', 'sat_int1_end',\n        'sat_int2_start', 'sat_int2_end', 'sun_int1_start',\n        'sun_int1_end', 'sun_int2_start', 'sun_int2_end', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('name'\n        ), params.get('local_public_holidays'), params.get('timezone'\n        ), params.get('type'), params.get('mon_int1_start'), params.get(\n        'mon_int1_end'), params.get('mon_int2_start'), params.get(\n        'mon_int2_end'), params.get('tue_int1_start'), params.get(\n        'tue_int1_end'), params.get('tue_int2_start'), params.get(\n        'tue_int2_end'), params.get('wed_int1_start'), params.get(\n        'wed_int1_end'), params.get('wed_int2_start'), params.get(\n        'wed_int2_end'), params.get('thu_int1_start'), params.get(\n        'thu_int1_end'), params.get('thu_int2_start'), params.get(\n        'thu_int2_end'), params.get('fri_int1_start'), params.get(\n        'fri_int1_end'), params.get('fri_int2_start'), params.get(\n        'fri_int2_end'), params.get('sat_int1_start'), params.get(\n        'sat_int1_end'), params.get('sat_int2_start'), params.get(\n        'sat_int2_end'), params.get('sun_int1_start'), params.get(\n        'sun_int1_end'), params.get('sun_int2_start'), params.get(\n        'sun_int2_end'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/calendars/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_bulk","title":"<code>calendars_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Calendars</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Calendars\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/calendars/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_create","title":"<code>calendars_create(kwargs=None, **payload)</code>","text":"<p>Create Calendar</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>timezone</code> <code>string required</code> <p>additional filter - payload</p> <code>local_public_holidays</code> <code>boolean required</code> <p>additional filter - payload</p> <code>mon_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>mon_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>mon_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>mon_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>ical</code> <code>string optional</code> <p>additional filter - payload</p> <code>type</code> <code>optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Calendar\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string required): additional filter - payload\n        timezone (string required): additional filter - payload\n        local_public_holidays (boolean required): additional filter - payload\n        mon_int1_start (string optional): additional filter - payload\n        mon_int1_end (string optional): additional filter - payload\n        mon_int2_start (string optional): additional filter - payload\n        mon_int2_end (string optional): additional filter - payload\n        tue_int1_start (string optional): additional filter - payload\n        tue_int1_end (string optional): additional filter - payload\n        tue_int2_start (string optional): additional filter - payload\n        tue_int2_end (string optional): additional filter - payload\n        wed_int1_start (string optional): additional filter - payload\n        wed_int1_end (string optional): additional filter - payload\n        wed_int2_start (string optional): additional filter - payload\n        wed_int2_end (string optional): additional filter - payload\n        thu_int1_start (string optional): additional filter - payload\n        thu_int1_end (string optional): additional filter - payload\n        thu_int2_start (string optional): additional filter - payload\n        thu_int2_end (string optional): additional filter - payload\n        fri_int1_start (string optional): additional filter - payload\n        fri_int1_end (string optional): additional filter - payload\n        fri_int2_start (string optional): additional filter - payload\n        fri_int2_end (string optional): additional filter - payload\n        sat_int1_start (string optional): additional filter - payload\n        sat_int1_end (string optional): additional filter - payload\n        sat_int2_start (string optional): additional filter - payload\n        sat_int2_end (string optional): additional filter - payload\n        sun_int1_start (string optional): additional filter - payload\n        sun_int1_end (string optional): additional filter - payload\n        sun_int2_start (string optional): additional filter - payload\n        sun_int2_end (string optional): additional filter - payload\n        ical (string optional): additional filter - payload\n        type ( optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'timezone',\n        'local_public_holidays', 'mon_int1_start', 'mon_int1_end',\n        'mon_int2_start', 'mon_int2_end', 'tue_int1_start',\n        'tue_int1_end', 'tue_int2_start', 'tue_int2_end',\n        'wed_int1_start', 'wed_int1_end', 'wed_int2_start',\n        'wed_int2_end', 'thu_int1_start', 'thu_int1_end',\n        'thu_int2_start', 'thu_int2_end', 'fri_int1_start',\n        'fri_int1_end', 'fri_int2_start', 'fri_int2_end',\n        'sat_int1_start', 'sat_int1_end', 'sat_int2_start',\n        'sat_int2_end', 'sun_int1_start', 'sun_int1_end',\n        'sun_int2_start', 'sun_int2_end', 'ical', 'type']\n    payload.get('name'), payload.get('timezone'), payload.get(\n        'local_public_holidays'), payload.get('mon_int1_start'\n        ), payload.get('mon_int1_end'), payload.get('mon_int2_start'\n        ), payload.get('mon_int2_end'), payload.get('tue_int1_start'\n        ), payload.get('tue_int1_end'), payload.get('tue_int2_start'\n        ), payload.get('tue_int2_end'), payload.get('wed_int1_start'\n        ), payload.get('wed_int1_end'), payload.get('wed_int2_start'\n        ), payload.get('wed_int2_end'), payload.get('thu_int1_start'\n        ), payload.get('thu_int1_end'), payload.get('thu_int2_start'\n        ), payload.get('thu_int2_end'), payload.get('fri_int1_start'\n        ), payload.get('fri_int1_end'), payload.get('fri_int2_start'\n        ), payload.get('fri_int2_end'), payload.get('sat_int1_start'\n        ), payload.get('sat_int1_end'), payload.get('sat_int2_start'\n        ), payload.get('sat_int2_end'), payload.get('sun_int1_start'\n        ), payload.get('sun_int1_end'), payload.get('sun_int2_start'\n        ), payload.get('sun_int2_end'), payload.get('ical'), payload.get(\n        'type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/calendars/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_create_bulk","title":"<code>calendars_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Calendars</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"name\": \"string\", required     \"timezone\": \"string\", required     \"local_public_holidays\": \"boolean\", required     \"mon_int1_start\": \"string\", optional     \"mon_int1_end\": \"string\", optional     \"mon_int2_start\": \"string\", optional     \"mon_int2_end\": \"string\", optional     \"tue_int1_start\": \"string\", optional     \"tue_int1_end\": \"string\", optional     \"tue_int2_start\": \"string\", optional     \"tue_int2_end\": \"string\", optional     \"wed_int1_start\": \"string\", optional     \"wed_int1_end\": \"string\", optional     \"wed_int2_start\": \"string\", optional     \"wed_int2_end\": \"string\", optional     \"thu_int1_start\": \"string\", optional     \"thu_int1_end\": \"string\", optional     \"thu_int2_start\": \"string\", optional     \"thu_int2_end\": \"string\", optional     \"fri_int1_start\": \"string\", optional     \"fri_int1_end\": \"string\", optional     \"fri_int2_start\": \"string\", optional     \"fri_int2_end\": \"string\", optional     \"sat_int1_start\": \"string\", optional     \"sat_int1_end\": \"string\", optional     \"sat_int2_start\": \"string\", optional     \"sat_int2_end\": \"string\", optional     \"sun_int1_start\": \"string\", optional     \"sun_int1_end\": \"string\", optional     \"sun_int2_start\": \"string\", optional     \"sun_int2_end\": \"string\", optional     \"ical\": \"string\", optional     \"type\": \"\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Calendars\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"name\": \"string\", required\n        \"timezone\": \"string\", required\n        \"local_public_holidays\": \"boolean\", required\n        \"mon_int1_start\": \"string\", optional\n        \"mon_int1_end\": \"string\", optional\n        \"mon_int2_start\": \"string\", optional\n        \"mon_int2_end\": \"string\", optional\n        \"tue_int1_start\": \"string\", optional\n        \"tue_int1_end\": \"string\", optional\n        \"tue_int2_start\": \"string\", optional\n        \"tue_int2_end\": \"string\", optional\n        \"wed_int1_start\": \"string\", optional\n        \"wed_int1_end\": \"string\", optional\n        \"wed_int2_start\": \"string\", optional\n        \"wed_int2_end\": \"string\", optional\n        \"thu_int1_start\": \"string\", optional\n        \"thu_int1_end\": \"string\", optional\n        \"thu_int2_start\": \"string\", optional\n        \"thu_int2_end\": \"string\", optional\n        \"fri_int1_start\": \"string\", optional\n        \"fri_int1_end\": \"string\", optional\n        \"fri_int2_start\": \"string\", optional\n        \"fri_int2_end\": \"string\", optional\n        \"sat_int1_start\": \"string\", optional\n        \"sat_int1_end\": \"string\", optional\n        \"sat_int2_start\": \"string\", optional\n        \"sat_int2_end\": \"string\", optional\n        \"sun_int1_start\": \"string\", optional\n        \"sun_int1_end\": \"string\", optional\n        \"sun_int2_start\": \"string\", optional\n        \"sun_int2_end\": \"string\", optional\n        \"ical\": \"string\", optional\n        \"type\": \"\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/calendars/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_delete","title":"<code>calendars_delete(uuid, kwargs=None)</code>","text":"<p>Delete Calendar</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Calendar\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/calendars/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_delete_bulk","title":"<code>calendars_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Calendars</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Calendars\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/calendars/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_dispatchers","title":"<code>calendars_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['tag', 'skip', 'limit', 'like', 'join', 'count'\n        ]\n    params.get('tag'), params.get('skip'), params.get('limit'), params.get(\n        'like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/calendars/{uuid}/dispatchers', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_downtimes","title":"<code>calendars_downtimes(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_downtimes(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/calendars/{uuid}/downtimes',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_is_local_holiday_create","title":"<code>calendars_is_local_holiday_create(kwargs=None, **params)</code>","text":"<p>Is Local Holiday</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>country</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts</code> <code>string required</code> <p>additional filter - parameter</p> <code>timezone</code> <code>string required</code> <p>additional filter - parameter</p> <code>state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_is_local_holiday_create(self, kwargs: dict = None, **params\n    ) -&gt; list:\n    \"\"\"Is Local Holiday\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        country (string required): additional filter - parameter\n        ts (string required): additional filter - parameter\n        timezone (string required): additional filter - parameter\n        state_province (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['country', 'ts', 'timezone', 'state_province']\n    params.get('country'), params.get('ts'), params.get('timezone'\n        ), params.get('state_province')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars_is_local_holiday_create\n            .__name__, params, official_params_list)\n    response = self.execute('POST', path=f'/calendars/is_local_holiday',\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.calendars/#hive.cookbook.calendars.Calendars.calendars_put","title":"<code>calendars_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Calendar</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>timezone</code> <code>string optional</code> <p>additional filter - payload</p> <code>local_public_holidays</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>mon_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>mon_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>mon_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>mon_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>tue_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>wed_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>thu_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>fri_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sat_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int1_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int1_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int2_start</code> <code>string optional</code> <p>additional filter - payload</p> <code>sun_int2_end</code> <code>string optional</code> <p>additional filter - payload</p> <code>ical</code> <code>string optional</code> <p>additional filter - payload</p> <code>type</code> <code>optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/calendars.py</code> <pre><code>def calendars_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Calendar\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string optional): additional filter - payload\n        timezone (string optional): additional filter - payload\n        local_public_holidays (boolean optional): additional filter - payload\n        mon_int1_start (string optional): additional filter - payload\n        mon_int1_end (string optional): additional filter - payload\n        mon_int2_start (string optional): additional filter - payload\n        mon_int2_end (string optional): additional filter - payload\n        tue_int1_start (string optional): additional filter - payload\n        tue_int1_end (string optional): additional filter - payload\n        tue_int2_start (string optional): additional filter - payload\n        tue_int2_end (string optional): additional filter - payload\n        wed_int1_start (string optional): additional filter - payload\n        wed_int1_end (string optional): additional filter - payload\n        wed_int2_start (string optional): additional filter - payload\n        wed_int2_end (string optional): additional filter - payload\n        thu_int1_start (string optional): additional filter - payload\n        thu_int1_end (string optional): additional filter - payload\n        thu_int2_start (string optional): additional filter - payload\n        thu_int2_end (string optional): additional filter - payload\n        fri_int1_start (string optional): additional filter - payload\n        fri_int1_end (string optional): additional filter - payload\n        fri_int2_start (string optional): additional filter - payload\n        fri_int2_end (string optional): additional filter - payload\n        sat_int1_start (string optional): additional filter - payload\n        sat_int1_end (string optional): additional filter - payload\n        sat_int2_start (string optional): additional filter - payload\n        sat_int2_end (string optional): additional filter - payload\n        sun_int1_start (string optional): additional filter - payload\n        sun_int1_end (string optional): additional filter - payload\n        sun_int2_start (string optional): additional filter - payload\n        sun_int2_end (string optional): additional filter - payload\n        ical (string optional): additional filter - payload\n        type ( optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'timezone',\n        'local_public_holidays', 'mon_int1_start', 'mon_int1_end',\n        'mon_int2_start', 'mon_int2_end', 'tue_int1_start',\n        'tue_int1_end', 'tue_int2_start', 'tue_int2_end',\n        'wed_int1_start', 'wed_int1_end', 'wed_int2_start',\n        'wed_int2_end', 'thu_int1_start', 'thu_int1_end',\n        'thu_int2_start', 'thu_int2_end', 'fri_int1_start',\n        'fri_int1_end', 'fri_int2_start', 'fri_int2_end',\n        'sat_int1_start', 'sat_int1_end', 'sat_int2_start',\n        'sat_int2_end', 'sun_int1_start', 'sun_int1_end',\n        'sun_int2_start', 'sun_int2_end', 'ical', 'type']\n    payload.get('name'), payload.get('timezone'), payload.get(\n        'local_public_holidays'), payload.get('mon_int1_start'\n        ), payload.get('mon_int1_end'), payload.get('mon_int2_start'\n        ), payload.get('mon_int2_end'), payload.get('tue_int1_start'\n        ), payload.get('tue_int1_end'), payload.get('tue_int2_start'\n        ), payload.get('tue_int2_end'), payload.get('wed_int1_start'\n        ), payload.get('wed_int1_end'), payload.get('wed_int2_start'\n        ), payload.get('wed_int2_end'), payload.get('thu_int1_start'\n        ), payload.get('thu_int1_end'), payload.get('thu_int2_start'\n        ), payload.get('thu_int2_end'), payload.get('fri_int1_start'\n        ), payload.get('fri_int1_end'), payload.get('fri_int2_start'\n        ), payload.get('fri_int2_end'), payload.get('sat_int1_start'\n        ), payload.get('sat_int1_end'), payload.get('sat_int2_start'\n        ), payload.get('sat_int2_end'), payload.get('sun_int1_start'\n        ), payload.get('sun_int1_end'), payload.get('sun_int2_start'\n        ), payload.get('sun_int2_end'), payload.get('ical'), payload.get(\n        'type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.calendars_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/calendars/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/","title":"Hive.cookbook.contacts","text":""},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts","title":"<code>Contacts</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata contacts APIs</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>class Contacts(ApiManager):\n    \"\"\"Class that handles all the XAutomata contacts APIs\"\"\"\n\n    def contacts(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Contacts\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            surname (string optional): additional filter - parameter\n            qualification (string optional): additional filter - parameter\n            company (string optional): additional filter - parameter\n            department (string optional): additional filter - parameter\n            principal_email (string optional): additional filter - parameter\n            secondary_email (string optional): additional filter - parameter\n            principal_mobile_number (string optional): additional filter - parameter\n            secondary_mobile_number (string optional): additional filter - parameter\n            phone_number (string optional): additional filter - parameter\n            birthday (string optional): additional filter - parameter\n            notes (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'type', 'name',\n            'surname', 'qualification', 'company', 'department',\n            'principal_email', 'secondary_email', 'principal_mobile_number',\n            'secondary_mobile_number', 'phone_number', 'birthday', 'notes',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('type'\n            ), params.get('name'), params.get('surname'), params.get(\n            'qualification'), params.get('company'), params.get('department'\n            ), params.get('principal_email'), params.get('secondary_email'\n            ), params.get('principal_mobile_number'), params.get(\n            'secondary_mobile_number'), params.get('phone_number'), params.get(\n            'birthday'), params.get('notes'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/contacts/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def contacts_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Contact\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string optional): additional filter - payload\n            name (string required): additional filter - payload\n            surname (string required): additional filter - payload\n            qualification (string optional): additional filter - payload\n            company (string optional): additional filter - payload\n            department (string optional): additional filter - payload\n            principal_email (string optional): additional filter - payload\n            secondary_email (string optional): additional filter - payload\n            principal_mobile_number (string optional): additional filter - payload\n            secondary_mobile_number (string optional): additional filter - payload\n            phone_number (string optional): additional filter - payload\n            birthday (string optional): additional filter - payload\n            notes (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type', 'name', 'surname', 'qualification',\n            'company', 'department', 'principal_email', 'secondary_email',\n            'principal_mobile_number', 'secondary_mobile_number',\n            'phone_number', 'birthday', 'notes']\n        payload.get('type'), payload.get('name'), payload.get('surname'\n            ), payload.get('qualification'), payload.get('company'\n            ), payload.get('department'), payload.get('principal_email'\n            ), payload.get('secondary_email'), payload.get(\n            'principal_mobile_number'), payload.get('secondary_mobile_number'\n            ), payload.get('phone_number'), payload.get('birthday'\n            ), payload.get('notes')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/contacts/', payload=payload,\n            **kwargs)\n        return response\n\n    def contact(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Contact\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/contacts/{uuid}', warm_start\n            =warm_start, **kwargs)\n        return response\n\n    def contacts_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Contact\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            surname (string optional): additional filter - payload\n            qualification (string optional): additional filter - payload\n            company (string optional): additional filter - payload\n            department (string optional): additional filter - payload\n            principal_email (string optional): additional filter - payload\n            secondary_email (string optional): additional filter - payload\n            principal_mobile_number (string optional): additional filter - payload\n            secondary_mobile_number (string optional): additional filter - payload\n            phone_number (string optional): additional filter - payload\n            birthday (string optional): additional filter - payload\n            notes (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type', 'name', 'surname', 'qualification',\n            'company', 'department', 'principal_email', 'secondary_email',\n            'principal_mobile_number', 'secondary_mobile_number',\n            'phone_number', 'birthday', 'notes']\n        payload.get('type'), payload.get('name'), payload.get('surname'\n            ), payload.get('qualification'), payload.get('company'\n            ), payload.get('department'), payload.get('principal_email'\n            ), payload.get('secondary_email'), payload.get(\n            'principal_mobile_number'), payload.get('secondary_mobile_number'\n            ), payload.get('phone_number'), payload.get('birthday'\n            ), payload.get('notes')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/contacts/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def contacts_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Contact\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/contacts/{uuid}', **kwargs)\n        return response\n\n    def contacts_sites(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Sites\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'type', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('type'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_sites.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/contacts/{uuid}/sites',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def contacts_sites_create(self, uuid: str, uuid_site: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Site\n\n        Args:\n            uuid (str, required): uuid\n            uuid_site (str, required): uuid_site\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_sites_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/contacts/{uuid}/sites/{uuid_site}', payload=payload, **kwargs)\n        return response\n\n    def contacts_sites_put(self, uuid: str, uuid_site: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Site\n\n        Args:\n            uuid (str, required): uuid\n            uuid_site (str, required): uuid_site\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_sites_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/contacts/{uuid}/sites/{uuid_site}', payload=payload, **kwargs)\n        return response\n\n    def contacts_sites_delete(self, uuid: str, uuid_site: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Site\n\n        Args:\n            uuid (str, required): uuid\n            uuid_site (str, required): uuid_site\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/contacts/{uuid}/sites/{uuid_site}', **kwargs)\n        return response\n\n    def contacts_customers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Customers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'type', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('type'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_customers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/contacts/{uuid}/customers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def contacts_customers_create(self, uuid: str, uuid_customer: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Customer\n\n        Args:\n            uuid (str, required): uuid\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_customers_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/contacts/{uuid}/customers/{uuid_customer}', payload=payload,\n            **kwargs)\n        return response\n\n    def contacts_customers_put(self, uuid: str, uuid_customer: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Customer\n\n        Args:\n            uuid (str, required): uuid\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_customers_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/contacts/{uuid}/customers/{uuid_customer}', payload=payload,\n            **kwargs)\n        return response\n\n    def contacts_customers_delete(self, uuid: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Customer\n\n        Args:\n            uuid (str, required): uuid\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/contacts/{uuid}/customers/{uuid_customer}', **kwargs)\n        return response\n\n    def contacts_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            send_email (boolean optional): additional filter - parameter\n            role_email (string optional): additional filter - parameter\n            send_sms (boolean optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'send_email', 'role_email',\n            'send_sms', 'active_at_timestamp', 'tag', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('send_email'), params.get('role_email'\n            ), params.get('send_sms'), params.get('active_at_timestamp'\n            ), params.get('tag'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/contacts/{uuid}/dispatchers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def contacts_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            send_email (boolean required): additional filter - payload\n            role_email ( optional): additional filter - payload\n            send_sms (boolean required): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['send_email', 'role_email', 'send_sms',\n            'endpoint']\n        payload.get('send_email'), payload.get('role_email'), payload.get(\n            'send_sms'), payload.get('endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_dispatchers_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/contacts/{uuid}/dispatchers/{uuid_dispatcher}', payload=\n            payload, **kwargs)\n        return response\n\n    def contacts_dispatchers_put(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            send_email (boolean optional): additional filter - payload\n            role_email ( optional): additional filter - payload\n            send_sms (boolean optional): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['send_email', 'role_email', 'send_sms',\n            'endpoint']\n        payload.get('send_email'), payload.get('role_email'), payload.get(\n            'send_sms'), payload.get('endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_dispatchers_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/contacts/{uuid}/dispatchers/{uuid_dispatcher}', payload=\n            payload, **kwargs)\n        return response\n\n    def contacts_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/contacts/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def contacts_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read \n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/contacts/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def contacts_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"type\": \"string\", optional\n            \"name\": \"string\", required\n            \"surname\": \"string\", required\n            \"qualification\": \"string\", optional\n            \"company\": \"string\", optional\n            \"department\": \"string\", optional\n            \"principal_email\": \"string\", optional\n            \"secondary_email\": \"string\", optional\n            \"principal_mobile_number\": \"string\", optional\n            \"secondary_mobile_number\": \"string\", optional\n            \"phone_number\": \"string\", optional\n            \"birthday\": \"string\", optional\n            \"notes\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/contacts/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def contacts_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/contacts/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def contacts_customers_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Customers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_customer\": \"string\", required\n            \"type\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_customers_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/contacts/bulk/create/customers', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def contacts_customers_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Customers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_customer\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/contacts/bulk/delete/customers', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def contacts_dispatchers_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Dispatchers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_dispatcher\": \"string\", required\n            \"send_email\": \"boolean\", optional\n            \"role_email\": \"\", optional\n            \"send_sms\": \"boolean\", optional\n            \"endpoint\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_dispatchers_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/contacts/bulk/create/dispatchers', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def contacts_dispatchers_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Dispatchers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_dispatcher\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/contacts/bulk/delete/dispatchers', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def contacts_sites_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Sites\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_site\": \"string\", required\n            \"type\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.contacts_sites_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/contacts/bulk/create/sites',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def contacts_sites_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Sites\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_site\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/contacts/bulk/delete/sites',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contact","title":"<code>contact(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contact(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Contact\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/contacts/{uuid}', warm_start\n        =warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts","title":"<code>contacts(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Contacts</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>surname</code> <code>string optional</code> <p>additional filter - parameter</p> <code>qualification</code> <code>string optional</code> <p>additional filter - parameter</p> <code>company</code> <code>string optional</code> <p>additional filter - parameter</p> <code>department</code> <code>string optional</code> <p>additional filter - parameter</p> <code>principal_email</code> <code>string optional</code> <p>additional filter - parameter</p> <code>secondary_email</code> <code>string optional</code> <p>additional filter - parameter</p> <code>principal_mobile_number</code> <code>string optional</code> <p>additional filter - parameter</p> <code>secondary_mobile_number</code> <code>string optional</code> <p>additional filter - parameter</p> <code>phone_number</code> <code>string optional</code> <p>additional filter - parameter</p> <code>birthday</code> <code>string optional</code> <p>additional filter - parameter</p> <code>notes</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Contacts\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        surname (string optional): additional filter - parameter\n        qualification (string optional): additional filter - parameter\n        company (string optional): additional filter - parameter\n        department (string optional): additional filter - parameter\n        principal_email (string optional): additional filter - parameter\n        secondary_email (string optional): additional filter - parameter\n        principal_mobile_number (string optional): additional filter - parameter\n        secondary_mobile_number (string optional): additional filter - parameter\n        phone_number (string optional): additional filter - parameter\n        birthday (string optional): additional filter - parameter\n        notes (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'type', 'name',\n        'surname', 'qualification', 'company', 'department',\n        'principal_email', 'secondary_email', 'principal_mobile_number',\n        'secondary_mobile_number', 'phone_number', 'birthday', 'notes',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('type'\n        ), params.get('name'), params.get('surname'), params.get(\n        'qualification'), params.get('company'), params.get('department'\n        ), params.get('principal_email'), params.get('secondary_email'\n        ), params.get('principal_mobile_number'), params.get(\n        'secondary_mobile_number'), params.get('phone_number'), params.get(\n        'birthday'), params.get('notes'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/contacts/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_bulk","title":"<code>contacts_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read </p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read \n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/contacts/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_create","title":"<code>contacts_create(kwargs=None, **payload)</code>","text":"<p>Create Contact</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>surname</code> <code>string required</code> <p>additional filter - payload</p> <code>qualification</code> <code>string optional</code> <p>additional filter - payload</p> <code>company</code> <code>string optional</code> <p>additional filter - payload</p> <code>department</code> <code>string optional</code> <p>additional filter - payload</p> <code>principal_email</code> <code>string optional</code> <p>additional filter - payload</p> <code>secondary_email</code> <code>string optional</code> <p>additional filter - payload</p> <code>principal_mobile_number</code> <code>string optional</code> <p>additional filter - payload</p> <code>secondary_mobile_number</code> <code>string optional</code> <p>additional filter - payload</p> <code>phone_number</code> <code>string optional</code> <p>additional filter - payload</p> <code>birthday</code> <code>string optional</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Contact\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string optional): additional filter - payload\n        name (string required): additional filter - payload\n        surname (string required): additional filter - payload\n        qualification (string optional): additional filter - payload\n        company (string optional): additional filter - payload\n        department (string optional): additional filter - payload\n        principal_email (string optional): additional filter - payload\n        secondary_email (string optional): additional filter - payload\n        principal_mobile_number (string optional): additional filter - payload\n        secondary_mobile_number (string optional): additional filter - payload\n        phone_number (string optional): additional filter - payload\n        birthday (string optional): additional filter - payload\n        notes (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type', 'name', 'surname', 'qualification',\n        'company', 'department', 'principal_email', 'secondary_email',\n        'principal_mobile_number', 'secondary_mobile_number',\n        'phone_number', 'birthday', 'notes']\n    payload.get('type'), payload.get('name'), payload.get('surname'\n        ), payload.get('qualification'), payload.get('company'\n        ), payload.get('department'), payload.get('principal_email'\n        ), payload.get('secondary_email'), payload.get(\n        'principal_mobile_number'), payload.get('secondary_mobile_number'\n        ), payload.get('phone_number'), payload.get('birthday'\n        ), payload.get('notes')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/contacts/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_create_bulk","title":"<code>contacts_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"type\": \"string\", optional     \"name\": \"string\", required     \"surname\": \"string\", required     \"qualification\": \"string\", optional     \"company\": \"string\", optional     \"department\": \"string\", optional     \"principal_email\": \"string\", optional     \"secondary_email\": \"string\", optional     \"principal_mobile_number\": \"string\", optional     \"secondary_mobile_number\": \"string\", optional     \"phone_number\": \"string\", optional     \"birthday\": \"string\", optional     \"notes\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"type\": \"string\", optional\n        \"name\": \"string\", required\n        \"surname\": \"string\", required\n        \"qualification\": \"string\", optional\n        \"company\": \"string\", optional\n        \"department\": \"string\", optional\n        \"principal_email\": \"string\", optional\n        \"secondary_email\": \"string\", optional\n        \"principal_mobile_number\": \"string\", optional\n        \"secondary_mobile_number\": \"string\", optional\n        \"phone_number\": \"string\", optional\n        \"birthday\": \"string\", optional\n        \"notes\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/contacts/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_customers","title":"<code>contacts_customers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Customers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_customers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Customers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'type', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('type'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_customers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/contacts/{uuid}/customers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_customers_create","title":"<code>contacts_customers_create(uuid, uuid_customer, kwargs=None, **payload)</code>","text":"<p>Add Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_customers_create(self, uuid: str, uuid_customer: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Customer\n\n    Args:\n        uuid (str, required): uuid\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_customers_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/contacts/{uuid}/customers/{uuid_customer}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_customers_create_bulk","title":"<code>contacts_customers_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Customers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_customer\": \"string\", required     \"type\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_customers_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Customers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_customer\": \"string\", required\n        \"type\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_customers_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/contacts/bulk/create/customers', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_customers_delete","title":"<code>contacts_customers_delete(uuid, uuid_customer, kwargs=None)</code>","text":"<p>Remove Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_customers_delete(self, uuid: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Customer\n\n    Args:\n        uuid (str, required): uuid\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/contacts/{uuid}/customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_customers_delete_bulk","title":"<code>contacts_customers_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Customers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_customer\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_customers_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Customers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_customer\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/contacts/bulk/delete/customers', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_customers_put","title":"<code>contacts_customers_put(uuid, uuid_customer, kwargs=None, **payload)</code>","text":"<p>Update Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_customers_put(self, uuid: str, uuid_customer: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Customer\n\n    Args:\n        uuid (str, required): uuid\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_customers_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/contacts/{uuid}/customers/{uuid_customer}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_delete","title":"<code>contacts_delete(uuid, kwargs=None)</code>","text":"<p>Delete Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Contact\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/contacts/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_delete_bulk","title":"<code>contacts_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/contacts/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_dispatchers","title":"<code>contacts_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>send_email</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>role_email</code> <code>string optional</code> <p>additional filter - parameter</p> <code>send_sms</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        send_email (boolean optional): additional filter - parameter\n        role_email (string optional): additional filter - parameter\n        send_sms (boolean optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'send_email', 'role_email',\n        'send_sms', 'active_at_timestamp', 'tag', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('send_email'), params.get('role_email'\n        ), params.get('send_sms'), params.get('active_at_timestamp'\n        ), params.get('tag'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/contacts/{uuid}/dispatchers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_dispatchers_create","title":"<code>contacts_dispatchers_create(uuid, uuid_dispatcher, kwargs=None, **payload)</code>","text":"<p>Add Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>send_email</code> <code>boolean required</code> <p>additional filter - payload</p> <code>role_email</code> <code>optional</code> <p>additional filter - payload</p> <code>send_sms</code> <code>boolean required</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        send_email (boolean required): additional filter - payload\n        role_email ( optional): additional filter - payload\n        send_sms (boolean required): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['send_email', 'role_email', 'send_sms',\n        'endpoint']\n    payload.get('send_email'), payload.get('role_email'), payload.get(\n        'send_sms'), payload.get('endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_dispatchers_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/contacts/{uuid}/dispatchers/{uuid_dispatcher}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_dispatchers_create_bulk","title":"<code>contacts_dispatchers_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_dispatcher\": \"string\", required     \"send_email\": \"boolean\", optional     \"role_email\": \"\", optional     \"send_sms\": \"boolean\", optional     \"endpoint\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_dispatchers_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Dispatchers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_dispatcher\": \"string\", required\n        \"send_email\": \"boolean\", optional\n        \"role_email\": \"\", optional\n        \"send_sms\": \"boolean\", optional\n        \"endpoint\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_dispatchers_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/contacts/bulk/create/dispatchers', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_dispatchers_delete","title":"<code>contacts_dispatchers_delete(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Delete Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/contacts/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_dispatchers_delete_bulk","title":"<code>contacts_dispatchers_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_dispatcher\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_dispatchers_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Dispatchers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_dispatcher\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/contacts/bulk/delete/dispatchers', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_dispatchers_put","title":"<code>contacts_dispatchers_put(uuid, uuid_dispatcher, kwargs=None, **payload)</code>","text":"<p>Update Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>send_email</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>role_email</code> <code>optional</code> <p>additional filter - payload</p> <code>send_sms</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_dispatchers_put(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        send_email (boolean optional): additional filter - payload\n        role_email ( optional): additional filter - payload\n        send_sms (boolean optional): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['send_email', 'role_email', 'send_sms',\n        'endpoint']\n    payload.get('send_email'), payload.get('role_email'), payload.get(\n        'send_sms'), payload.get('endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_dispatchers_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/contacts/{uuid}/dispatchers/{uuid_dispatcher}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_put","title":"<code>contacts_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>surname</code> <code>string optional</code> <p>additional filter - payload</p> <code>qualification</code> <code>string optional</code> <p>additional filter - payload</p> <code>company</code> <code>string optional</code> <p>additional filter - payload</p> <code>department</code> <code>string optional</code> <p>additional filter - payload</p> <code>principal_email</code> <code>string optional</code> <p>additional filter - payload</p> <code>secondary_email</code> <code>string optional</code> <p>additional filter - payload</p> <code>principal_mobile_number</code> <code>string optional</code> <p>additional filter - payload</p> <code>secondary_mobile_number</code> <code>string optional</code> <p>additional filter - payload</p> <code>phone_number</code> <code>string optional</code> <p>additional filter - payload</p> <code>birthday</code> <code>string optional</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Contact\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        surname (string optional): additional filter - payload\n        qualification (string optional): additional filter - payload\n        company (string optional): additional filter - payload\n        department (string optional): additional filter - payload\n        principal_email (string optional): additional filter - payload\n        secondary_email (string optional): additional filter - payload\n        principal_mobile_number (string optional): additional filter - payload\n        secondary_mobile_number (string optional): additional filter - payload\n        phone_number (string optional): additional filter - payload\n        birthday (string optional): additional filter - payload\n        notes (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type', 'name', 'surname', 'qualification',\n        'company', 'department', 'principal_email', 'secondary_email',\n        'principal_mobile_number', 'secondary_mobile_number',\n        'phone_number', 'birthday', 'notes']\n    payload.get('type'), payload.get('name'), payload.get('surname'\n        ), payload.get('qualification'), payload.get('company'\n        ), payload.get('department'), payload.get('principal_email'\n        ), payload.get('secondary_email'), payload.get(\n        'principal_mobile_number'), payload.get('secondary_mobile_number'\n        ), payload.get('phone_number'), payload.get('birthday'\n        ), payload.get('notes')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/contacts/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_sites","title":"<code>contacts_sites(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Sites</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_sites(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Sites\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'type', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('type'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_sites.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/contacts/{uuid}/sites',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_sites_create","title":"<code>contacts_sites_create(uuid, uuid_site, kwargs=None, **payload)</code>","text":"<p>Add Site</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_site</code> <code>(str, required)</code> <p>uuid_site</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_sites_create(self, uuid: str, uuid_site: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Site\n\n    Args:\n        uuid (str, required): uuid\n        uuid_site (str, required): uuid_site\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_sites_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/contacts/{uuid}/sites/{uuid_site}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_sites_create_bulk","title":"<code>contacts_sites_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Sites</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_site\": \"string\", required     \"type\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_sites_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Sites\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_site\": \"string\", required\n        \"type\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_sites_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/contacts/bulk/create/sites',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_sites_delete","title":"<code>contacts_sites_delete(uuid, uuid_site, kwargs=None)</code>","text":"<p>Remove Site</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_site</code> <code>(str, required)</code> <p>uuid_site</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_sites_delete(self, uuid: str, uuid_site: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Site\n\n    Args:\n        uuid (str, required): uuid\n        uuid_site (str, required): uuid_site\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/contacts/{uuid}/sites/{uuid_site}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_sites_delete_bulk","title":"<code>contacts_sites_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Sites</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_site\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_sites_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Sites\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_site\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/contacts/bulk/delete/sites',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.contacts/#hive.cookbook.contacts.Contacts.contacts_sites_put","title":"<code>contacts_sites_put(uuid, uuid_site, kwargs=None, **payload)</code>","text":"<p>Update Site</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_site</code> <code>(str, required)</code> <p>uuid_site</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/contacts.py</code> <pre><code>def contacts_sites_put(self, uuid: str, uuid_site: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Site\n\n    Args:\n        uuid (str, required): uuid\n        uuid_site (str, required): uuid_site\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.contacts_sites_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/contacts/{uuid}/sites/{uuid_site}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tagging/","title":"Hive.cookbook.cost tagging","text":""},{"location":"hive.cookbook.cost_tagging/#hive.cookbook.cost_tagging.CostTagging","title":"<code>CostTagging</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata cost_tagging APIs</p> Source code in <code>hive/cookbook/cost_tagging.py</code> <pre><code>class CostTagging(ApiManager):\n    \"\"\"Class that handles all the XAutomata cost_tagging APIs\"\"\"\n\n    def cost_tagging(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Taggings\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_view (string optional): additional filter - parameter\n            uuid_tag (string optional): additional filter - parameter\n            tag_code (string optional): additional filter - parameter\n            cost_category (string optional): additional filter - parameter\n            cost_category_value (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_view', 'uuid_tag',\n            'tag_code', 'cost_category', 'cost_category_value',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_view'), params.get('uuid_tag'\n            ), params.get('tag_code'), params.get('cost_category'), params.get(\n            'cost_category_value'), params.get('null_fields'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tagging.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_tagging/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def cost_tagging_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Cost Tagging\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            cost_category_value (string required): additional filter - payload\n            cost_category (string required): additional filter - payload\n            uuid_view (string required): additional filter - payload\n            uuid_tag (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['cost_category_value', 'cost_category',\n            'uuid_view', 'uuid_tag']\n        payload.get('cost_category_value'), payload.get('cost_category'\n            ), payload.get('uuid_view'), payload.get('uuid_tag')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tagging_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/cost_tagging/', payload=\n            payload, **kwargs)\n        return response\n\n    def cost_tagging_uuid(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Tagging\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tagging.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_tagging/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tagging_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Cost Tagging\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            tag_code (string optional): additional filter - payload\n            cost_category_value (string optional): additional filter - payload\n            cost_category (string optional): additional filter - payload\n            uuid_view (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['tag_code', 'cost_category_value',\n            'cost_category', 'uuid_view']\n        payload.get('tag_code'), payload.get('cost_category_value'\n            ), payload.get('cost_category'), payload.get('uuid_view')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tagging_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/cost_tagging/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def cost_tagging_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Cost Tagging\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/cost_tagging/{uuid}', **\n            kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.cost_tagging/#hive.cookbook.cost_tagging.CostTagging.cost_tagging","title":"<code>cost_tagging(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Cost Taggings</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>cost_category</code> <code>string optional</code> <p>additional filter - parameter</p> <code>cost_category_value</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tagging.py</code> <pre><code>def cost_tagging(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Taggings\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_view (string optional): additional filter - parameter\n        uuid_tag (string optional): additional filter - parameter\n        tag_code (string optional): additional filter - parameter\n        cost_category (string optional): additional filter - parameter\n        cost_category_value (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_view', 'uuid_tag',\n        'tag_code', 'cost_category', 'cost_category_value',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_view'), params.get('uuid_tag'\n        ), params.get('tag_code'), params.get('cost_category'), params.get(\n        'cost_category_value'), params.get('null_fields'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tagging.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_tagging/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tagging/#hive.cookbook.cost_tagging.CostTagging.cost_tagging_create","title":"<code>cost_tagging_create(kwargs=None, **payload)</code>","text":"<p>Create Cost Tagging</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>cost_category_value</code> <code>string required</code> <p>additional filter - payload</p> <code>cost_category</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_view</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_tag</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tagging.py</code> <pre><code>def cost_tagging_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Cost Tagging\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        cost_category_value (string required): additional filter - payload\n        cost_category (string required): additional filter - payload\n        uuid_view (string required): additional filter - payload\n        uuid_tag (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['cost_category_value', 'cost_category',\n        'uuid_view', 'uuid_tag']\n    payload.get('cost_category_value'), payload.get('cost_category'\n        ), payload.get('uuid_view'), payload.get('uuid_tag')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tagging_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/cost_tagging/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tagging/#hive.cookbook.cost_tagging.CostTagging.cost_tagging_delete","title":"<code>cost_tagging_delete(uuid, kwargs=None)</code>","text":"<p>Delete Cost Tagging</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tagging.py</code> <pre><code>def cost_tagging_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Cost Tagging\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/cost_tagging/{uuid}', **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tagging/#hive.cookbook.cost_tagging.CostTagging.cost_tagging_put","title":"<code>cost_tagging_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Cost Tagging</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tag_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>cost_category_value</code> <code>string optional</code> <p>additional filter - payload</p> <code>cost_category</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tagging.py</code> <pre><code>def cost_tagging_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Cost Tagging\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        tag_code (string optional): additional filter - payload\n        cost_category_value (string optional): additional filter - payload\n        cost_category (string optional): additional filter - payload\n        uuid_view (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['tag_code', 'cost_category_value',\n        'cost_category', 'uuid_view']\n    payload.get('tag_code'), payload.get('cost_category_value'\n        ), payload.get('cost_category'), payload.get('uuid_view')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tagging_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/cost_tagging/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tagging/#hive.cookbook.cost_tagging.CostTagging.cost_tagging_uuid","title":"<code>cost_tagging_uuid(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Cost Tagging</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tagging.py</code> <pre><code>def cost_tagging_uuid(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Tagging\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tagging.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_tagging/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/","title":"Hive.cookbook.cost tags","text":""},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags","title":"<code>CostTags</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata cost_tags APIs</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>class CostTags(ApiManager):\n    \"\"\"Class that handles all the XAutomata cost_tags APIs\"\"\"\n\n    def cost_tags(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Tags\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_view (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            data_profile (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_view', 'code',\n            'description', 'data_profile', 'null_fields', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_view'), params.get('code'\n            ), params.get('description'), params.get('data_profile'\n            ), params.get('null_fields'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tags.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_tags/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def cost_tags_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Cost Tag\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            description (string required): additional filter - payload\n            data_profile (array object required): additional filter - payload\n            uuid_view (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'data_profile',\n            'uuid_view']\n        payload.get('code'), payload.get('description'), payload.get(\n            'data_profile'), payload.get('uuid_view')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tags_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/cost_tags/', payload=\n            payload, **kwargs)\n        return response\n\n    def cost_tags_query_bulk(self, payload: dict = False,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Ts Costs Rows\n\n        Args:\n            payload (dict, optional): additional parameters for the API.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n\n        Examples:\n            payload = \n           {\n            \"uuid_view\": \"string\", required\n            \"select_operation\": \"None\", optional\n            \"selected_tags\": \"array\", optional\n            \"unselect_operation\": \"None\", optional\n            \"unselected_tags\": \"array\", optional\n           }\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'sort_by']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('sort_by')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tags_query_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/cost_tags/query/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def cost_tag(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Tag\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tag.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_tags/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tags_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Cost Tag\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            uuid_view (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'data_profile',\n            'uuid_view']\n        payload.get('code'), payload.get('description'), payload.get(\n            'data_profile'), payload.get('uuid_view')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tags_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/cost_tags/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def cost_tags_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Cost Tag\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/cost_tags/{uuid}', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags.cost_tag","title":"<code>cost_tag(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Cost Tag</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>def cost_tag(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Tag\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tag.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_tags/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags.cost_tags","title":"<code>cost_tags(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Cost Tags</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>def cost_tags(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Tags\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_view (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        data_profile (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_view', 'code',\n        'description', 'data_profile', 'null_fields', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_view'), params.get('code'\n        ), params.get('description'), params.get('data_profile'\n        ), params.get('null_fields'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tags.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_tags/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags.cost_tags_create","title":"<code>cost_tags_create(kwargs=None, **payload)</code>","text":"<p>Create Cost Tag</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object required</code> <p>additional filter - payload</p> <code>uuid_view</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>def cost_tags_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Cost Tag\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        description (string required): additional filter - payload\n        data_profile (array object required): additional filter - payload\n        uuid_view (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'data_profile',\n        'uuid_view']\n    payload.get('code'), payload.get('description'), payload.get(\n        'data_profile'), payload.get('uuid_view')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tags_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/cost_tags/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags.cost_tags_delete","title":"<code>cost_tags_delete(uuid, kwargs=None)</code>","text":"<p>Delete Cost Tag</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>def cost_tags_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Cost Tag\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/cost_tags/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags.cost_tags_put","title":"<code>cost_tags_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Cost Tag</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>def cost_tags_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Cost Tag\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        uuid_view (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'data_profile',\n        'uuid_view']\n    payload.get('code'), payload.get('description'), payload.get(\n        'data_profile'), payload.get('uuid_view')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tags_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/cost_tags/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tags/#hive.cookbook.cost_tags.CostTags.cost_tags_query_bulk","title":"<code>cost_tags_query_bulk(payload=False, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Ts Costs Rows</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <p>Examples:</p> <p>payload = </p> <p>{     \"uuid_view\": \"string\", required     \"select_operation\": \"None\", optional     \"selected_tags\": \"array\", optional     \"unselect_operation\": \"None\", optional     \"unselected_tags\": \"array\", optional    }</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tags.py</code> <pre><code>def cost_tags_query_bulk(self, payload: dict = False,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Ts Costs Rows\n\n    Args:\n        payload (dict, optional): additional parameters for the API.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n\n    Examples:\n        payload = \n       {\n        \"uuid_view\": \"string\", required\n        \"select_operation\": \"None\", optional\n        \"selected_tags\": \"array\", optional\n        \"unselect_operation\": \"None\", optional\n        \"unselected_tags\": \"array\", optional\n       }\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'sort_by']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('sort_by')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tags_query_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/cost_tags/query/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/","title":"Hive.cookbook.cost tree nodes","text":""},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes","title":"<code>CostTreeNodes</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata cost_tree_nodes APIs</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>class CostTreeNodes(ApiManager):\n    \"\"\"Class that handles all the XAutomata cost_tree_nodes APIs\"\"\"\n\n    def cost_tree_nodes(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Tree Nodes\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_parent (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            uuid_view (string optional): additional filter - parameter\n            budget (integer optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_parent', 'code',\n            'description', 'uuid_view', 'budget', 'null_fields', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_parent'), params.get('code'\n            ), params.get('description'), params.get('uuid_view'), params.get(\n            'budget'), params.get('null_fields'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_nodes.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_tree_nodes/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tree_nodes_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Cost Tree Node\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_parent (string optional): additional filter - payload\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            uuid_view (string required): additional filter - payload\n            budget (integer optional): additional filter - payload\n            criteria (array object optional): additional filter - payload\n            virtual (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_parent', 'code', 'description',\n            'uuid_view', 'budget', 'criteria', 'virtual']\n        payload.get('uuid_parent'), payload.get('code'), payload.get(\n            'description'), payload.get('uuid_view'), payload.get('budget'\n            ), payload.get('criteria'), payload.get('virtual')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_nodes_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/cost_tree_nodes/', payload=\n            payload, **kwargs)\n        return response\n\n    def cost_tree_node(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Tree Node\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_node.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_tree_nodes/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tree_nodes_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Cost Tree Node\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_parent (string optional): additional filter - payload\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            uuid_view (string optional): additional filter - payload\n            budget (integer optional): additional filter - payload\n            criteria (array object optional): additional filter - payload\n            virtual (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_parent', 'code', 'description',\n            'uuid_view', 'budget', 'criteria', 'virtual']\n        payload.get('uuid_parent'), payload.get('code'), payload.get(\n            'description'), payload.get('uuid_view'), payload.get('budget'\n            ), payload.get('criteria'), payload.get('virtual')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_nodes_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/cost_tree_nodes/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def cost_tree_nodes_delete(self, uuid: str, kwargs: dict = None, **params\n        ) -&gt; list:\n        \"\"\"Delete Cost Tree Node\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            delete_resources (boolean optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['delete_resources']\n        params.get('delete_resources')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_nodes_delete.__name__,\n                params, official_params_list)\n        response = self.execute('DELETE', path=f'/cost_tree_nodes/{uuid}',\n            params=params, **kwargs)\n        return response\n\n    def cost_tree_nodes_navigate_tree(self, uuid: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Tree From Node V2\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            resource_id (string optional): additional filter - parameter\n            previous_period (boolean optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end', 'resource_id',\n            'previous_period']\n        params.get('date_start'), params.get('date_end'), params.get(\n            'resource_id'), params.get('previous_period')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_nodes_navigate_tree.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/cost_tree_nodes/navigate_tree/{uuid}', warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def cost_tree_nodes_get_node_resources(self, uuid: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Resources From Node\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            resource_id (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'resource_id',\n            'skip', 'limit', 'sort_by']\n        params.get('date_start'), params.get('date_end'), params.get(\n            'resource_id'), params.get('skip'), params.get('limit'\n            ), params.get('sort_by')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                cost_tree_nodes_get_node_resources.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/cost_tree_nodes/get_node_resources/{uuid}', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def cost_tree_nodes_resources_by_criteria(self, uuid: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Resources From Node By Criteria\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                cost_tree_nodes_resources_by_criteria.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/cost_tree_nodes/{uuid}/resources_by_criteria', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_node","title":"<code>cost_tree_node(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Cost Tree Node</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_node(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Tree Node\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_node.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_tree_nodes/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes","title":"<code>cost_tree_nodes(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Cost Tree Nodes</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - parameter</p> <code>budget</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Tree Nodes\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_parent (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        uuid_view (string optional): additional filter - parameter\n        budget (integer optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_parent', 'code',\n        'description', 'uuid_view', 'budget', 'null_fields', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_parent'), params.get('code'\n        ), params.get('description'), params.get('uuid_view'), params.get(\n        'budget'), params.get('null_fields'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_nodes.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_tree_nodes/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes_create","title":"<code>cost_tree_nodes_create(kwargs=None, **payload)</code>","text":"<p>Create Cost Tree Node</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_parent</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_view</code> <code>string required</code> <p>additional filter - payload</p> <code>budget</code> <code>integer optional</code> <p>additional filter - payload</p> <code>criteria</code> <code>array object optional</code> <p>additional filter - payload</p> <code>virtual</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Cost Tree Node\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_parent (string optional): additional filter - payload\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        uuid_view (string required): additional filter - payload\n        budget (integer optional): additional filter - payload\n        criteria (array object optional): additional filter - payload\n        virtual (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_parent', 'code', 'description',\n        'uuid_view', 'budget', 'criteria', 'virtual']\n    payload.get('uuid_parent'), payload.get('code'), payload.get(\n        'description'), payload.get('uuid_view'), payload.get('budget'\n        ), payload.get('criteria'), payload.get('virtual')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_nodes_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/cost_tree_nodes/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes_delete","title":"<code>cost_tree_nodes_delete(uuid, kwargs=None, **params)</code>","text":"<p>Delete Cost Tree Node</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>delete_resources</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes_delete(self, uuid: str, kwargs: dict = None, **params\n    ) -&gt; list:\n    \"\"\"Delete Cost Tree Node\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        delete_resources (boolean optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['delete_resources']\n    params.get('delete_resources')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_nodes_delete.__name__,\n            params, official_params_list)\n    response = self.execute('DELETE', path=f'/cost_tree_nodes/{uuid}',\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes_get_node_resources","title":"<code>cost_tree_nodes_get_node_resources(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Resources From Node</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>resource_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes_get_node_resources(self, uuid: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Resources From Node\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        resource_id (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'resource_id',\n        'skip', 'limit', 'sort_by']\n    params.get('date_start'), params.get('date_end'), params.get(\n        'resource_id'), params.get('skip'), params.get('limit'\n        ), params.get('sort_by')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            cost_tree_nodes_get_node_resources.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/cost_tree_nodes/get_node_resources/{uuid}', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes_navigate_tree","title":"<code>cost_tree_nodes_navigate_tree(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Get Tree From Node V2</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>resource_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>previous_period</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes_navigate_tree(self, uuid: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Tree From Node V2\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        resource_id (string optional): additional filter - parameter\n        previous_period (boolean optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end', 'resource_id',\n        'previous_period']\n    params.get('date_start'), params.get('date_end'), params.get(\n        'resource_id'), params.get('previous_period')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_nodes_navigate_tree.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/cost_tree_nodes/navigate_tree/{uuid}', warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes_put","title":"<code>cost_tree_nodes_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Cost Tree Node</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_parent</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - payload</p> <code>budget</code> <code>integer optional</code> <p>additional filter - payload</p> <code>criteria</code> <code>array object optional</code> <p>additional filter - payload</p> <code>virtual</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Cost Tree Node\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_parent (string optional): additional filter - payload\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        uuid_view (string optional): additional filter - payload\n        budget (integer optional): additional filter - payload\n        criteria (array object optional): additional filter - payload\n        virtual (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_parent', 'code', 'description',\n        'uuid_view', 'budget', 'criteria', 'virtual']\n    payload.get('uuid_parent'), payload.get('code'), payload.get(\n        'description'), payload.get('uuid_view'), payload.get('budget'\n        ), payload.get('criteria'), payload.get('virtual')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_nodes_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/cost_tree_nodes/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_nodes/#hive.cookbook.cost_tree_nodes.CostTreeNodes.cost_tree_nodes_resources_by_criteria","title":"<code>cost_tree_nodes_resources_by_criteria(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Get Resources From Node By Criteria</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_nodes.py</code> <pre><code>def cost_tree_nodes_resources_by_criteria(self, uuid: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Resources From Node By Criteria\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            cost_tree_nodes_resources_by_criteria.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/cost_tree_nodes/{uuid}/resources_by_criteria', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/","title":"Hive.cookbook.cost tree resources","text":""},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources","title":"<code>CostTreeResources</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata cost_tree_resources APIs</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>class CostTreeResources(ApiManager):\n    \"\"\"Class that handles all the XAutomata cost_tree_resources APIs\"\"\"\n\n    def cost_tree_resources(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Tree Resources\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_tree_node (string optional): additional filter - parameter\n            uuid_view (string optional): additional filter - parameter\n            cost_category (string optional): additional filter - parameter\n            cost_category_value (string optional): additional filter - parameter\n            percentage (number optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_tree_node', 'uuid_view',\n            'cost_category', 'cost_category_value', 'percentage',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_tree_node'), params.get(\n            'uuid_view'), params.get('cost_category'), params.get(\n            'cost_category_value'), params.get('percentage'), params.get(\n            'null_fields'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_resources.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/cost_tree_resources/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tree_resources_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Cost Tree Resource\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_tree_node (string required): additional filter - payload\n            cost_category (string required): additional filter - payload\n            cost_category_value (string required): additional filter - payload\n            percentage (number optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_tree_node', 'cost_category',\n            'cost_category_value', 'percentage']\n        payload.get('uuid_tree_node'), payload.get('cost_category'\n            ), payload.get('cost_category_value'), payload.get('percentage')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_tree_resources_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/cost_tree_resources/',\n            payload=payload, **kwargs)\n        return response\n\n    def cost_tree_resources_all_resource_ids(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Resource Ids V2\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            uuid_view (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'uuid_customer',\n            'uuid_view', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get(\n            'uuid_customer'), params.get('uuid_view'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                cost_tree_resources_all_resource_ids.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/cost_tree_resources/all_resource_ids/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def cost_tree_resources_unfully_assigned_resource_ids(self,\n        uuid_view: str, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Unfully Assigned Resource Ids V2\n\n        Args:\n            uuid_view (str, required): uuid_view\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                cost_tree_resources_unfully_assigned_resource_ids.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/cost_tree_resources/{uuid_view}/unfully_assigned_resource_ids/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tree_resources_unfully_assigned_resources(self, uuid_view: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Unfully Assigned Resources\n\n        Args:\n            uuid_view (str, required): uuid_view\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            resource_id (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'resource_id',\n            'skip', 'limit', 'count', 'sort_by']\n        params.get('date_start'), params.get('date_end'), params.get(\n            'resource_id'), params.get('skip'), params.get('limit'\n            ), params.get('count'), params.get('sort_by')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                cost_tree_resources_unfully_assigned_resources.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/cost_tree_resources/{uuid_view}/unfully_assigned_resources/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def cost_tree_resources_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Tree Resources\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_tree_node\": \"string\", required\n            \"cost_category\": \"string\", required\n            \"cost_category_value\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/cost_tree_resources/bulk/delete/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def cost_tree_resources_delete(self, uuid_tree_node: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete For Uuid Tree Node\n\n        Args:\n            uuid_tree_node (str, required): uuid_tree_node\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/cost_tree_resources/delete/{uuid_tree_node}', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources","title":"<code>cost_tree_resources(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Cost Tree Resources</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_tree_node</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - parameter</p> <code>cost_category</code> <code>string optional</code> <p>additional filter - parameter</p> <code>cost_category_value</code> <code>string optional</code> <p>additional filter - parameter</p> <code>percentage</code> <code>number optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Tree Resources\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_tree_node (string optional): additional filter - parameter\n        uuid_view (string optional): additional filter - parameter\n        cost_category (string optional): additional filter - parameter\n        cost_category_value (string optional): additional filter - parameter\n        percentage (number optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_tree_node', 'uuid_view',\n        'cost_category', 'cost_category_value', 'percentage',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_tree_node'), params.get(\n        'uuid_view'), params.get('cost_category'), params.get(\n        'cost_category_value'), params.get('percentage'), params.get(\n        'null_fields'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_resources.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/cost_tree_resources/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources_all_resource_ids","title":"<code>cost_tree_resources_all_resource_ids(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Resource Ids V2</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_view</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources_all_resource_ids(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Resource Ids V2\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        uuid_view (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'uuid_customer',\n        'uuid_view', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get(\n        'uuid_customer'), params.get('uuid_view'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            cost_tree_resources_all_resource_ids.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/cost_tree_resources/all_resource_ids/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources_create","title":"<code>cost_tree_resources_create(kwargs=None, **payload)</code>","text":"<p>Create Cost Tree Resource</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_tree_node</code> <code>string required</code> <p>additional filter - payload</p> <code>cost_category</code> <code>string required</code> <p>additional filter - payload</p> <code>cost_category_value</code> <code>string required</code> <p>additional filter - payload</p> <code>percentage</code> <code>number optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Cost Tree Resource\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_tree_node (string required): additional filter - payload\n        cost_category (string required): additional filter - payload\n        cost_category_value (string required): additional filter - payload\n        percentage (number optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_tree_node', 'cost_category',\n        'cost_category_value', 'percentage']\n    payload.get('uuid_tree_node'), payload.get('cost_category'\n        ), payload.get('cost_category_value'), payload.get('percentage')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_tree_resources_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/cost_tree_resources/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources_delete","title":"<code>cost_tree_resources_delete(uuid_tree_node, kwargs=None)</code>","text":"<p>Delete For Uuid Tree Node</p> <p>Parameters:</p> Name Type Description Default <code>uuid_tree_node</code> <code>(str, required)</code> <p>uuid_tree_node</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources_delete(self, uuid_tree_node: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete For Uuid Tree Node\n\n    Args:\n        uuid_tree_node (str, required): uuid_tree_node\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/cost_tree_resources/delete/{uuid_tree_node}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources_delete_bulk","title":"<code>cost_tree_resources_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Tree Resources</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_tree_node\": \"string\", required     \"cost_category\": \"string\", required     \"cost_category_value\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Tree Resources\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_tree_node\": \"string\", required\n        \"cost_category\": \"string\", required\n        \"cost_category_value\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/cost_tree_resources/bulk/delete/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources_unfully_assigned_resource_ids","title":"<code>cost_tree_resources_unfully_assigned_resource_ids(uuid_view, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Unfully Assigned Resource Ids V2</p> <p>Parameters:</p> Name Type Description Default <code>uuid_view</code> <code>(str, required)</code> <p>uuid_view</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources_unfully_assigned_resource_ids(self,\n    uuid_view: str, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Unfully Assigned Resource Ids V2\n\n    Args:\n        uuid_view (str, required): uuid_view\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            cost_tree_resources_unfully_assigned_resource_ids.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/cost_tree_resources/{uuid_view}/unfully_assigned_resource_ids/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_tree_resources/#hive.cookbook.cost_tree_resources.CostTreeResources.cost_tree_resources_unfully_assigned_resources","title":"<code>cost_tree_resources_unfully_assigned_resources(uuid_view, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Unfully Assigned Resources</p> <p>Parameters:</p> Name Type Description Default <code>uuid_view</code> <code>(str, required)</code> <p>uuid_view</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>resource_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_tree_resources.py</code> <pre><code>def cost_tree_resources_unfully_assigned_resources(self, uuid_view: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Unfully Assigned Resources\n\n    Args:\n        uuid_view (str, required): uuid_view\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        resource_id (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'resource_id',\n        'skip', 'limit', 'count', 'sort_by']\n    params.get('date_start'), params.get('date_end'), params.get(\n        'resource_id'), params.get('skip'), params.get('limit'\n        ), params.get('count'), params.get('sort_by')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            cost_tree_resources_unfully_assigned_resources.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/cost_tree_resources/{uuid_view}/unfully_assigned_resources/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/","title":"Hive.cookbook.cost views","text":""},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews","title":"<code>CostViews</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata cost_views APIs</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>class CostViews(ApiManager):\n    \"\"\"Class that handles all the XAutomata cost_views APIs\"\"\"\n\n    def cost_views(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost Views\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'name', 'description', 'type',\n            'uuid_customer', 'null_fields', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('sort_by'), params.get('name'), params.get('description'\n            ), params.get('type'), params.get('uuid_customer'), params.get(\n            'null_fields'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_views.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_views/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def cost_views_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Cost View\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            type (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'name', 'description', 'type'\n            ]\n        payload.get('uuid_customer'), payload.get('name'), payload.get(\n            'description'), payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_views_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/cost_views/', payload=\n            payload, **kwargs)\n        return response\n\n    def cost_view(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost View\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_view.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_views/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def cost_views_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Cost View\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'description']\n        payload.get('name'), payload.get('description')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_views_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/cost_views/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def cost_views_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Cost View\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/cost_views/{uuid}', **kwargs)\n        return response\n\n    def cost_views_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Cost View Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.cost_views_users.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/cost_views/{uuid}/users',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def cost_views_users_create(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Create Association With User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/cost_views/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def cost_views_users_delete(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Association With User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/cost_views/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def cost_views_assign_resources_create(self, uuid: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Set Resources From Node By Criteria\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                cost_views_assign_resources_create.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/cost_views/{uuid}/assign_resources', params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_view","title":"<code>cost_view(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Cost View</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_view(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost View\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_view.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_views/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views","title":"<code>cost_views(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Cost Views</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost Views\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'name', 'description', 'type',\n        'uuid_customer', 'null_fields', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('sort_by'), params.get('name'), params.get('description'\n        ), params.get('type'), params.get('uuid_customer'), params.get(\n        'null_fields'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_views.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_views/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_assign_resources_create","title":"<code>cost_views_assign_resources_create(uuid, kwargs=None, **params)</code>","text":"<p>Set Resources From Node By Criteria</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_assign_resources_create(self, uuid: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Set Resources From Node By Criteria\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            cost_views_assign_resources_create.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/cost_views/{uuid}/assign_resources', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_create","title":"<code>cost_views_create(kwargs=None, **payload)</code>","text":"<p>Create Cost View</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Cost View\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        type (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'name', 'description', 'type'\n        ]\n    payload.get('uuid_customer'), payload.get('name'), payload.get(\n        'description'), payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_views_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/cost_views/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_delete","title":"<code>cost_views_delete(uuid, kwargs=None)</code>","text":"<p>Delete Cost View</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Cost View\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/cost_views/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_put","title":"<code>cost_views_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Cost View</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Cost View\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'description']\n    payload.get('name'), payload.get('description')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_views_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/cost_views/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_users","title":"<code>cost_views_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Cost View Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Cost View Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.cost_views_users.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/cost_views/{uuid}/users',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_users_create","title":"<code>cost_views_users_create(uuid, name, kwargs=None)</code>","text":"<p>Create Association With User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_users_create(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Create Association With User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/cost_views/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.cost_views/#hive.cookbook.cost_views.CostViews.cost_views_users_delete","title":"<code>cost_views_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Delete Association With User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/cost_views.py</code> <pre><code>def cost_views_users_delete(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Association With User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/cost_views/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/","title":"Hive.cookbook.customers","text":""},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers","title":"<code>Customers</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata customers APIs</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>class Customers(ApiManager):\n    \"\"\"Class that handles all the XAutomata customers APIs\"\"\"\n\n    def customers(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Customers\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            company_name (string optional): additional filter - parameter\n            address (string optional): additional filter - parameter\n            zip_code (string optional): additional filter - parameter\n            city (string optional): additional filter - parameter\n            country (string optional): additional filter - parameter\n            notes (string optional): additional filter - parameter\n            vat_id (string optional): additional filter - parameter\n            currency (string optional): additional filter - parameter\n            state_province (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            registration_date (string optional): additional filter - parameter\n            paying_customer (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'type', 'code',\n            'company_name', 'address', 'zip_code', 'city', 'country',\n            'notes', 'vat_id', 'currency', 'state_province', 'status',\n            'registration_date', 'paying_customer', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('type'\n            ), params.get('code'), params.get('company_name'), params.get(\n            'address'), params.get('zip_code'), params.get('city'), params.get(\n            'country'), params.get('notes'), params.get('vat_id'), params.get(\n            'currency'), params.get('state_province'), params.get('status'\n            ), params.get('registration_date'), params.get('paying_customer'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/customers/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def customers_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Customer\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string optional): additional filter - payload\n            code (string required): additional filter - payload\n            company_name (string required): additional filter - payload\n            address (string required): additional filter - payload\n            zip_code (string required): additional filter - payload\n            city (string required): additional filter - payload\n            country (string required): additional filter - payload\n            notes (string optional): additional filter - payload\n            vat_id (string optional): additional filter - payload\n            currency (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            status (string required): additional filter - payload\n            profile (string optional): additional filter - payload\n            registration_date (string optional): additional filter - payload\n            paying_customer (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type', 'code', 'company_name', 'address',\n            'zip_code', 'city', 'country', 'notes', 'vat_id', 'currency',\n            'state_province', 'status', 'profile', 'registration_date',\n            'paying_customer']\n        payload.get('type'), payload.get('code'), payload.get('company_name'\n            ), payload.get('address'), payload.get('zip_code'), payload.get(\n            'city'), payload.get('country'), payload.get('notes'), payload.get(\n            'vat_id'), payload.get('currency'), payload.get('state_province'\n            ), payload.get('status'), payload.get('profile'), payload.get(\n            'registration_date'), payload.get('paying_customer')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/customers/', payload=\n            payload, **kwargs)\n        return response\n\n    def customer(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Customer\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/customers/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def customers_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Customer\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string optional): additional filter - payload\n            code (string optional): additional filter - payload\n            company_name (string optional): additional filter - payload\n            address (string optional): additional filter - payload\n            zip_code (string optional): additional filter - payload\n            city (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            notes (string optional): additional filter - payload\n            vat_id (string optional): additional filter - payload\n            currency (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            status (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            registration_date (string optional): additional filter - payload\n            paying_customer (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type', 'code', 'company_name', 'address',\n            'zip_code', 'city', 'country', 'notes', 'vat_id', 'currency',\n            'state_province', 'status', 'profile', 'registration_date',\n            'paying_customer']\n        payload.get('type'), payload.get('code'), payload.get('company_name'\n            ), payload.get('address'), payload.get('zip_code'), payload.get(\n            'city'), payload.get('country'), payload.get('notes'), payload.get(\n            'vat_id'), payload.get('currency'), payload.get('state_province'\n            ), payload.get('status'), payload.get('profile'), payload.get(\n            'registration_date'), payload.get('paying_customer')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/customers/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def customers_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Customer\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/customers/{uuid}', **kwargs)\n        return response\n\n    def customers_register_create(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Registration Form\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            app_id (string optional): additional filter - parameter\n            vat_id (string required): additional filter - payload\n            company_name (string required): additional filter - payload\n            address (string required): additional filter - payload\n            zip_code (string required): additional filter - payload\n            city (string required): additional filter - payload\n            country (string required): additional filter - payload\n            state_province (string optional): additional filter - payload\n            currency (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['vat_id', 'company_name', 'address',\n            'zip_code', 'city', 'country', 'state_province', 'currency']\n        payload.get('vat_id'), payload.get('company_name'), payload.get(\n            'address'), payload.get('zip_code'), payload.get('city'\n            ), payload.get('country'), payload.get('state_province'\n            ), payload.get('currency')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_register_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/customers/register/',\n            params=params, payload=payload, **kwargs)\n        return response\n\n    def customers_relation_request_create(self, uuid_customer: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Create Relation Request\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            app_id (string optional): additional filter - parameter\n            refresh (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['app_id', 'refresh']\n        params.get('app_id'), params.get('refresh')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_relation_request_create\n                .__name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/customers/relation_request/{uuid_customer}', params=params,\n            **kwargs)\n        return response\n\n    def customers_relation_request_verify_create(self,\n        verification_code: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Verify Relation Request\n\n        Args:\n            verification_code (str, required): verification_code\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/customers/relation_request/verify/{verification_code}', **kwargs\n            )\n        return response\n\n    def customers_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_parent (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_parent',\n            'uuid_site', 'uuid_virtual_domain', 'object_profile', 'type',\n            'name', 'description', 'status', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_parent'), params.get('uuid_site'), params.get(\n            'uuid_virtual_domain'), params.get('object_profile'), params.get(\n            'type'), params.get('name'), params.get('description'), params.get(\n            'status'), params.get('skip'), params.get('limit'), params.get(\n            'like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/groups/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_image(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Get Customer Image\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/customers/{uuid}/image',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def customers_image_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Customer Image\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            image (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['image']\n        payload.get('image')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_image_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/customers/{uuid}/image',\n            payload=payload, **kwargs)\n        return response\n\n    def customers_services(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Services\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_services.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/services',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_service_profiles(self, uuid: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Service Profiles\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['not_in']\n        params.get('not_in')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_service_profiles.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/customers/{uuid}/service_profiles', warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def customers_retention_rules(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Retention Rules\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_retention_rules.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/customers/{uuid}/retention_rules', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def customers_sites(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Sites\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_sites.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/sites',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_contacts(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Contacts\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'type', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('type'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_contacts.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/contacts',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_contacts_create(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_contacts_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/{uuid}/contacts/{uuid_contact}', payload=payload,\n            **kwargs)\n        return response\n\n    def customers_contacts_put(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_contacts_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/customers/{uuid}/contacts/{uuid_contact}', payload=payload,\n            **kwargs)\n        return response\n\n    def customers_contacts_delete(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/customers/{uuid}/contacts/{uuid_contact}', **kwargs)\n        return response\n\n    def customers_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_users.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/users',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_users_create(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Add User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/customers/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def customers_users_delete(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Remove User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/customers/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def customers_with_dashboard(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Customers With Dashboard\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            type (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            company_name (string optional): additional filter - parameter\n            address (string optional): additional filter - parameter\n            zip_code (string optional): additional filter - parameter\n            city (string optional): additional filter - parameter\n            country (string optional): additional filter - parameter\n            notes (string optional): additional filter - parameter\n            vat_id (string optional): additional filter - parameter\n            currency (string optional): additional filter - parameter\n            state_province (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            starred (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'type', 'code', 'company_name',\n            'address', 'zip_code', 'city', 'country', 'notes', 'vat_id',\n            'currency', 'state_province', 'status', 'starred', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('type'), params.get('code'\n            ), params.get('company_name'), params.get('address'), params.get(\n            'zip_code'), params.get('city'), params.get('country'), params.get(\n            'notes'), params.get('vat_id'), params.get('currency'), params.get(\n            'state_province'), params.get('status'), params.get('starred'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_with_dashboard.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/customers/with_dashboard/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_by_vat(self, vat_id: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Get Customer By Vat Id\n\n        Args:\n            vat_id (str, required): vat_id\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/customers/by_vat/{vat_id}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def customers_dashboards(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dashboard\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_dashboards.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/dashboards',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_dashboards_create(self, uuid: str, uuid_dashboard: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Create Customer Dashboard Association\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dashboard (str, required): uuid_dashboard\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/customers/{uuid}/dashboards/{uuid_dashboard}', **kwargs)\n        return response\n\n    def customers_dashboards_delete(self, uuid: str, uuid_dashboard: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Customer Dashboard Association\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dashboard (str, required): uuid_dashboard\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/customers/{uuid}/dashboards/{uuid_dashboard}', **kwargs)\n        return response\n\n    def customers_downtimes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_calendar (string optional): additional filter - parameter\n            start (string optional): additional filter - parameter\n            end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            country (string optional): additional filter - parameter\n            state_province (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_calendar', 'start', 'end',\n            'status', 'code', 'description', 'country', 'state_province',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_calendar'), params.get('start'\n            ), params.get('end'), params.get('status'), params.get('code'\n            ), params.get('description'), params.get('country'), params.get(\n            'state_province'), params.get('null_fields'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_downtimes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/customers/{uuid}/downtimes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_notification_provider (string optional): additional filter - parameter\n            uuid_calendar (string optional): additional filter - parameter\n            uuid_message (string optional): additional filter - parameter\n            uuid_opening_reason (string optional): additional filter - parameter\n            uuid_reason_for_closure (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            level (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields',\n            'uuid_notification_provider', 'uuid_calendar', 'uuid_message',\n            'uuid_opening_reason', 'uuid_reason_for_closure', 'code',\n            'description', 'level', 'tag', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_notification_provider'), params.get('uuid_calendar'\n            ), params.get('uuid_message'), params.get('uuid_opening_reason'\n            ), params.get('uuid_reason_for_closure'), params.get('code'\n            ), params.get('description'), params.get('level'), params.get('tag'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/customers/{uuid}/dispatchers', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def customers_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read \n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/customers/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def customers_read_by_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Read By Code\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"code\": \"string\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/customers/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, payload=payload, **kwargs)\n        return response\n\n    def customers_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Customers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"type\": \"string\", optional\n            \"code\": \"string\", required\n            \"company_name\": \"string\", required\n            \"address\": \"string\", required\n            \"zip_code\": \"string\", required\n            \"city\": \"string\", required\n            \"country\": \"string\", required\n            \"notes\": \"string\", optional\n            \"vat_id\": \"string\", optional\n            \"currency\": \"string\", optional\n            \"state_province\": \"string\", optional\n            \"status\": \"string\", required\n            \"profile\": \"string\", optional\n            \"registration_date\": \"string\", optional\n            \"paying_customer\": \"boolean\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/customers/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def customers_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Customers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/customers/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def customers_contacts_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_customer\": \"string\", required\n            \"type\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_contacts_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/customers/bulk/create/contacts', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def customers_contacts_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_customer\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/customers/bulk/delete/contacts', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def customers_users_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_customer\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_users_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/customers/bulk/create/users', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def customers_users_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_customer\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/customers/bulk/delete/users', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def customers_azure_create_v2(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Azure Customer V2\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            customer (None required): additional filter - payload\n            azure_customer (None required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['customer', 'azure_customer']\n        payload.get('customer'), payload.get('azure_customer')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_azure_create_v2.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/customers/azure/v2/',\n            payload=payload, **kwargs)\n        return response\n\n    def customers_azure_subscription_create_v2(self, kwargs: dict = None,\n        **payload) -&gt; list:\n        \"\"\"Create Azure Customer Sub\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            customer (None required): additional filter - payload\n            azure_customer (None required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['customer', 'azure_customer']\n        payload.get('customer'), payload.get('azure_customer')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                customers_azure_subscription_create_v2.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/azure/v2/subscription/', payload=payload, **kwargs)\n        return response\n\n    def customers_azure_create_v2_uuid(self, uuid: str, kwargs: dict = None,\n        **payload) -&gt; list:\n        \"\"\"Create Azure Customer From V2\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            target_company (string required): additional filter - payload\n            target_code (string required): additional filter - payload\n            address (string optional): additional filter - payload\n            zip_code (string optional): additional filter - payload\n            city (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            paying_customer (boolean optional): additional filter - payload\n            base_margin (number required): additional filter - payload\n            reserved_margin (number required): additional filter - payload\n            azure_customer_id (string required): additional filter - payload\n            uuid_virtual_domain (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['target_company', 'target_code', 'address',\n            'zip_code', 'city', 'country', 'state_province',\n            'paying_customer', 'base_margin', 'reserved_margin',\n            'azure_customer_id', 'uuid_virtual_domain']\n        payload.get('target_company'), payload.get('target_code'), payload.get(\n            'address'), payload.get('zip_code'), payload.get('city'\n            ), payload.get('country'), payload.get('state_province'\n            ), payload.get('paying_customer'), payload.get('base_margin'\n            ), payload.get('reserved_margin'), payload.get('azure_customer_id'\n            ), payload.get('uuid_virtual_domain')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_azure_create_v2.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/customers/azure/v2/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def customers_azure_subscription_create_v2_uuid(self, uuid: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Azure Customer From V2 Sub\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            target_company (string required): additional filter - payload\n            target_code (string required): additional filter - payload\n            address (string optional): additional filter - payload\n            zip_code (string optional): additional filter - payload\n            city (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            paying_customer (boolean optional): additional filter - payload\n            uuid_virtual_domain (string optional): additional filter - payload\n            uuid_probe_type (string optional): additional filter - payload\n            uuid_object (string optional): additional filter - payload\n            subscriptions (array required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['target_company', 'target_code', 'address',\n            'zip_code', 'city', 'country', 'state_province',\n            'paying_customer', 'uuid_virtual_domain', 'uuid_probe_type',\n            'uuid_object', 'subscriptions']\n        payload.get('target_company'), payload.get('target_code'), payload.get(\n            'address'), payload.get('zip_code'), payload.get('city'\n            ), payload.get('country'), payload.get('state_province'\n            ), payload.get('paying_customer'), payload.get(\n            'uuid_virtual_domain'), payload.get('uuid_probe_type'\n            ), payload.get('uuid_object'), payload.get('subscriptions')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                customers_azure_subscription_create_v2.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/azure/v2/subscription/{uuid}', payload=payload, **\n            kwargs)\n        return response\n\n    def customers_aws_subscription_create_v2(self, kwargs: dict = None, **\n        payload) -&gt; list:\n        \"\"\"Create Aws Customer Sub\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            customer (None required): additional filter - payload\n            aws_customer (None required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['customer', 'aws_customer']\n        payload.get('customer'), payload.get('aws_customer')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                customers_aws_subscription_create_v2.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/aws/v2/subscription/', payload=payload, **kwargs)\n        return response\n\n    def customers_aws_subscription_create_v2_uuid(self, uuid: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Aws Customer From V2 Sub\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            target_company (string required): additional filter - payload\n            target_code (string required): additional filter - payload\n            address (string optional): additional filter - payload\n            zip_code (string optional): additional filter - payload\n            city (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            paying_customer (boolean optional): additional filter - payload\n            uuid_virtual_domain (string optional): additional filter - payload\n            uuid_probe_type (string optional): additional filter - payload\n            uuid_object (string optional): additional filter - payload\n            subscriptions (array required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['target_company', 'target_code', 'address',\n            'zip_code', 'city', 'country', 'state_province',\n            'paying_customer', 'uuid_virtual_domain', 'uuid_probe_type',\n            'uuid_object', 'subscriptions']\n        payload.get('target_company'), payload.get('target_code'), payload.get(\n            'address'), payload.get('zip_code'), payload.get('city'\n            ), payload.get('country'), payload.get('state_province'\n            ), payload.get('paying_customer'), payload.get(\n            'uuid_virtual_domain'), payload.get('uuid_probe_type'\n            ), payload.get('uuid_object'), payload.get('subscriptions')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                customers_aws_subscription_create_v2.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/aws/v2/subscription/{uuid}', payload=payload, **kwargs\n            )\n        return response\n\n    def customers_gcp_subscription_create_v2(self, kwargs: dict = None, **\n        payload) -&gt; list:\n        \"\"\"Create Gcp Customer Sub\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            customer (None required): additional filter - payload\n            gcp_customer (None required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['customer', 'gcp_customer']\n        payload.get('customer'), payload.get('gcp_customer')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                customers_gcp_subscription_create_v2.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/gcp/v2/subscription/', payload=payload, **kwargs)\n        return response\n\n    def customers_gcp_subscription_create_v2_uuid(self, uuid: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Gcp Customer From V2 Sub\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            target_company (string required): additional filter - payload\n            target_code (string required): additional filter - payload\n            address (string optional): additional filter - payload\n            zip_code (string optional): additional filter - payload\n            city (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            paying_customer (boolean optional): additional filter - payload\n            uuid_virtual_domain (string optional): additional filter - payload\n            uuid_probe_type (string optional): additional filter - payload\n            uuid_object (string optional): additional filter - payload\n            subscriptions (array required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['target_company', 'target_code', 'address',\n            'zip_code', 'city', 'country', 'state_province',\n            'paying_customer', 'uuid_virtual_domain', 'uuid_probe_type',\n            'uuid_object', 'subscriptions']\n        payload.get('target_company'), payload.get('target_code'), payload.get(\n            'address'), payload.get('zip_code'), payload.get('city'\n            ), payload.get('country'), payload.get('state_province'\n            ), payload.get('paying_customer'), payload.get(\n            'uuid_virtual_domain'), payload.get('uuid_probe_type'\n            ), payload.get('uuid_object'), payload.get('subscriptions')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                customers_gcp_subscription_create_v2.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/gcp/v2/subscription/{uuid}', payload=payload, **kwargs\n            )\n        return response\n\n    def customers_networks(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Networks By Customer\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            country (string optional): additional filter - parameter\n            city (string optional): additional filter - parameter\n            address (string optional): additional filter - parameter\n            zip_code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            ip_cidr (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_object',\n            'country', 'city', 'address', 'zip_code', 'status',\n            'description', 'name', 'ip_cidr', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_object'), params.get('country'), params.get('city'\n            ), params.get('address'), params.get('zip_code'), params.get(\n            'status'), params.get('description'), params.get('name'\n            ), params.get('ip_cidr'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_networks.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/customers/networks/{uuid_customer}', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def customers_acknowledged(self, uuid_customer: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Consume Acknowledged Log\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            offset (integer optional): additional filter - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['offset', 'limit']\n        params.get('offset'), params.get('limit')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_acknowledged.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/customers/{uuid_customer}/acknowledged/', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def customers_acknowledged_create(self, uuid_customer: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Produce Acknowledged Message\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid (str required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid']\n        payload.get('uuid')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.customers_acknowledged_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/customers/{uuid_customer}/acknowledged/', payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customer","title":"<code>customer(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customer(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Customer\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/customers/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers","title":"<code>customers(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Customers</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>notes</code> <code>string optional</code> <p>additional filter - parameter</p> <code>vat_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>currency</code> <code>string optional</code> <p>additional filter - parameter</p> <code>state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>registration_date</code> <code>string optional</code> <p>additional filter - parameter</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Customers\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        company_name (string optional): additional filter - parameter\n        address (string optional): additional filter - parameter\n        zip_code (string optional): additional filter - parameter\n        city (string optional): additional filter - parameter\n        country (string optional): additional filter - parameter\n        notes (string optional): additional filter - parameter\n        vat_id (string optional): additional filter - parameter\n        currency (string optional): additional filter - parameter\n        state_province (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        registration_date (string optional): additional filter - parameter\n        paying_customer (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'type', 'code',\n        'company_name', 'address', 'zip_code', 'city', 'country',\n        'notes', 'vat_id', 'currency', 'state_province', 'status',\n        'registration_date', 'paying_customer', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('type'\n        ), params.get('code'), params.get('company_name'), params.get(\n        'address'), params.get('zip_code'), params.get('city'), params.get(\n        'country'), params.get('notes'), params.get('vat_id'), params.get(\n        'currency'), params.get('state_province'), params.get('status'\n        ), params.get('registration_date'), params.get('paying_customer'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/customers/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_acknowledged","title":"<code>customers_acknowledged(uuid_customer, warm_start=False, kwargs=None, **params)</code>","text":"<p>Consume Acknowledged Log</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>offset</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_acknowledged(self, uuid_customer: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Consume Acknowledged Log\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        offset (integer optional): additional filter - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['offset', 'limit']\n    params.get('offset'), params.get('limit')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_acknowledged.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/customers/{uuid_customer}/acknowledged/', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_acknowledged_create","title":"<code>customers_acknowledged_create(uuid_customer, kwargs=None, **payload)</code>","text":"<p>Produce Acknowledged Message</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid</code> <code>str required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_acknowledged_create(self, uuid_customer: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Produce Acknowledged Message\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid (str required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid']\n    payload.get('uuid')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_acknowledged_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/{uuid_customer}/acknowledged/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_aws_subscription_create_v2","title":"<code>customers_aws_subscription_create_v2(kwargs=None, **payload)</code>","text":"<p>Create Aws Customer Sub</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>customer</code> <code>None required</code> <p>additional filter - payload</p> <code>aws_customer</code> <code>None required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_aws_subscription_create_v2(self, kwargs: dict = None, **\n    payload) -&gt; list:\n    \"\"\"Create Aws Customer Sub\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        customer (None required): additional filter - payload\n        aws_customer (None required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['customer', 'aws_customer']\n    payload.get('customer'), payload.get('aws_customer')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            customers_aws_subscription_create_v2.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/aws/v2/subscription/', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_aws_subscription_create_v2_uuid","title":"<code>customers_aws_subscription_create_v2_uuid(uuid, kwargs=None, **payload)</code>","text":"<p>Create Aws Customer From V2 Sub</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>target_company</code> <code>string required</code> <p>additional filter - payload</p> <code>target_code</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string optional</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>city</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_probe_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptions</code> <code>array required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_aws_subscription_create_v2_uuid(self, uuid: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Aws Customer From V2 Sub\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        target_company (string required): additional filter - payload\n        target_code (string required): additional filter - payload\n        address (string optional): additional filter - payload\n        zip_code (string optional): additional filter - payload\n        city (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        paying_customer (boolean optional): additional filter - payload\n        uuid_virtual_domain (string optional): additional filter - payload\n        uuid_probe_type (string optional): additional filter - payload\n        uuid_object (string optional): additional filter - payload\n        subscriptions (array required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['target_company', 'target_code', 'address',\n        'zip_code', 'city', 'country', 'state_province',\n        'paying_customer', 'uuid_virtual_domain', 'uuid_probe_type',\n        'uuid_object', 'subscriptions']\n    payload.get('target_company'), payload.get('target_code'), payload.get(\n        'address'), payload.get('zip_code'), payload.get('city'\n        ), payload.get('country'), payload.get('state_province'\n        ), payload.get('paying_customer'), payload.get(\n        'uuid_virtual_domain'), payload.get('uuid_probe_type'\n        ), payload.get('uuid_object'), payload.get('subscriptions')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            customers_aws_subscription_create_v2.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/aws/v2/subscription/{uuid}', payload=payload, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_azure_create_v2","title":"<code>customers_azure_create_v2(kwargs=None, **payload)</code>","text":"<p>Create Azure Customer V2</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>customer</code> <code>None required</code> <p>additional filter - payload</p> <code>azure_customer</code> <code>None required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_azure_create_v2(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Azure Customer V2\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        customer (None required): additional filter - payload\n        azure_customer (None required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['customer', 'azure_customer']\n    payload.get('customer'), payload.get('azure_customer')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_azure_create_v2.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/customers/azure/v2/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_azure_create_v2_uuid","title":"<code>customers_azure_create_v2_uuid(uuid, kwargs=None, **payload)</code>","text":"<p>Create Azure Customer From V2</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>target_company</code> <code>string required</code> <p>additional filter - payload</p> <code>target_code</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string optional</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>city</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>base_margin</code> <code>number required</code> <p>additional filter - payload</p> <code>reserved_margin</code> <code>number required</code> <p>additional filter - payload</p> <code>azure_customer_id</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_azure_create_v2_uuid(self, uuid: str, kwargs: dict = None,\n    **payload) -&gt; list:\n    \"\"\"Create Azure Customer From V2\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        target_company (string required): additional filter - payload\n        target_code (string required): additional filter - payload\n        address (string optional): additional filter - payload\n        zip_code (string optional): additional filter - payload\n        city (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        paying_customer (boolean optional): additional filter - payload\n        base_margin (number required): additional filter - payload\n        reserved_margin (number required): additional filter - payload\n        azure_customer_id (string required): additional filter - payload\n        uuid_virtual_domain (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['target_company', 'target_code', 'address',\n        'zip_code', 'city', 'country', 'state_province',\n        'paying_customer', 'base_margin', 'reserved_margin',\n        'azure_customer_id', 'uuid_virtual_domain']\n    payload.get('target_company'), payload.get('target_code'), payload.get(\n        'address'), payload.get('zip_code'), payload.get('city'\n        ), payload.get('country'), payload.get('state_province'\n        ), payload.get('paying_customer'), payload.get('base_margin'\n        ), payload.get('reserved_margin'), payload.get('azure_customer_id'\n        ), payload.get('uuid_virtual_domain')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_azure_create_v2.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/customers/azure/v2/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_azure_subscription_create_v2","title":"<code>customers_azure_subscription_create_v2(kwargs=None, **payload)</code>","text":"<p>Create Azure Customer Sub</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>customer</code> <code>None required</code> <p>additional filter - payload</p> <code>azure_customer</code> <code>None required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_azure_subscription_create_v2(self, kwargs: dict = None,\n    **payload) -&gt; list:\n    \"\"\"Create Azure Customer Sub\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        customer (None required): additional filter - payload\n        azure_customer (None required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['customer', 'azure_customer']\n    payload.get('customer'), payload.get('azure_customer')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            customers_azure_subscription_create_v2.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/azure/v2/subscription/', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_azure_subscription_create_v2_uuid","title":"<code>customers_azure_subscription_create_v2_uuid(uuid, kwargs=None, **payload)</code>","text":"<p>Create Azure Customer From V2 Sub</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>target_company</code> <code>string required</code> <p>additional filter - payload</p> <code>target_code</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string optional</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>city</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_probe_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptions</code> <code>array required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_azure_subscription_create_v2_uuid(self, uuid: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Azure Customer From V2 Sub\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        target_company (string required): additional filter - payload\n        target_code (string required): additional filter - payload\n        address (string optional): additional filter - payload\n        zip_code (string optional): additional filter - payload\n        city (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        paying_customer (boolean optional): additional filter - payload\n        uuid_virtual_domain (string optional): additional filter - payload\n        uuid_probe_type (string optional): additional filter - payload\n        uuid_object (string optional): additional filter - payload\n        subscriptions (array required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['target_company', 'target_code', 'address',\n        'zip_code', 'city', 'country', 'state_province',\n        'paying_customer', 'uuid_virtual_domain', 'uuid_probe_type',\n        'uuid_object', 'subscriptions']\n    payload.get('target_company'), payload.get('target_code'), payload.get(\n        'address'), payload.get('zip_code'), payload.get('city'\n        ), payload.get('country'), payload.get('state_province'\n        ), payload.get('paying_customer'), payload.get(\n        'uuid_virtual_domain'), payload.get('uuid_probe_type'\n        ), payload.get('uuid_object'), payload.get('subscriptions')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            customers_azure_subscription_create_v2.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/azure/v2/subscription/{uuid}', payload=payload, **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_bulk","title":"<code>customers_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read </p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read \n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/customers/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_by_vat","title":"<code>customers_by_vat(vat_id, warm_start=False, kwargs=None)</code>","text":"<p>Get Customer By Vat Id</p> <p>Parameters:</p> Name Type Description Default <code>vat_id</code> <code>(str, required)</code> <p>vat_id</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_by_vat(self, vat_id: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Get Customer By Vat Id\n\n    Args:\n        vat_id (str, required): vat_id\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/customers/by_vat/{vat_id}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_contacts","title":"<code>customers_contacts(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Contacts</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_contacts(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Contacts\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'type', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('type'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_contacts.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/contacts',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_contacts_create","title":"<code>customers_contacts_create(uuid, uuid_contact, kwargs=None, **payload)</code>","text":"<p>Add Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_contacts_create(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_contacts_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/{uuid}/contacts/{uuid_contact}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_contacts_create_bulk","title":"<code>customers_contacts_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_customer\": \"string\", required     \"type\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_contacts_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_customer\": \"string\", required\n        \"type\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_contacts_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/customers/bulk/create/contacts', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_contacts_delete","title":"<code>customers_contacts_delete(uuid, uuid_contact, kwargs=None)</code>","text":"<p>Remove Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_contacts_delete(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/customers/{uuid}/contacts/{uuid_contact}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_contacts_delete_bulk","title":"<code>customers_contacts_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_customer\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_contacts_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_customer\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/customers/bulk/delete/contacts', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_contacts_put","title":"<code>customers_contacts_put(uuid, uuid_contact, kwargs=None, **payload)</code>","text":"<p>Update Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_contacts_put(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_contacts_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/customers/{uuid}/contacts/{uuid_contact}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_create","title":"<code>customers_create(kwargs=None, **payload)</code>","text":"<p>Create Customer</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>company_name</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string required</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string required</code> <p>additional filter - payload</p> <code>city</code> <code>string required</code> <p>additional filter - payload</p> <code>country</code> <code>string required</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <code>vat_id</code> <code>string optional</code> <p>additional filter - payload</p> <code>currency</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>registration_date</code> <code>string optional</code> <p>additional filter - payload</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Customer\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string optional): additional filter - payload\n        code (string required): additional filter - payload\n        company_name (string required): additional filter - payload\n        address (string required): additional filter - payload\n        zip_code (string required): additional filter - payload\n        city (string required): additional filter - payload\n        country (string required): additional filter - payload\n        notes (string optional): additional filter - payload\n        vat_id (string optional): additional filter - payload\n        currency (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        status (string required): additional filter - payload\n        profile (string optional): additional filter - payload\n        registration_date (string optional): additional filter - payload\n        paying_customer (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type', 'code', 'company_name', 'address',\n        'zip_code', 'city', 'country', 'notes', 'vat_id', 'currency',\n        'state_province', 'status', 'profile', 'registration_date',\n        'paying_customer']\n    payload.get('type'), payload.get('code'), payload.get('company_name'\n        ), payload.get('address'), payload.get('zip_code'), payload.get(\n        'city'), payload.get('country'), payload.get('notes'), payload.get(\n        'vat_id'), payload.get('currency'), payload.get('state_province'\n        ), payload.get('status'), payload.get('profile'), payload.get(\n        'registration_date'), payload.get('paying_customer')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/customers/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_create_bulk","title":"<code>customers_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Customers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"type\": \"string\", optional     \"code\": \"string\", required     \"company_name\": \"string\", required     \"address\": \"string\", required     \"zip_code\": \"string\", required     \"city\": \"string\", required     \"country\": \"string\", required     \"notes\": \"string\", optional     \"vat_id\": \"string\", optional     \"currency\": \"string\", optional     \"state_province\": \"string\", optional     \"status\": \"string\", required     \"profile\": \"string\", optional     \"registration_date\": \"string\", optional     \"paying_customer\": \"boolean\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Customers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"type\": \"string\", optional\n        \"code\": \"string\", required\n        \"company_name\": \"string\", required\n        \"address\": \"string\", required\n        \"zip_code\": \"string\", required\n        \"city\": \"string\", required\n        \"country\": \"string\", required\n        \"notes\": \"string\", optional\n        \"vat_id\": \"string\", optional\n        \"currency\": \"string\", optional\n        \"state_province\": \"string\", optional\n        \"status\": \"string\", required\n        \"profile\": \"string\", optional\n        \"registration_date\": \"string\", optional\n        \"paying_customer\": \"boolean\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/customers/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_dashboards","title":"<code>customers_dashboards(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_dashboards(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dashboard\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_dashboards.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/dashboards',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_dashboards_create","title":"<code>customers_dashboards_create(uuid, uuid_dashboard, kwargs=None)</code>","text":"<p>Create Customer Dashboard Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dashboard</code> <code>(str, required)</code> <p>uuid_dashboard</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_dashboards_create(self, uuid: str, uuid_dashboard: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Create Customer Dashboard Association\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dashboard (str, required): uuid_dashboard\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/customers/{uuid}/dashboards/{uuid_dashboard}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_dashboards_delete","title":"<code>customers_dashboards_delete(uuid, uuid_dashboard, kwargs=None)</code>","text":"<p>Remove Customer Dashboard Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dashboard</code> <code>(str, required)</code> <p>uuid_dashboard</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_dashboards_delete(self, uuid: str, uuid_dashboard: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Customer Dashboard Association\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dashboard (str, required): uuid_dashboard\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/customers/{uuid}/dashboards/{uuid_dashboard}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_delete","title":"<code>customers_delete(uuid, kwargs=None)</code>","text":"<p>Delete Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Customer\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/customers/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_delete_bulk","title":"<code>customers_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Customers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Customers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/customers/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_dispatchers","title":"<code>customers_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_notification_provider</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_message</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_opening_reason</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_reason_for_closure</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>level</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_notification_provider (string optional): additional filter - parameter\n        uuid_calendar (string optional): additional filter - parameter\n        uuid_message (string optional): additional filter - parameter\n        uuid_opening_reason (string optional): additional filter - parameter\n        uuid_reason_for_closure (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        level (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields',\n        'uuid_notification_provider', 'uuid_calendar', 'uuid_message',\n        'uuid_opening_reason', 'uuid_reason_for_closure', 'code',\n        'description', 'level', 'tag', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_notification_provider'), params.get('uuid_calendar'\n        ), params.get('uuid_message'), params.get('uuid_opening_reason'\n        ), params.get('uuid_reason_for_closure'), params.get('code'\n        ), params.get('description'), params.get('level'), params.get('tag'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/customers/{uuid}/dispatchers', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_downtimes","title":"<code>customers_downtimes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - parameter</p> <code>start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_downtimes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_calendar (string optional): additional filter - parameter\n        start (string optional): additional filter - parameter\n        end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        country (string optional): additional filter - parameter\n        state_province (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_calendar', 'start', 'end',\n        'status', 'code', 'description', 'country', 'state_province',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_calendar'), params.get('start'\n        ), params.get('end'), params.get('status'), params.get('code'\n        ), params.get('description'), params.get('country'), params.get(\n        'state_province'), params.get('null_fields'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_downtimes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/downtimes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_gcp_subscription_create_v2","title":"<code>customers_gcp_subscription_create_v2(kwargs=None, **payload)</code>","text":"<p>Create Gcp Customer Sub</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>customer</code> <code>None required</code> <p>additional filter - payload</p> <code>gcp_customer</code> <code>None required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_gcp_subscription_create_v2(self, kwargs: dict = None, **\n    payload) -&gt; list:\n    \"\"\"Create Gcp Customer Sub\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        customer (None required): additional filter - payload\n        gcp_customer (None required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['customer', 'gcp_customer']\n    payload.get('customer'), payload.get('gcp_customer')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            customers_gcp_subscription_create_v2.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/gcp/v2/subscription/', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_gcp_subscription_create_v2_uuid","title":"<code>customers_gcp_subscription_create_v2_uuid(uuid, kwargs=None, **payload)</code>","text":"<p>Create Gcp Customer From V2 Sub</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>target_company</code> <code>string required</code> <p>additional filter - payload</p> <code>target_code</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string optional</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>city</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_probe_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptions</code> <code>array required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_gcp_subscription_create_v2_uuid(self, uuid: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Gcp Customer From V2 Sub\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        target_company (string required): additional filter - payload\n        target_code (string required): additional filter - payload\n        address (string optional): additional filter - payload\n        zip_code (string optional): additional filter - payload\n        city (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        paying_customer (boolean optional): additional filter - payload\n        uuid_virtual_domain (string optional): additional filter - payload\n        uuid_probe_type (string optional): additional filter - payload\n        uuid_object (string optional): additional filter - payload\n        subscriptions (array required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['target_company', 'target_code', 'address',\n        'zip_code', 'city', 'country', 'state_province',\n        'paying_customer', 'uuid_virtual_domain', 'uuid_probe_type',\n        'uuid_object', 'subscriptions']\n    payload.get('target_company'), payload.get('target_code'), payload.get(\n        'address'), payload.get('zip_code'), payload.get('city'\n        ), payload.get('country'), payload.get('state_province'\n        ), payload.get('paying_customer'), payload.get(\n        'uuid_virtual_domain'), payload.get('uuid_probe_type'\n        ), payload.get('uuid_object'), payload.get('subscriptions')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            customers_gcp_subscription_create_v2.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/customers/gcp/v2/subscription/{uuid}', payload=payload, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_groups","title":"<code>customers_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_parent (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_parent',\n        'uuid_site', 'uuid_virtual_domain', 'object_profile', 'type',\n        'name', 'description', 'status', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_parent'), params.get('uuid_site'), params.get(\n        'uuid_virtual_domain'), params.get('object_profile'), params.get(\n        'type'), params.get('name'), params.get('description'), params.get(\n        'status'), params.get('skip'), params.get('limit'), params.get(\n        'like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/groups/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_image","title":"<code>customers_image(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Get Customer Image</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_image(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Get Customer Image\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/customers/{uuid}/image',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_image_put","title":"<code>customers_image_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Customer Image</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>image</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_image_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Customer Image\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        image (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['image']\n    payload.get('image')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_image_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/customers/{uuid}/image',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_networks","title":"<code>customers_networks(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Networks By Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ip_cidr</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_networks(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Networks By Customer\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        country (string optional): additional filter - parameter\n        city (string optional): additional filter - parameter\n        address (string optional): additional filter - parameter\n        zip_code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        ip_cidr (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_object',\n        'country', 'city', 'address', 'zip_code', 'status',\n        'description', 'name', 'ip_cidr', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_object'), params.get('country'), params.get('city'\n        ), params.get('address'), params.get('zip_code'), params.get(\n        'status'), params.get('description'), params.get('name'\n        ), params.get('ip_cidr'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_networks.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/customers/networks/{uuid_customer}', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_put","title":"<code>customers_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>company_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>address</code> <code>string optional</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>city</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <code>vat_id</code> <code>string optional</code> <p>additional filter - payload</p> <code>currency</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>registration_date</code> <code>string optional</code> <p>additional filter - payload</p> <code>paying_customer</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Customer\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string optional): additional filter - payload\n        code (string optional): additional filter - payload\n        company_name (string optional): additional filter - payload\n        address (string optional): additional filter - payload\n        zip_code (string optional): additional filter - payload\n        city (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        notes (string optional): additional filter - payload\n        vat_id (string optional): additional filter - payload\n        currency (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        status (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        registration_date (string optional): additional filter - payload\n        paying_customer (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type', 'code', 'company_name', 'address',\n        'zip_code', 'city', 'country', 'notes', 'vat_id', 'currency',\n        'state_province', 'status', 'profile', 'registration_date',\n        'paying_customer']\n    payload.get('type'), payload.get('code'), payload.get('company_name'\n        ), payload.get('address'), payload.get('zip_code'), payload.get(\n        'city'), payload.get('country'), payload.get('notes'), payload.get(\n        'vat_id'), payload.get('currency'), payload.get('state_province'\n        ), payload.get('status'), payload.get('profile'), payload.get(\n        'registration_date'), payload.get('paying_customer')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/customers/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_read_by_bulk","title":"<code>customers_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Read By Code</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"code\": \"string\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_read_by_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Read By Code\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"code\": \"string\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/customers/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_register_create","title":"<code>customers_register_create(params=False, kwargs=None, **payload)</code>","text":"<p>Registration Form</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>vat_id</code> <code>string required</code> <p>additional filter - payload</p> <code>company_name</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string required</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string required</code> <p>additional filter - payload</p> <code>city</code> <code>string required</code> <p>additional filter - payload</p> <code>country</code> <code>string required</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>currency</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_register_create(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Registration Form\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        app_id (string optional): additional filter - parameter\n        vat_id (string required): additional filter - payload\n        company_name (string required): additional filter - payload\n        address (string required): additional filter - payload\n        zip_code (string required): additional filter - payload\n        city (string required): additional filter - payload\n        country (string required): additional filter - payload\n        state_province (string optional): additional filter - payload\n        currency (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['vat_id', 'company_name', 'address',\n        'zip_code', 'city', 'country', 'state_province', 'currency']\n    payload.get('vat_id'), payload.get('company_name'), payload.get(\n        'address'), payload.get('zip_code'), payload.get('city'\n        ), payload.get('country'), payload.get('state_province'\n        ), payload.get('currency')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_register_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/customers/register/',\n        params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_relation_request_create","title":"<code>customers_relation_request_create(uuid_customer, kwargs=None, **params)</code>","text":"<p>Create Relation Request</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>refresh</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_relation_request_create(self, uuid_customer: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Create Relation Request\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        app_id (string optional): additional filter - parameter\n        refresh (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['app_id', 'refresh']\n    params.get('app_id'), params.get('refresh')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_relation_request_create\n            .__name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/customers/relation_request/{uuid_customer}', params=params,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_relation_request_verify_create","title":"<code>customers_relation_request_verify_create(verification_code, kwargs=None)</code>","text":"<p>Verify Relation Request</p> <p>Parameters:</p> Name Type Description Default <code>verification_code</code> <code>(str, required)</code> <p>verification_code</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_relation_request_verify_create(self,\n    verification_code: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Verify Relation Request\n\n    Args:\n        verification_code (str, required): verification_code\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/customers/relation_request/verify/{verification_code}', **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_retention_rules","title":"<code>customers_retention_rules(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Retention Rules</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_retention_rules(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Retention Rules\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_retention_rules.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/customers/{uuid}/retention_rules', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_service_profiles","title":"<code>customers_service_profiles(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>List Service Profiles</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_service_profiles(self, uuid: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Service Profiles\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['not_in']\n    params.get('not_in')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_service_profiles.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/customers/{uuid}/service_profiles', warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_services","title":"<code>customers_services(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Services</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_services(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Services\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_services.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/services',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_sites","title":"<code>customers_sites(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Sites</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_sites(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Sites\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_sites.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/sites',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_users","title":"<code>customers_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_users.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/customers/{uuid}/users',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_users_create","title":"<code>customers_users_create(uuid, name, kwargs=None)</code>","text":"<p>Add User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_users_create(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Add User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/customers/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_users_create_bulk","title":"<code>customers_users_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_customer\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_users_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_customer\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_users_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/customers/bulk/create/users', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_users_delete","title":"<code>customers_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Remove User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_users_delete(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Remove User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/customers/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_users_delete_bulk","title":"<code>customers_users_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_customer\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_users_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_customer\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/customers/bulk/delete/users', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.customers/#hive.cookbook.customers.Customers.customers_with_dashboard","title":"<code>customers_with_dashboard(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Customers With Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>notes</code> <code>string optional</code> <p>additional filter - parameter</p> <code>vat_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>currency</code> <code>string optional</code> <p>additional filter - parameter</p> <code>state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>starred</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/customers.py</code> <pre><code>def customers_with_dashboard(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Customers With Dashboard\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        type (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        company_name (string optional): additional filter - parameter\n        address (string optional): additional filter - parameter\n        zip_code (string optional): additional filter - parameter\n        city (string optional): additional filter - parameter\n        country (string optional): additional filter - parameter\n        notes (string optional): additional filter - parameter\n        vat_id (string optional): additional filter - parameter\n        currency (string optional): additional filter - parameter\n        state_province (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        starred (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'type', 'code', 'company_name',\n        'address', 'zip_code', 'city', 'country', 'notes', 'vat_id',\n        'currency', 'state_province', 'status', 'starred', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('type'), params.get('code'\n        ), params.get('company_name'), params.get('address'), params.get(\n        'zip_code'), params.get('city'), params.get('country'), params.get(\n        'notes'), params.get('vat_id'), params.get('currency'), params.get(\n        'state_province'), params.get('status'), params.get('starred'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.customers_with_dashboard.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/customers/with_dashboard/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/","title":"Hive.cookbook.dashboards","text":""},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards","title":"<code>Dashboards</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata dashboards APIs</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>class Dashboards(ApiManager):\n    \"\"\"Class that handles all the XAutomata dashboards APIs\"\"\"\n\n    def dashboards(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Dashboards\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            username (string optional): additional filter - parameter\n            priority (integer optional): additional filter - parameter\n            refresh_interval (integer optional): additional filter - parameter\n            scope (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'name',\n            'description', 'type', 'username', 'priority',\n            'refresh_interval', 'scope', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('name'\n            ), params.get('description'), params.get('type'), params.get(\n            'username'), params.get('priority'), params.get('refresh_interval'\n            ), params.get('scope'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/dashboards/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def dashboards_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Dashboard\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string required): additional filter - payload\n            type (string optional): additional filter - payload\n            username (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            priority (integer optional): additional filter - payload\n            refresh_interval (integer optional): additional filter - payload\n            image_name (string optional): additional filter - payload\n            scope (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'type', 'username', 'description',\n            'priority', 'refresh_interval', 'image_name', 'scope']\n        payload.get('name'), payload.get('type'), payload.get('username'\n            ), payload.get('description'), payload.get('priority'\n            ), payload.get('refresh_interval'), payload.get('image_name'\n            ), payload.get('scope')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/dashboards/', payload=\n            payload, **kwargs)\n        return response\n\n    def dashboard(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Dashboard\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboard.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/dashboards/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def dashboards_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Dashboard\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string optional): additional filter - payload\n            type (string optional): additional filter - payload\n            username (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            priority (integer optional): additional filter - payload\n            refresh_interval (integer optional): additional filter - payload\n            image_name (string optional): additional filter - payload\n            scope (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'type', 'username', 'description',\n            'priority', 'refresh_interval', 'image_name', 'scope']\n        payload.get('name'), payload.get('type'), payload.get('username'\n            ), payload.get('description'), payload.get('priority'\n            ), payload.get('refresh_interval'), payload.get('image_name'\n            ), payload.get('scope')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/dashboards/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def dashboards_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Dashboard\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/dashboards/{uuid}', **kwargs)\n        return response\n\n    def dashboards_image(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Get Dashboard Image\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/dashboards/{uuid}/image',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def dashboards_image_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Dashboard Image\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            image (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['image']\n        payload.get('image')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_image_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/dashboards/{uuid}/image',\n            payload=payload, **kwargs)\n        return response\n\n    def dashboards_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_users.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/dashboards/{uuid}/users',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dashboards_users_create(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Add User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dashboards/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def dashboards_users_delete(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Remove User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dashboards/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def dashboards_widgets(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Widgets\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            index (integer optional): additional filter - parameter\n            width (integer optional): additional filter - parameter\n            height (integer optional): additional filter - parameter\n            grid_x (integer optional): additional filter - parameter\n            grid_y (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'index', 'width',\n            'height', 'grid_x', 'grid_y', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('name'), params.get('index'\n            ), params.get('width'), params.get('height'), params.get('grid_x'\n            ), params.get('grid_y'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_widgets.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dashboards/{uuid}/widgets',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dashboards_widgets_create(self, uuid: str, uuid_widget: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Widget\n\n        Args:\n            uuid (str, required): uuid\n            uuid_widget (str, required): uuid_widget\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            index (integer optional): additional filter - payload\n            width (integer optional): additional filter - payload\n            height (integer optional): additional filter - payload\n            grid_x (integer optional): additional filter - payload\n            grid_y (integer optional): additional filter - payload\n            settings (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['index', 'width', 'height', 'grid_x',\n            'grid_y', 'settings']\n        payload.get('index'), payload.get('width'), payload.get('height'\n            ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n            'settings')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_widgets_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/dashboards/{uuid}/widgets/{uuid_widget}', payload=payload,\n            **kwargs)\n        return response\n\n    def dashboards_dashboard_widget_put(self, uuid: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Dashboard Widget Association\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            index (integer optional): additional filter - payload\n            width (integer optional): additional filter - payload\n            height (integer optional): additional filter - payload\n            grid_x (integer optional): additional filter - payload\n            grid_y (integer optional): additional filter - payload\n            settings (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['index', 'width', 'height', 'grid_x',\n            'grid_y', 'settings']\n        payload.get('index'), payload.get('width'), payload.get('height'\n            ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n            'settings')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_dashboard_widget_put.\n                __name__, payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/dashboards/dashboard_widget/{uuid}', payload=payload, **kwargs)\n        return response\n\n    def dashboards_dashboard_widget_delete(self, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Remove Dashboard Widget Association\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dashboards/dashboard_widget/{uuid}', **kwargs)\n        return response\n\n    def dashboards_customers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dashboard\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            company_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'company_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('company_name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_customers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dashboards/{uuid}/customers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dashboards_customers_create(self, uuid: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Create Customer Dashboard Association\n\n        Args:\n            uuid (str, required): uuid\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dashboards/{uuid}/customers/{uuid_customer}', **kwargs)\n        return response\n\n    def dashboards_customers_delete(self, uuid: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Customer Dashboard Association\n\n        Args:\n            uuid (str, required): uuid\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dashboards/{uuid}/customers/{uuid_customer}', **kwargs)\n        return response\n\n    def dashboards_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Widgets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/dashboards/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def dashboards_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Dashboards\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"name\": \"string\", required\n            \"type\": \"string\", optional\n            \"username\": \"string\", optional\n            \"description\": \"string\", optional\n            \"priority\": \"integer\", optional\n            \"refresh_interval\": \"integer\", optional\n            \"image_name\": \"string\", optional\n            \"scope\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/dashboards/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def dashboards_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Dashboards\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/dashboards/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def dashboards_users_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_dashboard\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_users_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dashboards/bulk/create/users', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dashboards_users_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_dashboard\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dashboards/bulk/delete/users', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def dashboards_widgets_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Widgets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"index\": \"integer\", optional\n            \"width\": \"integer\", optional\n            \"height\": \"integer\", optional\n            \"grid_x\": \"integer\", optional\n            \"grid_y\": \"integer\", optional\n            \"settings\": \"array object\", optional\n            \"uuid_dashboard\": \"string\", required\n            \"uuid_widget\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dashboards_widgets_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dashboards/bulk/create/widgets', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dashboards_widgets_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Widgets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dashboards/bulk/delete/widgets', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboard","title":"<code>dashboard(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboard(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Dashboard\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboard.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/dashboards/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards","title":"<code>dashboards(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>username</code> <code>string optional</code> <p>additional filter - parameter</p> <code>priority</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>refresh_interval</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>scope</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Dashboards\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        username (string optional): additional filter - parameter\n        priority (integer optional): additional filter - parameter\n        refresh_interval (integer optional): additional filter - parameter\n        scope (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'name',\n        'description', 'type', 'username', 'priority',\n        'refresh_interval', 'scope', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('name'\n        ), params.get('description'), params.get('type'), params.get(\n        'username'), params.get('priority'), params.get('refresh_interval'\n        ), params.get('scope'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/dashboards/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_bulk","title":"<code>dashboards_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Widgets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Widgets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/dashboards/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_create","title":"<code>dashboards_create(kwargs=None, **payload)</code>","text":"<p>Create Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>username</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>priority</code> <code>integer optional</code> <p>additional filter - payload</p> <code>refresh_interval</code> <code>integer optional</code> <p>additional filter - payload</p> <code>image_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>scope</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Dashboard\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string required): additional filter - payload\n        type (string optional): additional filter - payload\n        username (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        priority (integer optional): additional filter - payload\n        refresh_interval (integer optional): additional filter - payload\n        image_name (string optional): additional filter - payload\n        scope (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'type', 'username', 'description',\n        'priority', 'refresh_interval', 'image_name', 'scope']\n    payload.get('name'), payload.get('type'), payload.get('username'\n        ), payload.get('description'), payload.get('priority'\n        ), payload.get('refresh_interval'), payload.get('image_name'\n        ), payload.get('scope')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/dashboards/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_create_bulk","title":"<code>dashboards_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"name\": \"string\", required     \"type\": \"string\", optional     \"username\": \"string\", optional     \"description\": \"string\", optional     \"priority\": \"integer\", optional     \"refresh_interval\": \"integer\", optional     \"image_name\": \"string\", optional     \"scope\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Dashboards\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"name\": \"string\", required\n        \"type\": \"string\", optional\n        \"username\": \"string\", optional\n        \"description\": \"string\", optional\n        \"priority\": \"integer\", optional\n        \"refresh_interval\": \"integer\", optional\n        \"image_name\": \"string\", optional\n        \"scope\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/dashboards/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_customers","title":"<code>dashboards_customers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_customers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dashboard\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        company_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'company_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('company_name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_customers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dashboards/{uuid}/customers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_customers_create","title":"<code>dashboards_customers_create(uuid, uuid_customer, kwargs=None)</code>","text":"<p>Create Customer Dashboard Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_customers_create(self, uuid: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Create Customer Dashboard Association\n\n    Args:\n        uuid (str, required): uuid\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dashboards/{uuid}/customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_customers_delete","title":"<code>dashboards_customers_delete(uuid, uuid_customer, kwargs=None)</code>","text":"<p>Remove Customer Dashboard Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_customers_delete(self, uuid: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Customer Dashboard Association\n\n    Args:\n        uuid (str, required): uuid\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dashboards/{uuid}/customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_dashboard_widget_delete","title":"<code>dashboards_dashboard_widget_delete(uuid, kwargs=None)</code>","text":"<p>Remove Dashboard Widget Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_dashboard_widget_delete(self, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Remove Dashboard Widget Association\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dashboards/dashboard_widget/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_dashboard_widget_put","title":"<code>dashboards_dashboard_widget_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Dashboard Widget Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>index</code> <code>integer optional</code> <p>additional filter - payload</p> <code>width</code> <code>integer optional</code> <p>additional filter - payload</p> <code>height</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_x</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_y</code> <code>integer optional</code> <p>additional filter - payload</p> <code>settings</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_dashboard_widget_put(self, uuid: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Dashboard Widget Association\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        index (integer optional): additional filter - payload\n        width (integer optional): additional filter - payload\n        height (integer optional): additional filter - payload\n        grid_x (integer optional): additional filter - payload\n        grid_y (integer optional): additional filter - payload\n        settings (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['index', 'width', 'height', 'grid_x',\n        'grid_y', 'settings']\n    payload.get('index'), payload.get('width'), payload.get('height'\n        ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n        'settings')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_dashboard_widget_put.\n            __name__, payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/dashboards/dashboard_widget/{uuid}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_delete","title":"<code>dashboards_delete(uuid, kwargs=None)</code>","text":"<p>Delete Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Dashboard\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/dashboards/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_delete_bulk","title":"<code>dashboards_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Dashboards\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/dashboards/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_image","title":"<code>dashboards_image(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Get Dashboard Image</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_image(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Get Dashboard Image\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/dashboards/{uuid}/image',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_image_put","title":"<code>dashboards_image_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Dashboard Image</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>image</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_image_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Dashboard Image\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        image (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['image']\n    payload.get('image')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_image_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/dashboards/{uuid}/image',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_put","title":"<code>dashboards_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>username</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>priority</code> <code>integer optional</code> <p>additional filter - payload</p> <code>refresh_interval</code> <code>integer optional</code> <p>additional filter - payload</p> <code>image_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>scope</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Dashboard\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string optional): additional filter - payload\n        type (string optional): additional filter - payload\n        username (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        priority (integer optional): additional filter - payload\n        refresh_interval (integer optional): additional filter - payload\n        image_name (string optional): additional filter - payload\n        scope (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'type', 'username', 'description',\n        'priority', 'refresh_interval', 'image_name', 'scope']\n    payload.get('name'), payload.get('type'), payload.get('username'\n        ), payload.get('description'), payload.get('priority'\n        ), payload.get('refresh_interval'), payload.get('image_name'\n        ), payload.get('scope')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/dashboards/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_users","title":"<code>dashboards_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_users.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/dashboards/{uuid}/users',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_users_create","title":"<code>dashboards_users_create(uuid, name, kwargs=None)</code>","text":"<p>Add User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_users_create(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Add User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dashboards/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_users_create_bulk","title":"<code>dashboards_users_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_dashboard\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_users_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_dashboard\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_users_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dashboards/bulk/create/users', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_users_delete","title":"<code>dashboards_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Remove User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_users_delete(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Remove User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dashboards/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_users_delete_bulk","title":"<code>dashboards_users_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_dashboard\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_users_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_dashboard\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dashboards/bulk/delete/users', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_widgets","title":"<code>dashboards_widgets(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Widgets</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>index</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>width</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>height</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>grid_x</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>grid_y</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_widgets(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Widgets\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        index (integer optional): additional filter - parameter\n        width (integer optional): additional filter - parameter\n        height (integer optional): additional filter - parameter\n        grid_x (integer optional): additional filter - parameter\n        grid_y (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'index', 'width',\n        'height', 'grid_x', 'grid_y', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('name'), params.get('index'\n        ), params.get('width'), params.get('height'), params.get('grid_x'\n        ), params.get('grid_y'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_widgets.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dashboards/{uuid}/widgets',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_widgets_create","title":"<code>dashboards_widgets_create(uuid, uuid_widget, kwargs=None, **payload)</code>","text":"<p>Add Widget</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_widget</code> <code>(str, required)</code> <p>uuid_widget</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>index</code> <code>integer optional</code> <p>additional filter - payload</p> <code>width</code> <code>integer optional</code> <p>additional filter - payload</p> <code>height</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_x</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_y</code> <code>integer optional</code> <p>additional filter - payload</p> <code>settings</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_widgets_create(self, uuid: str, uuid_widget: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Widget\n\n    Args:\n        uuid (str, required): uuid\n        uuid_widget (str, required): uuid_widget\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        index (integer optional): additional filter - payload\n        width (integer optional): additional filter - payload\n        height (integer optional): additional filter - payload\n        grid_x (integer optional): additional filter - payload\n        grid_y (integer optional): additional filter - payload\n        settings (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['index', 'width', 'height', 'grid_x',\n        'grid_y', 'settings']\n    payload.get('index'), payload.get('width'), payload.get('height'\n        ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n        'settings')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_widgets_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/dashboards/{uuid}/widgets/{uuid_widget}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_widgets_create_bulk","title":"<code>dashboards_widgets_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Widgets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"index\": \"integer\", optional     \"width\": \"integer\", optional     \"height\": \"integer\", optional     \"grid_x\": \"integer\", optional     \"grid_y\": \"integer\", optional     \"settings\": \"array object\", optional     \"uuid_dashboard\": \"string\", required     \"uuid_widget\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_widgets_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Widgets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"index\": \"integer\", optional\n        \"width\": \"integer\", optional\n        \"height\": \"integer\", optional\n        \"grid_x\": \"integer\", optional\n        \"grid_y\": \"integer\", optional\n        \"settings\": \"array object\", optional\n        \"uuid_dashboard\": \"string\", required\n        \"uuid_widget\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dashboards_widgets_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dashboards/bulk/create/widgets', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dashboards/#hive.cookbook.dashboards.Dashboards.dashboards_widgets_delete_bulk","title":"<code>dashboards_widgets_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Widgets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dashboards.py</code> <pre><code>def dashboards_widgets_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Widgets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dashboards/bulk/delete/widgets', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/","title":"Hive.cookbook.dispatchers","text":""},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers","title":"<code>Dispatchers</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata dispatchers APIs</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>class Dispatchers(ApiManager):\n    \"\"\"Class that handles all the XAutomata dispatchers APIs\"\"\"\n\n    def dispatchers(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Dispatchers\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_notification_provider (string optional): additional filter - parameter\n            uuid_calendar (string optional): additional filter - parameter\n            uuid_message (string optional): additional filter - parameter\n            uuid_opening_reason (string optional): additional filter - parameter\n            uuid_reason_for_closure (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            level (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields',\n            'uuid_notification_provider', 'uuid_calendar', 'uuid_message',\n            'uuid_opening_reason', 'uuid_reason_for_closure', 'code',\n            'description', 'level', 'status', 'tag', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_notification_provider'), params.get('uuid_calendar'\n            ), params.get('uuid_message'), params.get('uuid_opening_reason'\n            ), params.get('uuid_reason_for_closure'), params.get('code'\n            ), params.get('description'), params.get('level'), params.get(\n            'status'), params.get('tag'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def dispatchers_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Dispatcher\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_notification_provider (string optional): additional filter - payload\n            uuid_calendar (string required): additional filter - payload\n            uuid_message (string required): additional filter - payload\n            uuid_opening_reason (string optional): additional filter - payload\n            uuid_reason_for_closure (string optional): additional filter - payload\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            delay (integer optional): additional filter - payload\n            status (string required): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            remember_it (boolean optional): additional filter - payload\n            tag (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_notification_provider',\n            'uuid_calendar', 'uuid_message', 'uuid_opening_reason',\n            'uuid_reason_for_closure', 'code', 'description', 'delay',\n            'status', 'country', 'state_province', 'data_profile',\n            'remember_it', 'tag']\n        payload.get('uuid_notification_provider'), payload.get('uuid_calendar'\n            ), payload.get('uuid_message'), payload.get('uuid_opening_reason'\n            ), payload.get('uuid_reason_for_closure'), payload.get('code'\n            ), payload.get('description'), payload.get('delay'), payload.get(\n            'status'), payload.get('country'), payload.get('state_province'\n            ), payload.get('data_profile'), payload.get('remember_it'\n            ), payload.get('tag')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/dispatchers/', payload=\n            payload, **kwargs)\n        return response\n\n    def dispatcher(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatcher.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def dispatchers_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_notification_provider (string optional): additional filter - payload\n            uuid_calendar (string optional): additional filter - payload\n            uuid_message (string optional): additional filter - payload\n            uuid_opening_reason (string optional): additional filter - payload\n            uuid_reason_for_closure (string optional): additional filter - payload\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            delay (integer optional): additional filter - payload\n            status (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            remember_it (boolean optional): additional filter - payload\n            tag (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_notification_provider',\n            'uuid_calendar', 'uuid_message', 'uuid_opening_reason',\n            'uuid_reason_for_closure', 'code', 'description', 'delay',\n            'status', 'country', 'state_province', 'data_profile',\n            'remember_it', 'tag']\n        payload.get('uuid_notification_provider'), payload.get('uuid_calendar'\n            ), payload.get('uuid_message'), payload.get('uuid_opening_reason'\n            ), payload.get('uuid_reason_for_closure'), payload.get('code'\n            ), payload.get('description'), payload.get('delay'), payload.get(\n            'status'), payload.get('country'), payload.get('state_province'\n            ), payload.get('data_profile'), payload.get('remember_it'\n            ), payload.get('tag')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/dispatchers/{uuid}', payload\n            =payload, **kwargs)\n        return response\n\n    def dispatchers_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/dispatchers/{uuid}', **kwargs\n            )\n        return response\n\n    def dispatchers_contacts(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Contacts\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            send_email (boolean optional): additional filter - parameter\n            role_email (string optional): additional filter - parameter\n            send_sms (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'send_email',\n            'role_email', 'send_sms', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('send_email'\n            ), params.get('role_email'), params.get('send_sms'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_contacts.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/{uuid}/contacts',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dispatchers_contacts_create(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            send_email (boolean required): additional filter - payload\n            role_email ( optional): additional filter - payload\n            send_sms (boolean required): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['send_email', 'role_email', 'send_sms',\n            'endpoint']\n        payload.get('send_email'), payload.get('role_email'), payload.get(\n            'send_sms'), payload.get('endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_contacts_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/{uuid}/contacts/{uuid_contact}', payload=payload,\n            **kwargs)\n        return response\n\n    def dispatchers_contacts_put(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            send_email (boolean optional): additional filter - payload\n            role_email ( optional): additional filter - payload\n            send_sms (boolean optional): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['send_email', 'role_email', 'send_sms',\n            'endpoint']\n        payload.get('send_email'), payload.get('role_email'), payload.get(\n            'send_sms'), payload.get('endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_contacts_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/dispatchers/{uuid}/contacts/{uuid_contact}', payload=payload,\n            **kwargs)\n        return response\n\n    def dispatchers_contacts_delete(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dispatchers/{uuid}/contacts/{uuid_contact}', **kwargs)\n        return response\n\n    def dispatchers_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_groups.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/{uuid}/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dispatchers_groups_create(self, uuid: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/{uuid}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def dispatchers_groups_delete(self, uuid: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dispatchers/{uuid}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def dispatchers_objects(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Objects\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_objects.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/{uuid}/objects',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dispatchers_objects_create(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def dispatchers_objects_delete(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dispatchers/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def dispatchers_metrics(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metrics\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_metrics.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/{uuid}/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dispatchers_metrics_create(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def dispatchers_metrics_delete(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dispatchers/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def dispatchers_metric_types(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metric Types\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_metric_types.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/dispatchers/{uuid}/metric_types', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def dispatchers_metric_types_create(self, uuid: str,\n        uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric_type (str, required): uuid_metric_type\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n        return response\n\n    def dispatchers_metric_types_delete(self, uuid: str,\n        uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric_type (str, required): uuid_metric_type\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dispatchers/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n        return response\n\n    def dispatchers_services(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Services\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_services.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/dispatchers/{uuid}/services',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def dispatchers_services_create(self, uuid: str, uuid_service: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Service\n\n        Args:\n            uuid (str, required): uuid\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/{uuid}/services/{uuid_service}', **kwargs)\n        return response\n\n    def dispatchers_services_delete(self, uuid: str, uuid_service: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Service\n\n        Args:\n            uuid (str, required): uuid\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/dispatchers/{uuid}/services/{uuid_service}', **kwargs)\n        return response\n\n    def dispatchers_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read \n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/dispatchers/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Dispatchers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_notification_provider\": \"string\", optional\n            \"uuid_calendar\": \"string\", required\n            \"uuid_message\": \"string\", required\n            \"uuid_opening_reason\": \"string\", optional\n            \"uuid_reason_for_closure\": \"string\", optional\n            \"code\": \"string\", required\n            \"description\": \"string\", optional\n            \"delay\": \"integer\", optional\n            \"status\": \"string\", required\n            \"country\": \"string\", optional\n            \"state_province\": \"string\", optional\n            \"data_profile\": \"array object\", optional\n            \"remember_it\": \"boolean\", optional\n            \"tag\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/dispatchers/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def dispatchers_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Dispatchers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/dispatchers/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def dispatchers_contacts_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_dispatcher\": \"string\", required\n            \"send_email\": \"boolean\", optional\n            \"role_email\": \"\", optional\n            \"send_sms\": \"boolean\", optional\n            \"endpoint\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_contacts_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/create/contacts', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_contacts_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_dispatcher\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/delete/contacts', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_groups_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Groups Dispatchers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_groups_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/read/groups', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def dispatchers_groups_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_groups_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/create/groups', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_groups_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/delete/groups', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_objects_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Objects Dispatchers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_objects_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/read/objects', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def dispatchers_objects_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_objects_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/create/objects', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_objects_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/delete/objects', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_metric_types_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                dispatchers_metric_types_create_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/create/metric_types', single_page=\n            single_page, page_size=page_size, params=params, payload=\n            payload, **kwargs)\n        return response\n\n    def dispatchers_metric_types_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/delete/metric_types', single_page=\n            single_page, page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_metrics_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_metrics_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/create/metrics', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_metrics_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/delete/metrics', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_services_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.dispatchers_services_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/create/services', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def dispatchers_services_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_dispatcher\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/dispatchers/bulk/delete/services', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatcher","title":"<code>dispatcher(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatcher(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatcher.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers","title":"<code>dispatchers(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_notification_provider</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_message</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_opening_reason</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_reason_for_closure</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>level</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Dispatchers\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_notification_provider (string optional): additional filter - parameter\n        uuid_calendar (string optional): additional filter - parameter\n        uuid_message (string optional): additional filter - parameter\n        uuid_opening_reason (string optional): additional filter - parameter\n        uuid_reason_for_closure (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        level (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields',\n        'uuid_notification_provider', 'uuid_calendar', 'uuid_message',\n        'uuid_opening_reason', 'uuid_reason_for_closure', 'code',\n        'description', 'level', 'status', 'tag', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_notification_provider'), params.get('uuid_calendar'\n        ), params.get('uuid_message'), params.get('uuid_opening_reason'\n        ), params.get('uuid_reason_for_closure'), params.get('code'\n        ), params.get('description'), params.get('level'), params.get(\n        'status'), params.get('tag'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_bulk","title":"<code>dispatchers_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read </p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read \n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/dispatchers/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_contacts","title":"<code>dispatchers_contacts(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Contacts</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>send_email</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>role_email</code> <code>string optional</code> <p>additional filter - parameter</p> <code>send_sms</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_contacts(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Contacts\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        send_email (boolean optional): additional filter - parameter\n        role_email (string optional): additional filter - parameter\n        send_sms (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'send_email',\n        'role_email', 'send_sms', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('send_email'\n        ), params.get('role_email'), params.get('send_sms'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_contacts.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/{uuid}/contacts',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_contacts_create","title":"<code>dispatchers_contacts_create(uuid, uuid_contact, kwargs=None, **payload)</code>","text":"<p>Add Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>send_email</code> <code>boolean required</code> <p>additional filter - payload</p> <code>role_email</code> <code>optional</code> <p>additional filter - payload</p> <code>send_sms</code> <code>boolean required</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_contacts_create(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        send_email (boolean required): additional filter - payload\n        role_email ( optional): additional filter - payload\n        send_sms (boolean required): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['send_email', 'role_email', 'send_sms',\n        'endpoint']\n    payload.get('send_email'), payload.get('role_email'), payload.get(\n        'send_sms'), payload.get('endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_contacts_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/{uuid}/contacts/{uuid_contact}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_contacts_create_bulk","title":"<code>dispatchers_contacts_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_dispatcher\": \"string\", required     \"send_email\": \"boolean\", optional     \"role_email\": \"\", optional     \"send_sms\": \"boolean\", optional     \"endpoint\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_contacts_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_dispatcher\": \"string\", required\n        \"send_email\": \"boolean\", optional\n        \"role_email\": \"\", optional\n        \"send_sms\": \"boolean\", optional\n        \"endpoint\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_contacts_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/create/contacts', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_contacts_delete","title":"<code>dispatchers_contacts_delete(uuid, uuid_contact, kwargs=None)</code>","text":"<p>Delete Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_contacts_delete(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dispatchers/{uuid}/contacts/{uuid_contact}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_contacts_delete_bulk","title":"<code>dispatchers_contacts_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_dispatcher\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_contacts_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_dispatcher\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/delete/contacts', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_contacts_put","title":"<code>dispatchers_contacts_put(uuid, uuid_contact, kwargs=None, **payload)</code>","text":"<p>Update Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>send_email</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>role_email</code> <code>optional</code> <p>additional filter - payload</p> <code>send_sms</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_contacts_put(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        send_email (boolean optional): additional filter - payload\n        role_email ( optional): additional filter - payload\n        send_sms (boolean optional): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['send_email', 'role_email', 'send_sms',\n        'endpoint']\n    payload.get('send_email'), payload.get('role_email'), payload.get(\n        'send_sms'), payload.get('endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_contacts_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/dispatchers/{uuid}/contacts/{uuid_contact}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_create","title":"<code>dispatchers_create(kwargs=None, **payload)</code>","text":"<p>Create Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_notification_provider</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_calendar</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_message</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_opening_reason</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_reason_for_closure</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>delay</code> <code>integer optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>remember_it</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>tag</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Dispatcher\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_notification_provider (string optional): additional filter - payload\n        uuid_calendar (string required): additional filter - payload\n        uuid_message (string required): additional filter - payload\n        uuid_opening_reason (string optional): additional filter - payload\n        uuid_reason_for_closure (string optional): additional filter - payload\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        delay (integer optional): additional filter - payload\n        status (string required): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        remember_it (boolean optional): additional filter - payload\n        tag (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_notification_provider',\n        'uuid_calendar', 'uuid_message', 'uuid_opening_reason',\n        'uuid_reason_for_closure', 'code', 'description', 'delay',\n        'status', 'country', 'state_province', 'data_profile',\n        'remember_it', 'tag']\n    payload.get('uuid_notification_provider'), payload.get('uuid_calendar'\n        ), payload.get('uuid_message'), payload.get('uuid_opening_reason'\n        ), payload.get('uuid_reason_for_closure'), payload.get('code'\n        ), payload.get('description'), payload.get('delay'), payload.get(\n        'status'), payload.get('country'), payload.get('state_province'\n        ), payload.get('data_profile'), payload.get('remember_it'\n        ), payload.get('tag')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/dispatchers/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_create_bulk","title":"<code>dispatchers_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_notification_provider\": \"string\", optional     \"uuid_calendar\": \"string\", required     \"uuid_message\": \"string\", required     \"uuid_opening_reason\": \"string\", optional     \"uuid_reason_for_closure\": \"string\", optional     \"code\": \"string\", required     \"description\": \"string\", optional     \"delay\": \"integer\", optional     \"status\": \"string\", required     \"country\": \"string\", optional     \"state_province\": \"string\", optional     \"data_profile\": \"array object\", optional     \"remember_it\": \"boolean\", optional     \"tag\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Dispatchers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_notification_provider\": \"string\", optional\n        \"uuid_calendar\": \"string\", required\n        \"uuid_message\": \"string\", required\n        \"uuid_opening_reason\": \"string\", optional\n        \"uuid_reason_for_closure\": \"string\", optional\n        \"code\": \"string\", required\n        \"description\": \"string\", optional\n        \"delay\": \"integer\", optional\n        \"status\": \"string\", required\n        \"country\": \"string\", optional\n        \"state_province\": \"string\", optional\n        \"data_profile\": \"array object\", optional\n        \"remember_it\": \"boolean\", optional\n        \"tag\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/dispatchers/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_delete","title":"<code>dispatchers_delete(uuid, kwargs=None)</code>","text":"<p>Delete Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/dispatchers/{uuid}', **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_delete_bulk","title":"<code>dispatchers_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Dispatchers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/dispatchers/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_groups","title":"<code>dispatchers_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_groups.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/{uuid}/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_groups_bulk","title":"<code>dispatchers_groups_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Groups Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_groups_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Groups Dispatchers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_groups_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/read/groups', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_groups_create","title":"<code>dispatchers_groups_create(uuid, uuid_group, kwargs=None)</code>","text":"<p>Add Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_groups_create(self, uuid: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/{uuid}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_groups_create_bulk","title":"<code>dispatchers_groups_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_groups_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_groups_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/create/groups', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_groups_delete","title":"<code>dispatchers_groups_delete(uuid, uuid_group, kwargs=None)</code>","text":"<p>Remove Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_groups_delete(self, uuid: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dispatchers/{uuid}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_groups_delete_bulk","title":"<code>dispatchers_groups_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_groups_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/delete/groups', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metric_types","title":"<code>dispatchers_metric_types(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metric_types(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metric Types\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_metric_types.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/dispatchers/{uuid}/metric_types', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metric_types_create","title":"<code>dispatchers_metric_types_create(uuid, uuid_metric_type, kwargs=None)</code>","text":"<p>Add Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric_type</code> <code>(str, required)</code> <p>uuid_metric_type</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metric_types_create(self, uuid: str,\n    uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric_type (str, required): uuid_metric_type\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metric_types_create_bulk","title":"<code>dispatchers_metric_types_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metric_types_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            dispatchers_metric_types_create_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/create/metric_types', single_page=\n        single_page, page_size=page_size, params=params, payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metric_types_delete","title":"<code>dispatchers_metric_types_delete(uuid, uuid_metric_type, kwargs=None)</code>","text":"<p>Remove Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric_type</code> <code>(str, required)</code> <p>uuid_metric_type</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metric_types_delete(self, uuid: str,\n    uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric_type (str, required): uuid_metric_type\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dispatchers/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metric_types_delete_bulk","title":"<code>dispatchers_metric_types_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metric_types_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/delete/metric_types', single_page=\n        single_page, page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metrics","title":"<code>dispatchers_metrics(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metrics</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metrics(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metrics\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_metrics.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/{uuid}/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metrics_create","title":"<code>dispatchers_metrics_create(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Add Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metrics_create(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metrics_create_bulk","title":"<code>dispatchers_metrics_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metrics_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_metrics_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/create/metrics', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metrics_delete","title":"<code>dispatchers_metrics_delete(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Remove Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metrics_delete(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dispatchers/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_metrics_delete_bulk","title":"<code>dispatchers_metrics_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_metrics_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/delete/metrics', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_objects","title":"<code>dispatchers_objects(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Objects</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_objects(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Objects\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_objects.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/{uuid}/objects',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_objects_bulk","title":"<code>dispatchers_objects_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Objects Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_objects_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Objects Dispatchers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_objects_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/read/objects', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_objects_create","title":"<code>dispatchers_objects_create(uuid, uuid_object, kwargs=None)</code>","text":"<p>Add Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_objects_create(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_objects_create_bulk","title":"<code>dispatchers_objects_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_objects_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_objects_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/create/objects', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_objects_delete","title":"<code>dispatchers_objects_delete(uuid, uuid_object, kwargs=None)</code>","text":"<p>Remove Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_objects_delete(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dispatchers/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_objects_delete_bulk","title":"<code>dispatchers_objects_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_objects_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/delete/objects', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_put","title":"<code>dispatchers_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_notification_provider</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_message</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_opening_reason</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_reason_for_closure</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>delay</code> <code>integer optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>remember_it</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>tag</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_notification_provider (string optional): additional filter - payload\n        uuid_calendar (string optional): additional filter - payload\n        uuid_message (string optional): additional filter - payload\n        uuid_opening_reason (string optional): additional filter - payload\n        uuid_reason_for_closure (string optional): additional filter - payload\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        delay (integer optional): additional filter - payload\n        status (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        remember_it (boolean optional): additional filter - payload\n        tag (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_notification_provider',\n        'uuid_calendar', 'uuid_message', 'uuid_opening_reason',\n        'uuid_reason_for_closure', 'code', 'description', 'delay',\n        'status', 'country', 'state_province', 'data_profile',\n        'remember_it', 'tag']\n    payload.get('uuid_notification_provider'), payload.get('uuid_calendar'\n        ), payload.get('uuid_message'), payload.get('uuid_opening_reason'\n        ), payload.get('uuid_reason_for_closure'), payload.get('code'\n        ), payload.get('description'), payload.get('delay'), payload.get(\n        'status'), payload.get('country'), payload.get('state_province'\n        ), payload.get('data_profile'), payload.get('remember_it'\n        ), payload.get('tag')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/dispatchers/{uuid}', payload\n        =payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_services","title":"<code>dispatchers_services(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Services</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_services(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Services\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_services.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/dispatchers/{uuid}/services',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_services_create","title":"<code>dispatchers_services_create(uuid, uuid_service, kwargs=None)</code>","text":"<p>Add Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_services_create(self, uuid: str, uuid_service: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Service\n\n    Args:\n        uuid (str, required): uuid\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/{uuid}/services/{uuid_service}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_services_create_bulk","title":"<code>dispatchers_services_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_services_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.dispatchers_services_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/create/services', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_services_delete","title":"<code>dispatchers_services_delete(uuid, uuid_service, kwargs=None)</code>","text":"<p>Remove Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_services_delete(self, uuid: str, uuid_service: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Service\n\n    Args:\n        uuid (str, required): uuid\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/dispatchers/{uuid}/services/{uuid_service}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.dispatchers/#hive.cookbook.dispatchers.Dispatchers.dispatchers_services_delete_bulk","title":"<code>dispatchers_services_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_dispatcher\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/dispatchers.py</code> <pre><code>def dispatchers_services_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_dispatcher\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/dispatchers/bulk/delete/services', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/","title":"Hive.cookbook.downtimes","text":""},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes","title":"<code>Downtimes</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata downtimes APIs</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>class Downtimes(ApiManager):\n    \"\"\"Class that handles all the XAutomata downtimes APIs\"\"\"\n\n    def downtimes(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Downtimes\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_calendar (string optional): additional filter - parameter\n            start (string optional): additional filter - parameter\n            end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            country (string optional): additional filter - parameter\n            state_province (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_calendar', 'start', 'end',\n            'status', 'code', 'description', 'country', 'state_province',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_calendar'), params.get('start'\n            ), params.get('end'), params.get('status'), params.get('code'\n            ), params.get('description'), params.get('country'), params.get(\n            'state_province'), params.get('null_fields'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/downtimes/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def downtimes_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Downtime\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_calendar (string optional): additional filter - payload\n            start (string optional): additional filter - payload\n            end (string optional): additional filter - payload\n            status (string required): additional filter - payload\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_calendar', 'start', 'end', 'status',\n            'code', 'description', 'country', 'state_province']\n        payload.get('uuid_calendar'), payload.get('start'), payload.get('end'\n            ), payload.get('status'), payload.get('code'), payload.get(\n            'description'), payload.get('country'), payload.get(\n            'state_province')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/downtimes/', payload=\n            payload, **kwargs)\n        return response\n\n    def downtime(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Downtime\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtime.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/downtimes/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def downtimes_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Downtime\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_calendar (string optional): additional filter - payload\n            start (string optional): additional filter - payload\n            end (string optional): additional filter - payload\n            status (string optional): additional filter - payload\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_calendar', 'start', 'end', 'status',\n            'code', 'description', 'country', 'state_province']\n        payload.get('uuid_calendar'), payload.get('start'), payload.get('end'\n            ), payload.get('status'), payload.get('code'), payload.get(\n            'description'), payload.get('country'), payload.get(\n            'state_province')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/downtimes/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def downtimes_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Downtime\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/downtimes/{uuid}', **kwargs)\n        return response\n\n    def downtimes_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/downtimes/{uuid}/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def downtimes_groups_create(self, uuid: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/{uuid}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def downtimes_groups_delete(self, uuid: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/downtimes/{uuid}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def downtimes_objects(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Objects\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_objects.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/downtimes/{uuid}/objects',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def downtimes_objects_create(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def downtimes_objects_delete(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/downtimes/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def downtimes_metrics(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metrics\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_metrics.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/downtimes/{uuid}/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def downtimes_metrics_create(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def downtimes_metrics_delete(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/downtimes/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def downtimes_metric_types(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metric Types\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_metric_types.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/downtimes/{uuid}/metric_types', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def downtimes_metric_types_create(self, uuid: str,\n        uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric_type (str, required): uuid_metric_type\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n        return response\n\n    def downtimes_metric_types_delete(self, uuid: str,\n        uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric_type (str, required): uuid_metric_type\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/downtimes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n        return response\n\n    def downtimes_services(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Services\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_services.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/downtimes/{uuid}/services',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def downtimes_services_create(self, uuid: str, uuid_service: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Service\n\n        Args:\n            uuid (str, required): uuid\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/{uuid}/services/{uuid_service}', **kwargs)\n        return response\n\n    def downtimes_services_delete(self, uuid: str, uuid_service: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Service\n\n        Args:\n            uuid (str, required): uuid\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/downtimes/{uuid}/services/{uuid_service}', **kwargs)\n        return response\n\n    def downtimes_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/downtimes/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_calendar\": \"string\", optional\n            \"start\": \"string\", optional\n            \"end\": \"string\", optional\n            \"status\": \"string\", required\n            \"code\": \"string\", required\n            \"description\": \"string\", optional\n            \"country\": \"string\", optional\n            \"state_province\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/downtimes/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def downtimes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/downtimes/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def downtimes_groups_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Groups Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_groups_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/downtimes/bulk/read/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_groups_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_groups_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/create/groups', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_groups_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/delete/groups', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def downtimes_objects_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Objects Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_objects_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/read/objects', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def downtimes_objects_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_objects_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/create/objects', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_objects_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/delete/objects', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def downtimes_metric_types_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                downtimes_metric_types_create_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/create/metric_types', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_metric_types_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/delete/metric_types', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def downtimes_metrics_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_metrics_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/create/metrics', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_metrics_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/delete/metrics', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def downtimes_services_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.downtimes_services_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/create/services', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def downtimes_services_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/downtimes/bulk/delete/services', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtime","title":"<code>downtime(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtime(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Downtime\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtime.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/downtimes/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes","title":"<code>downtimes(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - parameter</p> <code>start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Downtimes\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_calendar (string optional): additional filter - parameter\n        start (string optional): additional filter - parameter\n        end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        country (string optional): additional filter - parameter\n        state_province (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_calendar', 'start', 'end',\n        'status', 'code', 'description', 'country', 'state_province',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_calendar'), params.get('start'\n        ), params.get('end'), params.get('status'), params.get('code'\n        ), params.get('description'), params.get('country'), params.get(\n        'state_province'), params.get('null_fields'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/downtimes/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_bulk","title":"<code>downtimes_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/downtimes/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_create","title":"<code>downtimes_create(kwargs=None, **payload)</code>","text":"<p>Create Downtime</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - payload</p> <code>start</code> <code>string optional</code> <p>additional filter - payload</p> <code>end</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Downtime\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_calendar (string optional): additional filter - payload\n        start (string optional): additional filter - payload\n        end (string optional): additional filter - payload\n        status (string required): additional filter - payload\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_calendar', 'start', 'end', 'status',\n        'code', 'description', 'country', 'state_province']\n    payload.get('uuid_calendar'), payload.get('start'), payload.get('end'\n        ), payload.get('status'), payload.get('code'), payload.get(\n        'description'), payload.get('country'), payload.get(\n        'state_province')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/downtimes/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_create_bulk","title":"<code>downtimes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_calendar\": \"string\", optional     \"start\": \"string\", optional     \"end\": \"string\", optional     \"status\": \"string\", required     \"code\": \"string\", required     \"description\": \"string\", optional     \"country\": \"string\", optional     \"state_province\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_calendar\": \"string\", optional\n        \"start\": \"string\", optional\n        \"end\": \"string\", optional\n        \"status\": \"string\", required\n        \"code\": \"string\", required\n        \"description\": \"string\", optional\n        \"country\": \"string\", optional\n        \"state_province\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/downtimes/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_delete","title":"<code>downtimes_delete(uuid, kwargs=None)</code>","text":"<p>Delete Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Downtime\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/downtimes/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_delete_bulk","title":"<code>downtimes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/downtimes/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_groups","title":"<code>downtimes_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/downtimes/{uuid}/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_groups_bulk","title":"<code>downtimes_groups_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Groups Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_groups_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Groups Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_groups_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/downtimes/bulk/read/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_groups_create","title":"<code>downtimes_groups_create(uuid, uuid_group, kwargs=None)</code>","text":"<p>Add Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_groups_create(self, uuid: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/{uuid}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_groups_create_bulk","title":"<code>downtimes_groups_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_groups_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_groups_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/create/groups', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_groups_delete","title":"<code>downtimes_groups_delete(uuid, uuid_group, kwargs=None)</code>","text":"<p>Remove Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_groups_delete(self, uuid: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/downtimes/{uuid}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_groups_delete_bulk","title":"<code>downtimes_groups_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_groups_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/delete/groups', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metric_types","title":"<code>downtimes_metric_types(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metric_types(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metric Types\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_metric_types.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/downtimes/{uuid}/metric_types', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metric_types_create","title":"<code>downtimes_metric_types_create(uuid, uuid_metric_type, kwargs=None)</code>","text":"<p>Add Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric_type</code> <code>(str, required)</code> <p>uuid_metric_type</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metric_types_create(self, uuid: str,\n    uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric_type (str, required): uuid_metric_type\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metric_types_create_bulk","title":"<code>downtimes_metric_types_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metric_types_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            downtimes_metric_types_create_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/create/metric_types', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metric_types_delete","title":"<code>downtimes_metric_types_delete(uuid, uuid_metric_type, kwargs=None)</code>","text":"<p>Remove Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric_type</code> <code>(str, required)</code> <p>uuid_metric_type</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metric_types_delete(self, uuid: str,\n    uuid_metric_type: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric_type (str, required): uuid_metric_type\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/downtimes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metric_types_delete_bulk","title":"<code>downtimes_metric_types_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metric_types_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/delete/metric_types', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metrics","title":"<code>downtimes_metrics(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metrics</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metrics(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metrics\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_metrics.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/downtimes/{uuid}/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metrics_create","title":"<code>downtimes_metrics_create(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Add Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metrics_create(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metrics_create_bulk","title":"<code>downtimes_metrics_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metrics_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_metrics_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/create/metrics', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metrics_delete","title":"<code>downtimes_metrics_delete(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Remove Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metrics_delete(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/downtimes/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_metrics_delete_bulk","title":"<code>downtimes_metrics_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_metrics_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/delete/metrics', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_objects","title":"<code>downtimes_objects(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Objects</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_objects(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Objects\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_objects.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/downtimes/{uuid}/objects',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_objects_bulk","title":"<code>downtimes_objects_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Objects Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_objects_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Objects Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_objects_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/read/objects', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_objects_create","title":"<code>downtimes_objects_create(uuid, uuid_object, kwargs=None)</code>","text":"<p>Add Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_objects_create(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_objects_create_bulk","title":"<code>downtimes_objects_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_objects_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_objects_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/create/objects', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_objects_delete","title":"<code>downtimes_objects_delete(uuid, uuid_object, kwargs=None)</code>","text":"<p>Remove Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_objects_delete(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/downtimes/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_objects_delete_bulk","title":"<code>downtimes_objects_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_objects_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/delete/objects', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_put","title":"<code>downtimes_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_calendar</code> <code>string optional</code> <p>additional filter - payload</p> <code>start</code> <code>string optional</code> <p>additional filter - payload</p> <code>end</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Downtime\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_calendar (string optional): additional filter - payload\n        start (string optional): additional filter - payload\n        end (string optional): additional filter - payload\n        status (string optional): additional filter - payload\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_calendar', 'start', 'end', 'status',\n        'code', 'description', 'country', 'state_province']\n    payload.get('uuid_calendar'), payload.get('start'), payload.get('end'\n        ), payload.get('status'), payload.get('code'), payload.get(\n        'description'), payload.get('country'), payload.get(\n        'state_province')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/downtimes/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_services","title":"<code>downtimes_services(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Services</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_services(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Services\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_services.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/downtimes/{uuid}/services',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_services_create","title":"<code>downtimes_services_create(uuid, uuid_service, kwargs=None)</code>","text":"<p>Add Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_services_create(self, uuid: str, uuid_service: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Service\n\n    Args:\n        uuid (str, required): uuid\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/{uuid}/services/{uuid_service}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_services_create_bulk","title":"<code>downtimes_services_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_services_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.downtimes_services_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/create/services', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_services_delete","title":"<code>downtimes_services_delete(uuid, uuid_service, kwargs=None)</code>","text":"<p>Remove Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_services_delete(self, uuid: str, uuid_service: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Service\n\n    Args:\n        uuid (str, required): uuid\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/downtimes/{uuid}/services/{uuid_service}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.downtimes/#hive.cookbook.downtimes.Downtimes.downtimes_services_delete_bulk","title":"<code>downtimes_services_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/downtimes.py</code> <pre><code>def downtimes_services_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/downtimes/bulk/delete/services', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/","title":"Hive.cookbook.external tickets","text":""},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets","title":"<code>ExternalTickets</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata external_tickets APIs</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>class ExternalTickets(ApiManager):\n    \"\"\"Class that handles all the XAutomata external_tickets APIs\"\"\"\n\n    def external_tickets(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read External Tickets\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            in_sla (boolean optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object (string optional): additional filter - parameter\n            metric_type (string optional): additional filter - parameter\n            metric (string optional): additional filter - parameter\n            external_itsm (string optional): additional filter - parameter\n            external_ticket (string optional): additional filter - parameter\n            opening_date_start (string optional): additional filter - parameter\n            opening_date_end (string optional): additional filter - parameter\n            closing_date_start (string optional): additional filter - parameter\n            closing_date_end (string optional): additional filter - parameter\n            ticket_type (string optional): additional filter - parameter\n            mode (string optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            organization (string optional): additional filter - parameter\n            responsibility (string optional): additional filter - parameter\n            stage_start_sla_l1 (string optional): additional filter - parameter\n            working_period_l1 (string optional): additional filter - parameter\n            target_stage_start_sla_l1 (string optional): additional filter - parameter\n            stage_start_sla_l2 (string optional): additional filter - parameter\n            working_period_l2 (string optional): additional filter - parameter\n            target_stage_start_sla_l2 (string optional): additional filter - parameter\n            resolution_sla (string optional): additional filter - parameter\n            working_period_resolution (string optional): additional filter - parameter\n            target_period_resolution (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'in_sla', 'uuid_customer',\n            'uuid_virtual_domain', 'uuid_object', 'object', 'metric_type',\n            'metric', 'external_itsm', 'external_ticket',\n            'opening_date_start', 'opening_date_end', 'closing_date_start',\n            'closing_date_end', 'ticket_type', 'mode', 'severity',\n            'organization', 'responsibility', 'stage_start_sla_l1',\n            'working_period_l1', 'target_stage_start_sla_l1',\n            'stage_start_sla_l2', 'working_period_l2',\n            'target_stage_start_sla_l2', 'resolution_sla',\n            'working_period_resolution', 'target_period_resolution',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('in_sla'), params.get('uuid_customer'\n            ), params.get('uuid_virtual_domain'), params.get('uuid_object'\n            ), params.get('object'), params.get('metric_type'), params.get(\n            'metric'), params.get('external_itsm'), params.get(\n            'external_ticket'), params.get('opening_date_start'), params.get(\n            'opening_date_end'), params.get('closing_date_start'), params.get(\n            'closing_date_end'), params.get('ticket_type'), params.get('mode'\n            ), params.get('severity'), params.get('organization'), params.get(\n            'responsibility'), params.get('stage_start_sla_l1'), params.get(\n            'working_period_l1'), params.get('target_stage_start_sla_l1'\n            ), params.get('stage_start_sla_l2'), params.get('working_period_l2'\n            ), params.get('target_stage_start_sla_l2'), params.get(\n            'resolution_sla'), params.get('working_period_resolution'\n            ), params.get('target_period_resolution'), params.get('null_fields'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/external_tickets/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create External Ticket\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string required): additional filter - payload\n            uuid_virtual_domain (string optional): additional filter - payload\n            uuid_object (string optional): additional filter - payload\n            object (string optional): additional filter - payload\n            metric_type (string optional): additional filter - payload\n            metric (string optional): additional filter - payload\n            external_itsm (string required): additional filter - payload\n            external_ticket (string required): additional filter - payload\n            opening_date (string required): additional filter - payload\n            closing_date (string required): additional filter - payload\n            ticket_type (string required): additional filter - payload\n            mode (string required): additional filter - payload\n            severity (string required): additional filter - payload\n            organization (string required): additional filter - payload\n            responsibility (string required): additional filter - payload\n            stage_start_sla_l1 (string required): additional filter - payload\n            working_period_l1 (string required): additional filter - payload\n            target_stage_start_sla_l1 (string required): additional filter - payload\n            stage_start_sla_l2 (string required): additional filter - payload\n            working_period_l2 (string required): additional filter - payload\n            target_stage_start_sla_l2 (string required): additional filter - payload\n            resolution_sla (string required): additional filter - payload\n            working_period_resolution (string required): additional filter - payload\n            target_period_resolution (string required): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'uuid_virtual_domain',\n            'uuid_object', 'object', 'metric_type', 'metric',\n            'external_itsm', 'external_ticket', 'opening_date',\n            'closing_date', 'ticket_type', 'mode', 'severity',\n            'organization', 'responsibility', 'stage_start_sla_l1',\n            'working_period_l1', 'target_stage_start_sla_l1',\n            'stage_start_sla_l2', 'working_period_l2',\n            'target_stage_start_sla_l2', 'resolution_sla',\n            'working_period_resolution', 'target_period_resolution',\n            'data_profile']\n        payload.get('uuid_customer'), payload.get('uuid_virtual_domain'\n            ), payload.get('uuid_object'), payload.get('object'), payload.get(\n            'metric_type'), payload.get('metric'), payload.get('external_itsm'\n            ), payload.get('external_ticket'), payload.get('opening_date'\n            ), payload.get('closing_date'), payload.get('ticket_type'\n            ), payload.get('mode'), payload.get('severity'), payload.get(\n            'organization'), payload.get('responsibility'), payload.get(\n            'stage_start_sla_l1'), payload.get('working_period_l1'\n            ), payload.get('target_stage_start_sla_l1'), payload.get(\n            'stage_start_sla_l2'), payload.get('working_period_l2'\n            ), payload.get('target_stage_start_sla_l2'), payload.get(\n            'resolution_sla'), payload.get('working_period_resolution'\n            ), payload.get('target_period_resolution'), payload.get(\n            'data_profile')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/external_tickets/', payload\n            =payload, **kwargs)\n        return response\n\n    def external_ticket(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read External Ticket\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_ticket.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/external_tickets/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update External Ticket\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string optional): additional filter - payload\n            uuid_virtual_domain (string optional): additional filter - payload\n            uuid_object (string optional): additional filter - payload\n            object (string optional): additional filter - payload\n            metric_type (string optional): additional filter - payload\n            metric (string optional): additional filter - payload\n            external_itsm (string optional): additional filter - payload\n            external_ticket (string optional): additional filter - payload\n            opening_date (string optional): additional filter - payload\n            closing_date (string optional): additional filter - payload\n            ticket_type (string optional): additional filter - payload\n            mode (string optional): additional filter - payload\n            severity (string optional): additional filter - payload\n            organization (string optional): additional filter - payload\n            responsibility (string optional): additional filter - payload\n            stage_start_sla_l1 (string optional): additional filter - payload\n            working_period_l1 (string optional): additional filter - payload\n            target_stage_start_sla_l1 (string optional): additional filter - payload\n            stage_start_sla_l2 (string optional): additional filter - payload\n            working_period_l2 (string optional): additional filter - payload\n            target_stage_start_sla_l2 (string optional): additional filter - payload\n            resolution_sla (string optional): additional filter - payload\n            working_period_resolution (string optional): additional filter - payload\n            target_period_resolution (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'uuid_virtual_domain',\n            'uuid_object', 'object', 'metric_type', 'metric',\n            'external_itsm', 'external_ticket', 'opening_date',\n            'closing_date', 'ticket_type', 'mode', 'severity',\n            'organization', 'responsibility', 'stage_start_sla_l1',\n            'working_period_l1', 'target_stage_start_sla_l1',\n            'stage_start_sla_l2', 'working_period_l2',\n            'target_stage_start_sla_l2', 'resolution_sla',\n            'working_period_resolution', 'target_period_resolution',\n            'data_profile']\n        payload.get('uuid_customer'), payload.get('uuid_virtual_domain'\n            ), payload.get('uuid_object'), payload.get('object'), payload.get(\n            'metric_type'), payload.get('metric'), payload.get('external_itsm'\n            ), payload.get('external_ticket'), payload.get('opening_date'\n            ), payload.get('closing_date'), payload.get('ticket_type'\n            ), payload.get('mode'), payload.get('severity'), payload.get(\n            'organization'), payload.get('responsibility'), payload.get(\n            'stage_start_sla_l1'), payload.get('working_period_l1'\n            ), payload.get('target_stage_start_sla_l1'), payload.get(\n            'stage_start_sla_l2'), payload.get('working_period_l2'\n            ), payload.get('target_stage_start_sla_l2'), payload.get(\n            'resolution_sla'), payload.get('working_period_resolution'\n            ), payload.get('target_period_resolution'), payload.get(\n            'data_profile')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/external_tickets/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def external_tickets_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete External Ticket\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/external_tickets/{uuid}',\n            **kwargs)\n        return response\n\n    def external_tickets_ticket_by_params(self, ticket_type: str,\n        uuid_customer: str, warm_start: bool = False, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Pie Charts\n\n        Args:\n            ticket_type (str, required): ticket_type\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_ticket_by_params\n                .__name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/external_tickets/ticket_by_params/{ticket_type}/{uuid_customer}'\n            , warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_ticket_by_sla(self, ticket_type: str,\n        uuid_customer: str, warm_start: bool = False, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Sla Charge And Resolution\n\n        Args:\n            ticket_type (str, required): ticket_type\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_ticket_by_sla.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/external_tickets/ticket_by_sla/{ticket_type}/{uuid_customer}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_ticket_by_date(self, uuid_customer: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"History\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_ticket_by_date.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/external_tickets/ticket_by_date/{uuid_customer}', warm_start\n            =warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_ticket_by_params_customers_filtering(self,\n        ticket_type: str, warm_start: bool = False, kwargs: dict = None, **\n        params) -&gt; list:\n        \"\"\"Customers Filtering Pie Charts\n\n        Args:\n            ticket_type (str, required): ticket_type\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                external_tickets_ticket_by_params_customers_filtering.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/external_tickets/ticket_by_params/customers_filtering/{ticket_type}/'\n            , warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_ticket_by_sla_customers_filtering(self,\n        ticket_type: str, warm_start: bool = False, kwargs: dict = None, **\n        params) -&gt; list:\n        \"\"\"Customers Filtering Sla Charge And Resolution\n\n        Args:\n            ticket_type (str, required): ticket_type\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                external_tickets_ticket_by_sla_customers_filtering.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/external_tickets/ticket_by_sla/customers_filtering/{ticket_type}/'\n            , warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_ticket_by_date_customers_filtering(self,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Customers Filtering History\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                external_tickets_ticket_by_date_customers_filtering.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/external_tickets/ticket_by_date/customers_filtering/',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def external_tickets_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read External Tickets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/external_tickets/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def external_tickets_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create External Tickets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_customer\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", optional\n            \"uuid_object\": \"string\", optional\n            \"object\": \"string\", optional\n            \"metric_type\": \"string\", optional\n            \"metric\": \"string\", optional\n            \"external_itsm\": \"string\", required\n            \"external_ticket\": \"string\", required\n            \"opening_date\": \"string\", required\n            \"closing_date\": \"string\", required\n            \"ticket_type\": \"string\", required\n            \"mode\": \"string\", required\n            \"severity\": \"string\", required\n            \"organization\": \"string\", required\n            \"responsibility\": \"string\", required\n            \"stage_start_sla_l1\": \"string\", required\n            \"working_period_l1\": \"string\", required\n            \"target_stage_start_sla_l1\": \"string\", required\n            \"stage_start_sla_l2\": \"string\", required\n            \"working_period_l2\": \"string\", required\n            \"target_stage_start_sla_l2\": \"string\", required\n            \"resolution_sla\": \"string\", required\n            \"working_period_resolution\": \"string\", required\n            \"target_period_resolution\": \"string\", required\n            \"data_profile\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.external_tickets_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/external_tickets/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_ticket","title":"<code>external_ticket(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read External Ticket</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_ticket(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read External Ticket\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_ticket.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/external_tickets/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets","title":"<code>external_tickets(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read External Tickets</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>in_sla</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>external_itsm</code> <code>string optional</code> <p>additional filter - parameter</p> <code>external_ticket</code> <code>string optional</code> <p>additional filter - parameter</p> <code>opening_date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>opening_date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>closing_date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>closing_date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ticket_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mode</code> <code>string optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>organization</code> <code>string optional</code> <p>additional filter - parameter</p> <code>responsibility</code> <code>string optional</code> <p>additional filter - parameter</p> <code>stage_start_sla_l1</code> <code>string optional</code> <p>additional filter - parameter</p> <code>working_period_l1</code> <code>string optional</code> <p>additional filter - parameter</p> <code>target_stage_start_sla_l1</code> <code>string optional</code> <p>additional filter - parameter</p> <code>stage_start_sla_l2</code> <code>string optional</code> <p>additional filter - parameter</p> <code>working_period_l2</code> <code>string optional</code> <p>additional filter - parameter</p> <code>target_stage_start_sla_l2</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resolution_sla</code> <code>string optional</code> <p>additional filter - parameter</p> <code>working_period_resolution</code> <code>string optional</code> <p>additional filter - parameter</p> <code>target_period_resolution</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read External Tickets\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        in_sla (boolean optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object (string optional): additional filter - parameter\n        metric_type (string optional): additional filter - parameter\n        metric (string optional): additional filter - parameter\n        external_itsm (string optional): additional filter - parameter\n        external_ticket (string optional): additional filter - parameter\n        opening_date_start (string optional): additional filter - parameter\n        opening_date_end (string optional): additional filter - parameter\n        closing_date_start (string optional): additional filter - parameter\n        closing_date_end (string optional): additional filter - parameter\n        ticket_type (string optional): additional filter - parameter\n        mode (string optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        organization (string optional): additional filter - parameter\n        responsibility (string optional): additional filter - parameter\n        stage_start_sla_l1 (string optional): additional filter - parameter\n        working_period_l1 (string optional): additional filter - parameter\n        target_stage_start_sla_l1 (string optional): additional filter - parameter\n        stage_start_sla_l2 (string optional): additional filter - parameter\n        working_period_l2 (string optional): additional filter - parameter\n        target_stage_start_sla_l2 (string optional): additional filter - parameter\n        resolution_sla (string optional): additional filter - parameter\n        working_period_resolution (string optional): additional filter - parameter\n        target_period_resolution (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'in_sla', 'uuid_customer',\n        'uuid_virtual_domain', 'uuid_object', 'object', 'metric_type',\n        'metric', 'external_itsm', 'external_ticket',\n        'opening_date_start', 'opening_date_end', 'closing_date_start',\n        'closing_date_end', 'ticket_type', 'mode', 'severity',\n        'organization', 'responsibility', 'stage_start_sla_l1',\n        'working_period_l1', 'target_stage_start_sla_l1',\n        'stage_start_sla_l2', 'working_period_l2',\n        'target_stage_start_sla_l2', 'resolution_sla',\n        'working_period_resolution', 'target_period_resolution',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('in_sla'), params.get('uuid_customer'\n        ), params.get('uuid_virtual_domain'), params.get('uuid_object'\n        ), params.get('object'), params.get('metric_type'), params.get(\n        'metric'), params.get('external_itsm'), params.get(\n        'external_ticket'), params.get('opening_date_start'), params.get(\n        'opening_date_end'), params.get('closing_date_start'), params.get(\n        'closing_date_end'), params.get('ticket_type'), params.get('mode'\n        ), params.get('severity'), params.get('organization'), params.get(\n        'responsibility'), params.get('stage_start_sla_l1'), params.get(\n        'working_period_l1'), params.get('target_stage_start_sla_l1'\n        ), params.get('stage_start_sla_l2'), params.get('working_period_l2'\n        ), params.get('target_stage_start_sla_l2'), params.get(\n        'resolution_sla'), params.get('working_period_resolution'\n        ), params.get('target_period_resolution'), params.get('null_fields'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/external_tickets/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_bulk","title":"<code>external_tickets_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read External Tickets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read External Tickets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/external_tickets/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_create","title":"<code>external_tickets_create(kwargs=None, **payload)</code>","text":"<p>Create External Ticket</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - payload</p> <code>object</code> <code>string optional</code> <p>additional filter - payload</p> <code>metric_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>metric</code> <code>string optional</code> <p>additional filter - payload</p> <code>external_itsm</code> <code>string required</code> <p>additional filter - payload</p> <code>external_ticket</code> <code>string required</code> <p>additional filter - payload</p> <code>opening_date</code> <code>string required</code> <p>additional filter - payload</p> <code>closing_date</code> <code>string required</code> <p>additional filter - payload</p> <code>ticket_type</code> <code>string required</code> <p>additional filter - payload</p> <code>mode</code> <code>string required</code> <p>additional filter - payload</p> <code>severity</code> <code>string required</code> <p>additional filter - payload</p> <code>organization</code> <code>string required</code> <p>additional filter - payload</p> <code>responsibility</code> <code>string required</code> <p>additional filter - payload</p> <code>stage_start_sla_l1</code> <code>string required</code> <p>additional filter - payload</p> <code>working_period_l1</code> <code>string required</code> <p>additional filter - payload</p> <code>target_stage_start_sla_l1</code> <code>string required</code> <p>additional filter - payload</p> <code>stage_start_sla_l2</code> <code>string required</code> <p>additional filter - payload</p> <code>working_period_l2</code> <code>string required</code> <p>additional filter - payload</p> <code>target_stage_start_sla_l2</code> <code>string required</code> <p>additional filter - payload</p> <code>resolution_sla</code> <code>string required</code> <p>additional filter - payload</p> <code>working_period_resolution</code> <code>string required</code> <p>additional filter - payload</p> <code>target_period_resolution</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create External Ticket\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string required): additional filter - payload\n        uuid_virtual_domain (string optional): additional filter - payload\n        uuid_object (string optional): additional filter - payload\n        object (string optional): additional filter - payload\n        metric_type (string optional): additional filter - payload\n        metric (string optional): additional filter - payload\n        external_itsm (string required): additional filter - payload\n        external_ticket (string required): additional filter - payload\n        opening_date (string required): additional filter - payload\n        closing_date (string required): additional filter - payload\n        ticket_type (string required): additional filter - payload\n        mode (string required): additional filter - payload\n        severity (string required): additional filter - payload\n        organization (string required): additional filter - payload\n        responsibility (string required): additional filter - payload\n        stage_start_sla_l1 (string required): additional filter - payload\n        working_period_l1 (string required): additional filter - payload\n        target_stage_start_sla_l1 (string required): additional filter - payload\n        stage_start_sla_l2 (string required): additional filter - payload\n        working_period_l2 (string required): additional filter - payload\n        target_stage_start_sla_l2 (string required): additional filter - payload\n        resolution_sla (string required): additional filter - payload\n        working_period_resolution (string required): additional filter - payload\n        target_period_resolution (string required): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'uuid_virtual_domain',\n        'uuid_object', 'object', 'metric_type', 'metric',\n        'external_itsm', 'external_ticket', 'opening_date',\n        'closing_date', 'ticket_type', 'mode', 'severity',\n        'organization', 'responsibility', 'stage_start_sla_l1',\n        'working_period_l1', 'target_stage_start_sla_l1',\n        'stage_start_sla_l2', 'working_period_l2',\n        'target_stage_start_sla_l2', 'resolution_sla',\n        'working_period_resolution', 'target_period_resolution',\n        'data_profile']\n    payload.get('uuid_customer'), payload.get('uuid_virtual_domain'\n        ), payload.get('uuid_object'), payload.get('object'), payload.get(\n        'metric_type'), payload.get('metric'), payload.get('external_itsm'\n        ), payload.get('external_ticket'), payload.get('opening_date'\n        ), payload.get('closing_date'), payload.get('ticket_type'\n        ), payload.get('mode'), payload.get('severity'), payload.get(\n        'organization'), payload.get('responsibility'), payload.get(\n        'stage_start_sla_l1'), payload.get('working_period_l1'\n        ), payload.get('target_stage_start_sla_l1'), payload.get(\n        'stage_start_sla_l2'), payload.get('working_period_l2'\n        ), payload.get('target_stage_start_sla_l2'), payload.get(\n        'resolution_sla'), payload.get('working_period_resolution'\n        ), payload.get('target_period_resolution'), payload.get(\n        'data_profile')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/external_tickets/', payload\n        =payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_create_bulk","title":"<code>external_tickets_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create External Tickets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_customer\": \"string\", required     \"uuid_virtual_domain\": \"string\", optional     \"uuid_object\": \"string\", optional     \"object\": \"string\", optional     \"metric_type\": \"string\", optional     \"metric\": \"string\", optional     \"external_itsm\": \"string\", required     \"external_ticket\": \"string\", required     \"opening_date\": \"string\", required     \"closing_date\": \"string\", required     \"ticket_type\": \"string\", required     \"mode\": \"string\", required     \"severity\": \"string\", required     \"organization\": \"string\", required     \"responsibility\": \"string\", required     \"stage_start_sla_l1\": \"string\", required     \"working_period_l1\": \"string\", required     \"target_stage_start_sla_l1\": \"string\", required     \"stage_start_sla_l2\": \"string\", required     \"working_period_l2\": \"string\", required     \"target_stage_start_sla_l2\": \"string\", required     \"resolution_sla\": \"string\", required     \"working_period_resolution\": \"string\", required     \"target_period_resolution\": \"string\", required     \"data_profile\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create External Tickets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_customer\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", optional\n        \"uuid_object\": \"string\", optional\n        \"object\": \"string\", optional\n        \"metric_type\": \"string\", optional\n        \"metric\": \"string\", optional\n        \"external_itsm\": \"string\", required\n        \"external_ticket\": \"string\", required\n        \"opening_date\": \"string\", required\n        \"closing_date\": \"string\", required\n        \"ticket_type\": \"string\", required\n        \"mode\": \"string\", required\n        \"severity\": \"string\", required\n        \"organization\": \"string\", required\n        \"responsibility\": \"string\", required\n        \"stage_start_sla_l1\": \"string\", required\n        \"working_period_l1\": \"string\", required\n        \"target_stage_start_sla_l1\": \"string\", required\n        \"stage_start_sla_l2\": \"string\", required\n        \"working_period_l2\": \"string\", required\n        \"target_stage_start_sla_l2\": \"string\", required\n        \"resolution_sla\": \"string\", required\n        \"working_period_resolution\": \"string\", required\n        \"target_period_resolution\": \"string\", required\n        \"data_profile\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/external_tickets/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_delete","title":"<code>external_tickets_delete(uuid, kwargs=None)</code>","text":"<p>Delete External Ticket</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete External Ticket\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/external_tickets/{uuid}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_put","title":"<code>external_tickets_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update External Ticket</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - payload</p> <code>object</code> <code>string optional</code> <p>additional filter - payload</p> <code>metric_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>metric</code> <code>string optional</code> <p>additional filter - payload</p> <code>external_itsm</code> <code>string optional</code> <p>additional filter - payload</p> <code>external_ticket</code> <code>string optional</code> <p>additional filter - payload</p> <code>opening_date</code> <code>string optional</code> <p>additional filter - payload</p> <code>closing_date</code> <code>string optional</code> <p>additional filter - payload</p> <code>ticket_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>mode</code> <code>string optional</code> <p>additional filter - payload</p> <code>severity</code> <code>string optional</code> <p>additional filter - payload</p> <code>organization</code> <code>string optional</code> <p>additional filter - payload</p> <code>responsibility</code> <code>string optional</code> <p>additional filter - payload</p> <code>stage_start_sla_l1</code> <code>string optional</code> <p>additional filter - payload</p> <code>working_period_l1</code> <code>string optional</code> <p>additional filter - payload</p> <code>target_stage_start_sla_l1</code> <code>string optional</code> <p>additional filter - payload</p> <code>stage_start_sla_l2</code> <code>string optional</code> <p>additional filter - payload</p> <code>working_period_l2</code> <code>string optional</code> <p>additional filter - payload</p> <code>target_stage_start_sla_l2</code> <code>string optional</code> <p>additional filter - payload</p> <code>resolution_sla</code> <code>string optional</code> <p>additional filter - payload</p> <code>working_period_resolution</code> <code>string optional</code> <p>additional filter - payload</p> <code>target_period_resolution</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update External Ticket\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string optional): additional filter - payload\n        uuid_virtual_domain (string optional): additional filter - payload\n        uuid_object (string optional): additional filter - payload\n        object (string optional): additional filter - payload\n        metric_type (string optional): additional filter - payload\n        metric (string optional): additional filter - payload\n        external_itsm (string optional): additional filter - payload\n        external_ticket (string optional): additional filter - payload\n        opening_date (string optional): additional filter - payload\n        closing_date (string optional): additional filter - payload\n        ticket_type (string optional): additional filter - payload\n        mode (string optional): additional filter - payload\n        severity (string optional): additional filter - payload\n        organization (string optional): additional filter - payload\n        responsibility (string optional): additional filter - payload\n        stage_start_sla_l1 (string optional): additional filter - payload\n        working_period_l1 (string optional): additional filter - payload\n        target_stage_start_sla_l1 (string optional): additional filter - payload\n        stage_start_sla_l2 (string optional): additional filter - payload\n        working_period_l2 (string optional): additional filter - payload\n        target_stage_start_sla_l2 (string optional): additional filter - payload\n        resolution_sla (string optional): additional filter - payload\n        working_period_resolution (string optional): additional filter - payload\n        target_period_resolution (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'uuid_virtual_domain',\n        'uuid_object', 'object', 'metric_type', 'metric',\n        'external_itsm', 'external_ticket', 'opening_date',\n        'closing_date', 'ticket_type', 'mode', 'severity',\n        'organization', 'responsibility', 'stage_start_sla_l1',\n        'working_period_l1', 'target_stage_start_sla_l1',\n        'stage_start_sla_l2', 'working_period_l2',\n        'target_stage_start_sla_l2', 'resolution_sla',\n        'working_period_resolution', 'target_period_resolution',\n        'data_profile']\n    payload.get('uuid_customer'), payload.get('uuid_virtual_domain'\n        ), payload.get('uuid_object'), payload.get('object'), payload.get(\n        'metric_type'), payload.get('metric'), payload.get('external_itsm'\n        ), payload.get('external_ticket'), payload.get('opening_date'\n        ), payload.get('closing_date'), payload.get('ticket_type'\n        ), payload.get('mode'), payload.get('severity'), payload.get(\n        'organization'), payload.get('responsibility'), payload.get(\n        'stage_start_sla_l1'), payload.get('working_period_l1'\n        ), payload.get('target_stage_start_sla_l1'), payload.get(\n        'stage_start_sla_l2'), payload.get('working_period_l2'\n        ), payload.get('target_stage_start_sla_l2'), payload.get(\n        'resolution_sla'), payload.get('working_period_resolution'\n        ), payload.get('target_period_resolution'), payload.get(\n        'data_profile')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/external_tickets/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_ticket_by_date","title":"<code>external_tickets_ticket_by_date(uuid_customer, warm_start=False, kwargs=None, **params)</code>","text":"<p>History</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_ticket_by_date(self, uuid_customer: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"History\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_ticket_by_date.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/external_tickets/ticket_by_date/{uuid_customer}', warm_start\n        =warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_ticket_by_date_customers_filtering","title":"<code>external_tickets_ticket_by_date_customers_filtering(warm_start=False, kwargs=None, **params)</code>","text":"<p>Customers Filtering History</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_ticket_by_date_customers_filtering(self,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Customers Filtering History\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            external_tickets_ticket_by_date_customers_filtering.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/external_tickets/ticket_by_date/customers_filtering/',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_ticket_by_params","title":"<code>external_tickets_ticket_by_params(ticket_type, uuid_customer, warm_start=False, kwargs=None, **params)</code>","text":"<p>Pie Charts</p> <p>Parameters:</p> Name Type Description Default <code>ticket_type</code> <code>(str, required)</code> <p>ticket_type</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_ticket_by_params(self, ticket_type: str,\n    uuid_customer: str, warm_start: bool = False, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Pie Charts\n\n    Args:\n        ticket_type (str, required): ticket_type\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_ticket_by_params\n            .__name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/external_tickets/ticket_by_params/{ticket_type}/{uuid_customer}'\n        , warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_ticket_by_params_customers_filtering","title":"<code>external_tickets_ticket_by_params_customers_filtering(ticket_type, warm_start=False, kwargs=None, **params)</code>","text":"<p>Customers Filtering Pie Charts</p> <p>Parameters:</p> Name Type Description Default <code>ticket_type</code> <code>(str, required)</code> <p>ticket_type</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_ticket_by_params_customers_filtering(self,\n    ticket_type: str, warm_start: bool = False, kwargs: dict = None, **\n    params) -&gt; list:\n    \"\"\"Customers Filtering Pie Charts\n\n    Args:\n        ticket_type (str, required): ticket_type\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            external_tickets_ticket_by_params_customers_filtering.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/external_tickets/ticket_by_params/customers_filtering/{ticket_type}/'\n        , warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_ticket_by_sla","title":"<code>external_tickets_ticket_by_sla(ticket_type, uuid_customer, warm_start=False, kwargs=None, **params)</code>","text":"<p>Sla Charge And Resolution</p> <p>Parameters:</p> Name Type Description Default <code>ticket_type</code> <code>(str, required)</code> <p>ticket_type</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_ticket_by_sla(self, ticket_type: str,\n    uuid_customer: str, warm_start: bool = False, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Sla Charge And Resolution\n\n    Args:\n        ticket_type (str, required): ticket_type\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.external_tickets_ticket_by_sla.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/external_tickets/ticket_by_sla/{ticket_type}/{uuid_customer}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.external_tickets/#hive.cookbook.external_tickets.ExternalTickets.external_tickets_ticket_by_sla_customers_filtering","title":"<code>external_tickets_ticket_by_sla_customers_filtering(ticket_type, warm_start=False, kwargs=None, **params)</code>","text":"<p>Customers Filtering Sla Charge And Resolution</p> <p>Parameters:</p> Name Type Description Default <code>ticket_type</code> <code>(str, required)</code> <p>ticket_type</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/external_tickets.py</code> <pre><code>def external_tickets_ticket_by_sla_customers_filtering(self,\n    ticket_type: str, warm_start: bool = False, kwargs: dict = None, **\n    params) -&gt; list:\n    \"\"\"Customers Filtering Sla Charge And Resolution\n\n    Args:\n        ticket_type (str, required): ticket_type\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            external_tickets_ticket_by_sla_customers_filtering.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/external_tickets/ticket_by_sla/customers_filtering/{ticket_type}/'\n        , warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.features/","title":"Hive.cookbook.features","text":""},{"location":"hive.cookbook.features/#hive.cookbook.features.Features","title":"<code>Features</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata features APIs</p> Source code in <code>hive/cookbook/features.py</code> <pre><code>class Features(ApiManager):\n    \"\"\"Class that handles all the XAutomata features APIs\"\"\"\n\n    def features(self, warm_start: bool = False, kwargs: dict = None, **params\n        ) -&gt; list:\n        \"\"\"Get Api Features Settings\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            user-agent (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['user-agent']\n        params.get('user-agent')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.features.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/features/', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.features/#hive.cookbook.features.Features.features","title":"<code>features(warm_start=False, kwargs=None, **params)</code>","text":"<p>Get Api Features Settings</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>user-agent</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/features.py</code> <pre><code>def features(self, warm_start: bool = False, kwargs: dict = None, **params\n    ) -&gt; list:\n    \"\"\"Get Api Features Settings\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        user-agent (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['user-agent']\n    params.get('user-agent')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.features.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/features/', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/","title":"Hive.cookbook.files","text":""},{"location":"hive.cookbook.files/#hive.cookbook.files.Files","title":"<code>Files</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata files APIs</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>class Files(ApiManager):\n    \"\"\"Class that handles all the XAutomata files APIs\"\"\"\n\n    def files(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List User Files\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            name (string optional): additional filter - parameter\n            username (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            start_ts (string optional): additional filter - parameter\n            end_ts (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'name', 'username',\n            'uuid_service', 'type', 'start_ts', 'end_ts', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('name'), params.get('username'\n            ), params.get('uuid_service'), params.get('type'), params.get(\n            'start_ts'), params.get('end_ts'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.files.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/files/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def files_create(self, params: dict = False, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Post User File\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_service (string optional): additional filter - parameter\n            expires_at (string optional): additional filter - parameter\n            file (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['file']\n        payload.get('file')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.files_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/files/', params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def file(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read User File\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/files/{uuid}', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def files_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Expire User File\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_service (string optional): additional filter - payload\n            expires_at (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_service', 'expires_at']\n        payload.get('uuid_service'), payload.get('expires_at')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.files_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/files/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def files_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete User File\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/files/{uuid}', **kwargs)\n        return response\n\n    def files_reset_put(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Reset Expire User File\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('PUT', path=f'/files/{uuid}/reset', **kwargs)\n        return response\n\n    def files_download(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Download User File\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/files/{uuid}/download',\n            warm_start=warm_start, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.file","title":"<code>file(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read User File</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def file(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read User File\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/files/{uuid}', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.files","title":"<code>files(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List User Files</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>username</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>start_ts</code> <code>string optional</code> <p>additional filter - parameter</p> <code>end_ts</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def files(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List User Files\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        name (string optional): additional filter - parameter\n        username (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        start_ts (string optional): additional filter - parameter\n        end_ts (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'name', 'username',\n        'uuid_service', 'type', 'start_ts', 'end_ts', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('name'), params.get('username'\n        ), params.get('uuid_service'), params.get('type'), params.get(\n        'start_ts'), params.get('end_ts'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.files.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/files/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.files_create","title":"<code>files_create(params=False, kwargs=None, **payload)</code>","text":"<p>Post User File</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>expires_at</code> <code>string optional</code> <p>additional filter - parameter</p> <code>file</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def files_create(self, params: dict = False, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Post User File\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_service (string optional): additional filter - parameter\n        expires_at (string optional): additional filter - parameter\n        file (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['file']\n    payload.get('file')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.files_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/files/', params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.files_delete","title":"<code>files_delete(uuid, kwargs=None)</code>","text":"<p>Delete User File</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def files_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete User File\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/files/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.files_download","title":"<code>files_download(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Download User File</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def files_download(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Download User File\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/files/{uuid}/download',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.files_put","title":"<code>files_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Expire User File</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_service</code> <code>string optional</code> <p>additional filter - payload</p> <code>expires_at</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def files_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Expire User File\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_service (string optional): additional filter - payload\n        expires_at (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_service', 'expires_at']\n    payload.get('uuid_service'), payload.get('expires_at')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.files_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/files/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.files/#hive.cookbook.files.Files.files_reset_put","title":"<code>files_reset_put(uuid, kwargs=None)</code>","text":"<p>Reset Expire User File</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/files.py</code> <pre><code>def files_reset_put(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Reset Expire User File\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('PUT', path=f'/files/{uuid}/reset', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.firmware_updates/","title":"Hive.cookbook.firmware updates","text":""},{"location":"hive.cookbook.firmware_updates/#hive.cookbook.firmware_updates.FirmwareUpdates","title":"<code>FirmwareUpdates</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata firmware_updates APIs</p> Source code in <code>hive/cookbook/firmware_updates.py</code> <pre><code>class FirmwareUpdates(ApiManager):\n    \"\"\"Class that handles all the XAutomata firmware_updates APIs\"\"\"\n\n    def firmware_updates(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Firmware Updates\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            code (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            model (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            firmware (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'code', 'uuid_customer',\n            'uuid_metric', 'model', 'type', 'firmware', 'status',\n            'date_start', 'date_end', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('code'), params.get('uuid_customer'\n            ), params.get('uuid_metric'), params.get('model'), params.get(\n            'type'), params.get('firmware'), params.get('status'), params.get(\n            'date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.firmware_updates.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/firmware_updates/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def firmware_updates_grouped(self, uuid_customer: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Firmware Updates Grouped\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            column (string required): additional filter - parameter\n            code (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            model (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            firmware (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['column', 'code', 'uuid_metric', 'model',\n            'type', 'firmware', 'status', 'date_start', 'date_end']\n        params.get('column'), params.get('code'), params.get('uuid_metric'\n            ), params.get('model'), params.get('type'), params.get('firmware'\n            ), params.get('status'), params.get('date_start'), params.get(\n            'date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.firmware_updates_grouped.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/firmware_updates/{uuid_customer}/grouped/', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.firmware_updates/#hive.cookbook.firmware_updates.FirmwareUpdates.firmware_updates","title":"<code>firmware_updates(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Firmware Updates</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>model</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>firmware</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/firmware_updates.py</code> <pre><code>def firmware_updates(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Firmware Updates\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        code (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        model (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        firmware (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'code', 'uuid_customer',\n        'uuid_metric', 'model', 'type', 'firmware', 'status',\n        'date_start', 'date_end', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('code'), params.get('uuid_customer'\n        ), params.get('uuid_metric'), params.get('model'), params.get(\n        'type'), params.get('firmware'), params.get('status'), params.get(\n        'date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.firmware_updates.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/firmware_updates/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.firmware_updates/#hive.cookbook.firmware_updates.FirmwareUpdates.firmware_updates_grouped","title":"<code>firmware_updates_grouped(uuid_customer, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Firmware Updates Grouped</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>column</code> <code>string required</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>model</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>firmware</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/firmware_updates.py</code> <pre><code>def firmware_updates_grouped(self, uuid_customer: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Firmware Updates Grouped\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        column (string required): additional filter - parameter\n        code (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        model (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        firmware (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['column', 'code', 'uuid_metric', 'model',\n        'type', 'firmware', 'status', 'date_start', 'date_end']\n    params.get('column'), params.get('code'), params.get('uuid_metric'\n        ), params.get('model'), params.get('type'), params.get('firmware'\n        ), params.get('status'), params.get('date_start'), params.get(\n        'date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.firmware_updates_grouped.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/firmware_updates/{uuid_customer}/grouped/', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.google/","title":"Hive.cookbook.google","text":""},{"location":"hive.cookbook.google/#hive.cookbook.google.Google","title":"<code>Google</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata google APIs</p> Source code in <code>hive/cookbook/google.py</code> <pre><code>class Google(ApiManager):\n    \"\"\"Class that handles all the XAutomata google APIs\"\"\"\n\n    def google_login(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Google Login\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/google/login', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def google_callback(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Google Callback\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/google/callback', warm_start\n            =warm_start, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.google/#hive.cookbook.google.Google.google_callback","title":"<code>google_callback(warm_start=False, kwargs=None)</code>","text":"<p>Google Callback</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/google.py</code> <pre><code>def google_callback(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Google Callback\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/google/callback', warm_start\n        =warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.google/#hive.cookbook.google.Google.google_login","title":"<code>google_login(warm_start=False, kwargs=None)</code>","text":"<p>Google Login</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/google.py</code> <pre><code>def google_login(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Google Login\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/google/login', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/","title":"Hive.cookbook.groups","text":""},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups","title":"<code>Groups</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata groups APIs</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>class Groups(ApiManager):\n    \"\"\"Class that handles all the XAutomata groups APIs\"\"\"\n\n    def groups(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Groups\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            uuid_parent (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            count_children (boolean optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'uuid_parent', 'uuid_site', 'uuid_virtual_domain', 'type',\n            'name', 'description', 'status', 'extract_severity',\n            'count_children', 'severity', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('uuid_parent'), params.get('uuid_site'\n            ), params.get('uuid_virtual_domain'), params.get('type'\n            ), params.get('name'), params.get('description'), params.get(\n            'status'), params.get('extract_severity'), params.get(\n            'count_children'), params.get('severity'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/groups/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def groups_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Group\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_parent (string optional): additional filter - payload\n            uuid_site (string required): additional filter - payload\n            uuid_virtual_domain (string required): additional filter - payload\n            type (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string required): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_parent', 'uuid_site',\n            'uuid_virtual_domain', 'type', 'name', 'description',\n            'automata_domain', 'status']\n        payload.get('uuid_parent'), payload.get('uuid_site'), payload.get(\n            'uuid_virtual_domain'), payload.get('type'), payload.get('name'\n            ), payload.get('description'), payload.get('automata_domain'\n            ), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/groups/', payload=payload,\n            **kwargs)\n        return response\n\n    def group(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Group\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.group.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/groups/{uuid}', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def groups_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Group\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_parent (string optional): additional filter - payload\n            uuid_site (string optional): additional filter - payload\n            uuid_virtual_domain (string optional): additional filter - payload\n            type (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_parent', 'uuid_site',\n            'uuid_virtual_domain', 'type', 'name', 'description',\n            'automata_domain', 'status']\n        payload.get('uuid_parent'), payload.get('uuid_site'), payload.get(\n            'uuid_virtual_domain'), payload.get('type'), payload.get('name'\n            ), payload.get('description'), payload.get('automata_domain'\n            ), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/groups/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def groups_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Group\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/groups/{uuid}', **kwargs)\n        return response\n\n    def groups_objects(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Objects\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            not_fields (string optional): additional filter - parameter\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            count_children (boolean optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'not_fields', 'not_in', 'name',\n            'profile', 'extract_severity', 'count_children',\n            'object_profile', 'severity', 'status', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('not_fields'), params.get('not_in'\n            ), params.get('name'), params.get('profile'), params.get(\n            'extract_severity'), params.get('count_children'), params.get(\n            'object_profile'), params.get('severity'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_objects.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/groups/{uuid}/objects',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def groups_objects_create(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/groups/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def groups_objects_delete(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/groups/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def groups_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_users.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/groups/{uuid}/users',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def groups_users_create(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Add User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/groups/{uuid}/users/{name}',\n            **kwargs)\n        return response\n\n    def groups_users_delete(self, uuid: str, name: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Remove User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/groups/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def groups_downtimes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status',\n            'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('active_at_timestamp'), params.get(\n            'active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_downtimes.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/groups/{uuid}/downtimes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def groups_downtimes_create(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/groups/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def groups_downtimes_delete(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/groups/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def groups_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status',\n            'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('active_at_timestamp'), params.get(\n            'active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('tag'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/groups/{uuid}/dispatchers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def groups_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/groups/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def groups_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/groups/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def groups_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/groups/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def groups_read_by_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Read Groups By Uuid Site And Uuid Virtual Domain And Name\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_site\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", required\n            \"name\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/groups/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, payload=payload, **kwargs)\n        return response\n\n    def groups_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_parent\": \"string\", optional\n            \"uuid_site\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", required\n            \"type\": \"string\", required\n            \"name\": \"string\", required\n            \"description\": \"string\", required\n            \"automata_domain\": \"array object\", optional\n            \"status\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/groups/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def groups_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/groups/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def groups_objects_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_group\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_objects_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/groups/bulk/create/objects',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def groups_objects_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_group\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/groups/bulk/delete/objects',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def groups_downtimes_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Groups Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['active_at_timestamp',\n            'active_after_timestamp', 'active_at_or_after_timestamp', 'join']\n        params.get('active_at_timestamp'), params.get('active_after_timestamp'\n            ), params.get('active_at_or_after_timestamp'), params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_downtimes_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/groups/bulk/read/downtimes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def groups_downtimes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_downtimes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/groups/bulk/create/downtimes', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def groups_downtimes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/groups/bulk/delete/downtimes', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def groups_users_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.groups_users_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/groups/bulk/create/users',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def groups_users_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/groups/bulk/delete/users',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.group","title":"<code>group(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def group(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Group\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.group.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/groups/{uuid}', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups","title":"<code>groups(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Groups</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>count_children</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Groups\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        uuid_parent (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        count_children (boolean optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'uuid_parent', 'uuid_site', 'uuid_virtual_domain', 'type',\n        'name', 'description', 'status', 'extract_severity',\n        'count_children', 'severity', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('uuid_parent'), params.get('uuid_site'\n        ), params.get('uuid_virtual_domain'), params.get('type'\n        ), params.get('name'), params.get('description'), params.get(\n        'status'), params.get('extract_severity'), params.get(\n        'count_children'), params.get('severity'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/groups/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_bulk","title":"<code>groups_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/groups/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_create","title":"<code>groups_create(kwargs=None, **payload)</code>","text":"<p>Create Group</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_parent</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_site</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string required</code> <p>additional filter - payload</p> <code>type</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string required</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Group\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_parent (string optional): additional filter - payload\n        uuid_site (string required): additional filter - payload\n        uuid_virtual_domain (string required): additional filter - payload\n        type (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string required): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_parent', 'uuid_site',\n        'uuid_virtual_domain', 'type', 'name', 'description',\n        'automata_domain', 'status']\n    payload.get('uuid_parent'), payload.get('uuid_site'), payload.get(\n        'uuid_virtual_domain'), payload.get('type'), payload.get('name'\n        ), payload.get('description'), payload.get('automata_domain'\n        ), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/groups/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_create_bulk","title":"<code>groups_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_parent\": \"string\", optional     \"uuid_site\": \"string\", required     \"uuid_virtual_domain\": \"string\", required     \"type\": \"string\", required     \"name\": \"string\", required     \"description\": \"string\", required     \"automata_domain\": \"array object\", optional     \"status\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_parent\": \"string\", optional\n        \"uuid_site\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", required\n        \"type\": \"string\", required\n        \"name\": \"string\", required\n        \"description\": \"string\", required\n        \"automata_domain\": \"array object\", optional\n        \"status\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/groups/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_delete","title":"<code>groups_delete(uuid, kwargs=None)</code>","text":"<p>Delete Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Group\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/groups/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_delete_bulk","title":"<code>groups_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/groups/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_dispatchers","title":"<code>groups_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status',\n        'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('active_at_timestamp'), params.get(\n        'active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('tag'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/groups/{uuid}/dispatchers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_dispatchers_create","title":"<code>groups_dispatchers_create(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Add Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/groups/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_dispatchers_delete","title":"<code>groups_dispatchers_delete(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Remove Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/groups/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_downtimes","title":"<code>groups_downtimes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_downtimes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status',\n        'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('active_at_timestamp'), params.get(\n        'active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_downtimes.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/groups/{uuid}/downtimes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_downtimes_bulk","title":"<code>groups_downtimes_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Groups Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_downtimes_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Groups Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['active_at_timestamp',\n        'active_after_timestamp', 'active_at_or_after_timestamp', 'join']\n    params.get('active_at_timestamp'), params.get('active_after_timestamp'\n        ), params.get('active_at_or_after_timestamp'), params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_downtimes_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/groups/bulk/read/downtimes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_downtimes_create","title":"<code>groups_downtimes_create(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Add Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_downtimes_create(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/groups/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_downtimes_create_bulk","title":"<code>groups_downtimes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_downtimes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_downtimes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/groups/bulk/create/downtimes', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_downtimes_delete","title":"<code>groups_downtimes_delete(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Remove Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_downtimes_delete(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/groups/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_downtimes_delete_bulk","title":"<code>groups_downtimes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_downtimes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/groups/bulk/delete/downtimes', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_objects","title":"<code>groups_objects(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Objects</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>count_children</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_objects(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Objects\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        not_fields (string optional): additional filter - parameter\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        count_children (boolean optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'not_fields', 'not_in', 'name',\n        'profile', 'extract_severity', 'count_children',\n        'object_profile', 'severity', 'status', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('not_fields'), params.get('not_in'\n        ), params.get('name'), params.get('profile'), params.get(\n        'extract_severity'), params.get('count_children'), params.get(\n        'object_profile'), params.get('severity'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_objects.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/groups/{uuid}/objects',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_objects_create","title":"<code>groups_objects_create(uuid, uuid_object, kwargs=None)</code>","text":"<p>Add Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_objects_create(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/groups/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_objects_create_bulk","title":"<code>groups_objects_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_group\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_objects_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_group\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_objects_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/groups/bulk/create/objects',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_objects_delete","title":"<code>groups_objects_delete(uuid, uuid_object, kwargs=None)</code>","text":"<p>Remove Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_objects_delete(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/groups/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_objects_delete_bulk","title":"<code>groups_objects_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_group\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_objects_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_group\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/groups/bulk/delete/objects',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_put","title":"<code>groups_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_parent</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Group\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_parent (string optional): additional filter - payload\n        uuid_site (string optional): additional filter - payload\n        uuid_virtual_domain (string optional): additional filter - payload\n        type (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_parent', 'uuid_site',\n        'uuid_virtual_domain', 'type', 'name', 'description',\n        'automata_domain', 'status']\n    payload.get('uuid_parent'), payload.get('uuid_site'), payload.get(\n        'uuid_virtual_domain'), payload.get('type'), payload.get('name'\n        ), payload.get('description'), payload.get('automata_domain'\n        ), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/groups/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_read_by_bulk","title":"<code>groups_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Read Groups By Uuid Site And Uuid Virtual Domain And Name</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_site\": \"string\", required     \"uuid_virtual_domain\": \"string\", required     \"name\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_read_by_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Read Groups By Uuid Site And Uuid Virtual Domain And Name\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_site\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", required\n        \"name\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/groups/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_users","title":"<code>groups_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_users.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/groups/{uuid}/users',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_users_create","title":"<code>groups_users_create(uuid, name, kwargs=None)</code>","text":"<p>Add User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_users_create(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Add User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/groups/{uuid}/users/{name}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_users_create_bulk","title":"<code>groups_users_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_users_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.groups_users_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/groups/bulk/create/users',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_users_delete","title":"<code>groups_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Remove User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_users_delete(self, uuid: str, name: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Remove User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/groups/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.groups/#hive.cookbook.groups.Groups.groups_users_delete_bulk","title":"<code>groups_users_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/groups.py</code> <pre><code>def groups_users_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/groups/bulk/delete/users',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.jobs/","title":"Hive.cookbook.jobs","text":""},{"location":"hive.cookbook.jobs/#hive.cookbook.jobs.Jobs","title":"<code>Jobs</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata jobs APIs</p> Source code in <code>hive/cookbook/jobs.py</code> <pre><code>class Jobs(ApiManager):\n    \"\"\"Class that handles all the XAutomata jobs APIs\"\"\"\n\n    def jobs(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Jobs\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            state (string optional): additional filter - parameter\n            exception (string optional): additional filter - parameter\n            result (string optional): additional filter - parameter\n            username (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'name', 'state',\n            'exception', 'result', 'username', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('name'\n            ), params.get('state'), params.get('exception'), params.get(\n            'result'), params.get('username'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.jobs.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/jobs/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def job(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Get Job By Uuid\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/jobs/{uuid}', warm_start=\n            warm_start, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.jobs/#hive.cookbook.jobs.Jobs.job","title":"<code>job(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Get Job By Uuid</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/jobs.py</code> <pre><code>def job(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Get Job By Uuid\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/jobs/{uuid}', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.jobs/#hive.cookbook.jobs.Jobs.jobs","title":"<code>jobs(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Jobs</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>state</code> <code>string optional</code> <p>additional filter - parameter</p> <code>exception</code> <code>string optional</code> <p>additional filter - parameter</p> <code>result</code> <code>string optional</code> <p>additional filter - parameter</p> <code>username</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/jobs.py</code> <pre><code>def jobs(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Jobs\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        state (string optional): additional filter - parameter\n        exception (string optional): additional filter - parameter\n        result (string optional): additional filter - parameter\n        username (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'name', 'state',\n        'exception', 'result', 'username', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('name'\n        ), params.get('state'), params.get('exception'), params.get(\n        'result'), params.get('username'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.jobs.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/jobs/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.last_object_status/","title":"Hive.cookbook.last object status","text":""},{"location":"hive.cookbook.last_object_status/#hive.cookbook.last_object_status.LastObjectStatus","title":"<code>LastObjectStatus</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata last_object_status APIs</p> Source code in <code>hive/cookbook/last_object_status.py</code> <pre><code>class LastObjectStatus(ApiManager):\n    \"\"\"Class that handles all the XAutomata last_object_status APIs\"\"\"\n\n    def last_object_status(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Last Object Status\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_valueless_metrics (boolean optional): additional filter - parameter\n            extract_automata_domain (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            topic (string optional): additional filter - parameter\n            last_value_uuid_probe (string optional): additional filter - parameter\n            last_value_timestamp_start (string optional): additional filter - parameter\n            last_value_timestamp_end (string optional): additional filter - parameter\n            last_value_object_type (string optional): additional filter - parameter\n            last_value_name (string optional): additional filter - parameter\n            last_value_value (string optional): additional filter - parameter\n            last_value_unit (string optional): additional filter - parameter\n            last_value_description (string optional): additional filter - parameter\n            last_value_status (string optional): additional filter - parameter\n            last_value_ranking (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_valueless_metrics',\n            'extract_automata_domain', 'sort_by', 'null_fields',\n            'uuid_customer', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'topic', 'last_value_uuid_probe', 'last_value_timestamp_start',\n            'last_value_timestamp_end', 'last_value_object_type',\n            'last_value_name', 'last_value_value', 'last_value_unit',\n            'last_value_description', 'last_value_status',\n            'last_value_ranking', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('extract_valueless_metrics'), params.get(\n            'extract_automata_domain'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('uuid_customer'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('uuid_metric_type'), params.get('metric_type_name'\n            ), params.get('metric_type_status'), params.get('uuid_metric'\n            ), params.get('metric_name'), params.get('metric_status'\n            ), params.get('metric_profile'), params.get('topic'), params.get(\n            'last_value_uuid_probe'), params.get('last_value_timestamp_start'\n            ), params.get('last_value_timestamp_end'), params.get(\n            'last_value_object_type'), params.get('last_value_name'\n            ), params.get('last_value_value'), params.get('last_value_unit'\n            ), params.get('last_value_description'), params.get(\n            'last_value_status'), params.get('last_value_ranking'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.last_object_status.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/last_object_status/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def last_object_status_create(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Read Last Object Status Lists\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n            uuid_customer (array optional): additional filter - payload\n            customer_code (array optional): additional filter - payload\n            customer_status (array optional): additional filter - payload\n            uuid_site (array optional): additional filter - payload\n            site_code (array optional): additional filter - payload\n            site_description (array optional): additional filter - payload\n            site_address (array optional): additional filter - payload\n            site_zip_code (array optional): additional filter - payload\n            site_city (array optional): additional filter - payload\n            site_country (array optional): additional filter - payload\n            site_state_province (array optional): additional filter - payload\n            site_status (array optional): additional filter - payload\n            uuid_group (array optional): additional filter - payload\n            group_name (array optional): additional filter - payload\n            group_status (array optional): additional filter - payload\n            group_type (array optional): additional filter - payload\n            uuid_object (array optional): additional filter - payload\n            object_name (array optional): additional filter - payload\n            object_status (array optional): additional filter - payload\n            object_profile (array optional): additional filter - payload\n            uuid_metric_type (array optional): additional filter - payload\n            metric_type_name (array optional): additional filter - payload\n            metric_type_status (array optional): additional filter - payload\n            uuid_metric (array optional): additional filter - payload\n            metric_name (array optional): additional filter - payload\n            metric_status (array optional): additional filter - payload\n            metric_profile (array optional): additional filter - payload\n            topic (array optional): additional filter - payload\n            last_value_uuid_probe (array optional): additional filter - payload\n            last_value_timestamp (array optional): additional filter - payload\n            last_value_object_type (array optional): additional filter - payload\n            last_value_name (array optional): additional filter - payload\n            last_value_value (array optional): additional filter - payload\n            last_value_unit (array optional): additional filter - payload\n            last_value_description (array optional): additional filter - payload\n            last_value_status (array optional): additional filter - payload\n            last_value_ranking (array optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'customer_code',\n            'customer_status', 'uuid_site', 'site_code', 'site_description',\n            'site_address', 'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'topic', 'last_value_uuid_probe', 'last_value_timestamp',\n            'last_value_object_type', 'last_value_name', 'last_value_value',\n            'last_value_unit', 'last_value_description',\n            'last_value_status', 'last_value_ranking']\n        payload.get('uuid_customer'), payload.get('customer_code'\n            ), payload.get('customer_status'), payload.get('uuid_site'\n            ), payload.get('site_code'), payload.get('site_description'\n            ), payload.get('site_address'), payload.get('site_zip_code'\n            ), payload.get('site_city'), payload.get('site_country'\n            ), payload.get('site_state_province'), payload.get('site_status'\n            ), payload.get('uuid_group'), payload.get('group_name'\n            ), payload.get('group_status'), payload.get('group_type'\n            ), payload.get('uuid_object'), payload.get('object_name'\n            ), payload.get('object_status'), payload.get('object_profile'\n            ), payload.get('uuid_metric_type'), payload.get('metric_type_name'\n            ), payload.get('metric_type_status'), payload.get('uuid_metric'\n            ), payload.get('metric_name'), payload.get('metric_status'\n            ), payload.get('metric_profile'), payload.get('topic'\n            ), payload.get('last_value_uuid_probe'), payload.get(\n            'last_value_timestamp'), payload.get('last_value_object_type'\n            ), payload.get('last_value_name'), payload.get('last_value_value'\n            ), payload.get('last_value_unit'), payload.get(\n            'last_value_description'), payload.get('last_value_status'\n            ), payload.get('last_value_ranking')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.last_object_status_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/last_object_status/',\n            params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.last_object_status/#hive.cookbook.last_object_status.LastObjectStatus.last_object_status","title":"<code>last_object_status(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Last Object Status</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_valueless_metrics</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_automata_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>topic</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_uuid_probe</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_object_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_value</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/last_object_status.py</code> <pre><code>def last_object_status(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Last Object Status\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_valueless_metrics (boolean optional): additional filter - parameter\n        extract_automata_domain (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        topic (string optional): additional filter - parameter\n        last_value_uuid_probe (string optional): additional filter - parameter\n        last_value_timestamp_start (string optional): additional filter - parameter\n        last_value_timestamp_end (string optional): additional filter - parameter\n        last_value_object_type (string optional): additional filter - parameter\n        last_value_name (string optional): additional filter - parameter\n        last_value_value (string optional): additional filter - parameter\n        last_value_unit (string optional): additional filter - parameter\n        last_value_description (string optional): additional filter - parameter\n        last_value_status (string optional): additional filter - parameter\n        last_value_ranking (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_valueless_metrics',\n        'extract_automata_domain', 'sort_by', 'null_fields',\n        'uuid_customer', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'topic', 'last_value_uuid_probe', 'last_value_timestamp_start',\n        'last_value_timestamp_end', 'last_value_object_type',\n        'last_value_name', 'last_value_value', 'last_value_unit',\n        'last_value_description', 'last_value_status',\n        'last_value_ranking', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('extract_valueless_metrics'), params.get(\n        'extract_automata_domain'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('uuid_customer'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('uuid_metric_type'), params.get('metric_type_name'\n        ), params.get('metric_type_status'), params.get('uuid_metric'\n        ), params.get('metric_name'), params.get('metric_status'\n        ), params.get('metric_profile'), params.get('topic'), params.get(\n        'last_value_uuid_probe'), params.get('last_value_timestamp_start'\n        ), params.get('last_value_timestamp_end'), params.get(\n        'last_value_object_type'), params.get('last_value_name'\n        ), params.get('last_value_value'), params.get('last_value_unit'\n        ), params.get('last_value_description'), params.get(\n        'last_value_status'), params.get('last_value_ranking'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.last_object_status.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/last_object_status/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.last_object_status/#hive.cookbook.last_object_status.LastObjectStatus.last_object_status_create","title":"<code>last_object_status_create(params=False, kwargs=None, **payload)</code>","text":"<p>Read Last Object Status Lists</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <code>uuid_customer</code> <code>array optional</code> <p>additional filter - payload</p> <code>customer_code</code> <code>array optional</code> <p>additional filter - payload</p> <code>customer_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>uuid_site</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_code</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_description</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_address</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_zip_code</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_city</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_country</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_state_province</code> <code>array optional</code> <p>additional filter - payload</p> <code>site_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>uuid_group</code> <code>array optional</code> <p>additional filter - payload</p> <code>group_name</code> <code>array optional</code> <p>additional filter - payload</p> <code>group_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>group_type</code> <code>array optional</code> <p>additional filter - payload</p> <code>uuid_object</code> <code>array optional</code> <p>additional filter - payload</p> <code>object_name</code> <code>array optional</code> <p>additional filter - payload</p> <code>object_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>object_profile</code> <code>array optional</code> <p>additional filter - payload</p> <code>uuid_metric_type</code> <code>array optional</code> <p>additional filter - payload</p> <code>metric_type_name</code> <code>array optional</code> <p>additional filter - payload</p> <code>metric_type_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>uuid_metric</code> <code>array optional</code> <p>additional filter - payload</p> <code>metric_name</code> <code>array optional</code> <p>additional filter - payload</p> <code>metric_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>metric_profile</code> <code>array optional</code> <p>additional filter - payload</p> <code>topic</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_uuid_probe</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_timestamp</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_object_type</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_name</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_value</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_unit</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_description</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_status</code> <code>array optional</code> <p>additional filter - payload</p> <code>last_value_ranking</code> <code>array optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/last_object_status.py</code> <pre><code>def last_object_status_create(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Read Last Object Status Lists\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n        uuid_customer (array optional): additional filter - payload\n        customer_code (array optional): additional filter - payload\n        customer_status (array optional): additional filter - payload\n        uuid_site (array optional): additional filter - payload\n        site_code (array optional): additional filter - payload\n        site_description (array optional): additional filter - payload\n        site_address (array optional): additional filter - payload\n        site_zip_code (array optional): additional filter - payload\n        site_city (array optional): additional filter - payload\n        site_country (array optional): additional filter - payload\n        site_state_province (array optional): additional filter - payload\n        site_status (array optional): additional filter - payload\n        uuid_group (array optional): additional filter - payload\n        group_name (array optional): additional filter - payload\n        group_status (array optional): additional filter - payload\n        group_type (array optional): additional filter - payload\n        uuid_object (array optional): additional filter - payload\n        object_name (array optional): additional filter - payload\n        object_status (array optional): additional filter - payload\n        object_profile (array optional): additional filter - payload\n        uuid_metric_type (array optional): additional filter - payload\n        metric_type_name (array optional): additional filter - payload\n        metric_type_status (array optional): additional filter - payload\n        uuid_metric (array optional): additional filter - payload\n        metric_name (array optional): additional filter - payload\n        metric_status (array optional): additional filter - payload\n        metric_profile (array optional): additional filter - payload\n        topic (array optional): additional filter - payload\n        last_value_uuid_probe (array optional): additional filter - payload\n        last_value_timestamp (array optional): additional filter - payload\n        last_value_object_type (array optional): additional filter - payload\n        last_value_name (array optional): additional filter - payload\n        last_value_value (array optional): additional filter - payload\n        last_value_unit (array optional): additional filter - payload\n        last_value_description (array optional): additional filter - payload\n        last_value_status (array optional): additional filter - payload\n        last_value_ranking (array optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'customer_code',\n        'customer_status', 'uuid_site', 'site_code', 'site_description',\n        'site_address', 'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'topic', 'last_value_uuid_probe', 'last_value_timestamp',\n        'last_value_object_type', 'last_value_name', 'last_value_value',\n        'last_value_unit', 'last_value_description',\n        'last_value_status', 'last_value_ranking']\n    payload.get('uuid_customer'), payload.get('customer_code'\n        ), payload.get('customer_status'), payload.get('uuid_site'\n        ), payload.get('site_code'), payload.get('site_description'\n        ), payload.get('site_address'), payload.get('site_zip_code'\n        ), payload.get('site_city'), payload.get('site_country'\n        ), payload.get('site_state_province'), payload.get('site_status'\n        ), payload.get('uuid_group'), payload.get('group_name'\n        ), payload.get('group_status'), payload.get('group_type'\n        ), payload.get('uuid_object'), payload.get('object_name'\n        ), payload.get('object_status'), payload.get('object_profile'\n        ), payload.get('uuid_metric_type'), payload.get('metric_type_name'\n        ), payload.get('metric_type_status'), payload.get('uuid_metric'\n        ), payload.get('metric_name'), payload.get('metric_status'\n        ), payload.get('metric_profile'), payload.get('topic'\n        ), payload.get('last_value_uuid_probe'), payload.get(\n        'last_value_timestamp'), payload.get('last_value_object_type'\n        ), payload.get('last_value_name'), payload.get('last_value_value'\n        ), payload.get('last_value_unit'), payload.get(\n        'last_value_description'), payload.get('last_value_status'\n        ), payload.get('last_value_ranking')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.last_object_status_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/last_object_status/',\n        params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.last_status/","title":"Hive.cookbook.last status","text":""},{"location":"hive.cookbook.last_status/#hive.cookbook.last_status.LastStatus","title":"<code>LastStatus</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata last_status APIs</p> Source code in <code>hive/cookbook/last_status.py</code> <pre><code>class LastStatus(ApiManager):\n    \"\"\"Class that handles all the XAutomata last_status APIs\"\"\"\n\n    def last_status(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Last Admin Status\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_valueless_metrics (boolean optional): additional filter - parameter\n            extract_automata_domain (string optional): additional filter - parameter\n            extract_data_profile (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_company_name (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            topic (string optional): additional filter - parameter\n            last_value_uuid_probe (string optional): additional filter - parameter\n            last_value_timestamp_start (string optional): additional filter - parameter\n            last_value_timestamp_end (string optional): additional filter - parameter\n            last_value_object_type (string optional): additional filter - parameter\n            last_value_name (string optional): additional filter - parameter\n            last_value_value (string optional): additional filter - parameter\n            last_value_unit (string optional): additional filter - parameter\n            last_value_description (string optional): additional filter - parameter\n            last_value_status (string optional): additional filter - parameter\n            last_value_ranking (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_valueless_metrics',\n            'extract_automata_domain', 'extract_data_profile', 'sort_by',\n            'null_fields', 'uuid_customer', 'customer_company_name',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'uuid_object', 'object_name', 'object_status',\n            'object_profile', 'uuid_metric_type', 'metric_type_name',\n            'metric_type_status', 'uuid_metric', 'metric_name',\n            'metric_status', 'metric_profile', 'topic',\n            'last_value_uuid_probe', 'last_value_timestamp_start',\n            'last_value_timestamp_end', 'last_value_object_type',\n            'last_value_name', 'last_value_value', 'last_value_unit',\n            'last_value_description', 'last_value_status',\n            'last_value_ranking', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('extract_valueless_metrics'), params.get(\n            'extract_automata_domain'), params.get('extract_data_profile'\n            ), params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_company_name'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('uuid_metric_type'), params.get('metric_type_name'\n            ), params.get('metric_type_status'), params.get('uuid_metric'\n            ), params.get('metric_name'), params.get('metric_status'\n            ), params.get('metric_profile'), params.get('topic'), params.get(\n            'last_value_uuid_probe'), params.get('last_value_timestamp_start'\n            ), params.get('last_value_timestamp_end'), params.get(\n            'last_value_object_type'), params.get('last_value_name'\n            ), params.get('last_value_value'), params.get('last_value_unit'\n            ), params.get('last_value_description'), params.get(\n            'last_value_status'), params.get('last_value_ranking'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.last_status.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/last_status/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def last_status_bulk(self, payload: dict = False,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Last Admin Status Lists\n\n        Args:\n            payload (dict, optional): additional parameters for the API.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_valueless_metrics (boolean optional): additional filter - parameter\n            extract_automata_domain (string optional): additional filter - parameter\n            extract_data_profile (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n           {\n            \"uuid_customer\": \"array\", optional\n            \"customer_company_name\": \"array\", optional\n            \"customer_code\": \"array\", optional\n            \"customer_status\": \"array\", optional\n            \"uuid_site\": \"array\", optional\n            \"site_code\": \"array\", optional\n            \"site_description\": \"array\", optional\n            \"site_address\": \"array\", optional\n            \"site_zip_code\": \"array\", optional\n            \"site_city\": \"array\", optional\n            \"site_country\": \"array\", optional\n            \"site_state_province\": \"array\", optional\n            \"site_status\": \"array\", optional\n            \"uuid_group\": \"array\", optional\n            \"group_name\": \"array\", optional\n            \"group_status\": \"array\", optional\n            \"group_type\": \"array\", optional\n            \"uuid_object\": \"array\", optional\n            \"object_name\": \"array\", optional\n            \"object_status\": \"array\", optional\n            \"object_profile\": \"array\", optional\n            \"uuid_metric_type\": \"array\", optional\n            \"metric_type_name\": \"array\", optional\n            \"metric_type_status\": \"array\", optional\n            \"uuid_metric\": \"array\", optional\n            \"metric_name\": \"array\", optional\n            \"metric_status\": \"array\", optional\n            \"metric_profile\": \"array\", optional\n            \"topic\": \"array\", optional\n            \"last_value_uuid_probe\": \"array\", optional\n            \"last_value_timestamp\": \"array\", optional\n            \"last_value_object_type\": \"array\", optional\n            \"last_value_name\": \"array\", optional\n            \"last_value_value\": \"array\", optional\n            \"last_value_unit\": \"array\", optional\n            \"last_value_description\": \"array\", optional\n            \"last_value_status\": \"array\", optional\n            \"last_value_ranking\": \"array\", optional\n           }\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_valueless_metrics',\n            'extract_automata_domain', 'extract_data_profile', 'sort_by',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('extract_valueless_metrics'), params.get(\n            'extract_automata_domain'), params.get('extract_data_profile'\n            ), params.get('sort_by'), params.get('null_fields'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.last_status_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/last_status/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, payload=payload, **kwargs)\n        return response\n\n    def last_status_delete(self, uuid_metric: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Last Admin Status\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/last_status/{uuid_metric}', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.last_status/#hive.cookbook.last_status.LastStatus.last_status","title":"<code>last_status(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Last Admin Status</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_valueless_metrics</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_automata_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>topic</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_uuid_probe</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_object_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_value</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/last_status.py</code> <pre><code>def last_status(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Last Admin Status\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_valueless_metrics (boolean optional): additional filter - parameter\n        extract_automata_domain (string optional): additional filter - parameter\n        extract_data_profile (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_company_name (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        topic (string optional): additional filter - parameter\n        last_value_uuid_probe (string optional): additional filter - parameter\n        last_value_timestamp_start (string optional): additional filter - parameter\n        last_value_timestamp_end (string optional): additional filter - parameter\n        last_value_object_type (string optional): additional filter - parameter\n        last_value_name (string optional): additional filter - parameter\n        last_value_value (string optional): additional filter - parameter\n        last_value_unit (string optional): additional filter - parameter\n        last_value_description (string optional): additional filter - parameter\n        last_value_status (string optional): additional filter - parameter\n        last_value_ranking (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_valueless_metrics',\n        'extract_automata_domain', 'extract_data_profile', 'sort_by',\n        'null_fields', 'uuid_customer', 'customer_company_name',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'uuid_object', 'object_name', 'object_status',\n        'object_profile', 'uuid_metric_type', 'metric_type_name',\n        'metric_type_status', 'uuid_metric', 'metric_name',\n        'metric_status', 'metric_profile', 'topic',\n        'last_value_uuid_probe', 'last_value_timestamp_start',\n        'last_value_timestamp_end', 'last_value_object_type',\n        'last_value_name', 'last_value_value', 'last_value_unit',\n        'last_value_description', 'last_value_status',\n        'last_value_ranking', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('extract_valueless_metrics'), params.get(\n        'extract_automata_domain'), params.get('extract_data_profile'\n        ), params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_company_name'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('uuid_metric_type'), params.get('metric_type_name'\n        ), params.get('metric_type_status'), params.get('uuid_metric'\n        ), params.get('metric_name'), params.get('metric_status'\n        ), params.get('metric_profile'), params.get('topic'), params.get(\n        'last_value_uuid_probe'), params.get('last_value_timestamp_start'\n        ), params.get('last_value_timestamp_end'), params.get(\n        'last_value_object_type'), params.get('last_value_name'\n        ), params.get('last_value_value'), params.get('last_value_unit'\n        ), params.get('last_value_description'), params.get(\n        'last_value_status'), params.get('last_value_ranking'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.last_status.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/last_status/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.last_status/#hive.cookbook.last_status.LastStatus.last_status_bulk","title":"<code>last_status_bulk(payload=False, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Last Admin Status Lists</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_valueless_metrics</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_automata_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>{     \"uuid_customer\": \"array\", optional     \"customer_company_name\": \"array\", optional     \"customer_code\": \"array\", optional     \"customer_status\": \"array\", optional     \"uuid_site\": \"array\", optional     \"site_code\": \"array\", optional     \"site_description\": \"array\", optional     \"site_address\": \"array\", optional     \"site_zip_code\": \"array\", optional     \"site_city\": \"array\", optional     \"site_country\": \"array\", optional     \"site_state_province\": \"array\", optional     \"site_status\": \"array\", optional     \"uuid_group\": \"array\", optional     \"group_name\": \"array\", optional     \"group_status\": \"array\", optional     \"group_type\": \"array\", optional     \"uuid_object\": \"array\", optional     \"object_name\": \"array\", optional     \"object_status\": \"array\", optional     \"object_profile\": \"array\", optional     \"uuid_metric_type\": \"array\", optional     \"metric_type_name\": \"array\", optional     \"metric_type_status\": \"array\", optional     \"uuid_metric\": \"array\", optional     \"metric_name\": \"array\", optional     \"metric_status\": \"array\", optional     \"metric_profile\": \"array\", optional     \"topic\": \"array\", optional     \"last_value_uuid_probe\": \"array\", optional     \"last_value_timestamp\": \"array\", optional     \"last_value_object_type\": \"array\", optional     \"last_value_name\": \"array\", optional     \"last_value_value\": \"array\", optional     \"last_value_unit\": \"array\", optional     \"last_value_description\": \"array\", optional     \"last_value_status\": \"array\", optional     \"last_value_ranking\": \"array\", optional    }</p> <p>Returns: list</p> Source code in <code>hive/cookbook/last_status.py</code> <pre><code>def last_status_bulk(self, payload: dict = False,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Last Admin Status Lists\n\n    Args:\n        payload (dict, optional): additional parameters for the API.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_valueless_metrics (boolean optional): additional filter - parameter\n        extract_automata_domain (string optional): additional filter - parameter\n        extract_data_profile (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n       {\n        \"uuid_customer\": \"array\", optional\n        \"customer_company_name\": \"array\", optional\n        \"customer_code\": \"array\", optional\n        \"customer_status\": \"array\", optional\n        \"uuid_site\": \"array\", optional\n        \"site_code\": \"array\", optional\n        \"site_description\": \"array\", optional\n        \"site_address\": \"array\", optional\n        \"site_zip_code\": \"array\", optional\n        \"site_city\": \"array\", optional\n        \"site_country\": \"array\", optional\n        \"site_state_province\": \"array\", optional\n        \"site_status\": \"array\", optional\n        \"uuid_group\": \"array\", optional\n        \"group_name\": \"array\", optional\n        \"group_status\": \"array\", optional\n        \"group_type\": \"array\", optional\n        \"uuid_object\": \"array\", optional\n        \"object_name\": \"array\", optional\n        \"object_status\": \"array\", optional\n        \"object_profile\": \"array\", optional\n        \"uuid_metric_type\": \"array\", optional\n        \"metric_type_name\": \"array\", optional\n        \"metric_type_status\": \"array\", optional\n        \"uuid_metric\": \"array\", optional\n        \"metric_name\": \"array\", optional\n        \"metric_status\": \"array\", optional\n        \"metric_profile\": \"array\", optional\n        \"topic\": \"array\", optional\n        \"last_value_uuid_probe\": \"array\", optional\n        \"last_value_timestamp\": \"array\", optional\n        \"last_value_object_type\": \"array\", optional\n        \"last_value_name\": \"array\", optional\n        \"last_value_value\": \"array\", optional\n        \"last_value_unit\": \"array\", optional\n        \"last_value_description\": \"array\", optional\n        \"last_value_status\": \"array\", optional\n        \"last_value_ranking\": \"array\", optional\n       }\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_valueless_metrics',\n        'extract_automata_domain', 'extract_data_profile', 'sort_by',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('extract_valueless_metrics'), params.get(\n        'extract_automata_domain'), params.get('extract_data_profile'\n        ), params.get('sort_by'), params.get('null_fields'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.last_status_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/last_status/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.last_status/#hive.cookbook.last_status.LastStatus.last_status_delete","title":"<code>last_status_delete(uuid_metric, kwargs=None)</code>","text":"<p>Delete Last Admin Status</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/last_status.py</code> <pre><code>def last_status_delete(self, uuid_metric: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Last Admin Status\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/last_status/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/","title":"Hive.cookbook.login","text":""},{"location":"hive.cookbook.login/#hive.cookbook.login.Login","title":"<code>Login</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata login APIs</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>class Login(ApiManager):\n    \"\"\"Class that handles all the XAutomata login APIs\"\"\"\n\n    def login_access_token_create(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Login Access Token Oauth2\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            value_refresh_token (string optional): additional filter - parameter\n            refresh (string optional): additional filter - parameter\n            grant_type (string optional): additional filter - payload\n            username (string required): additional filter - payload\n            password (string required): additional filter - payload\n            scope (string optional): additional filter - payload\n            client_id (string optional): additional filter - payload\n            client_secret (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['grant_type', 'username', 'password',\n            'scope', 'client_id', 'client_secret']\n        payload.get('grant_type'), payload.get('username'), payload.get(\n            'password'), payload.get('scope'), payload.get('client_id'\n            ), payload.get('client_secret')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_access_token_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/login/access-token', params\n            =params, payload=payload, **kwargs)\n        return response\n\n    def login_refresh_create(self, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Refresh Token\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            refresh (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['refresh']\n        params.get('refresh')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_refresh_create.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/login/refresh', params=\n            params, **kwargs)\n        return response\n\n    def login_refresh_invalidate_create(self, kwargs: dict = None, **params\n        ) -&gt; list:\n        \"\"\"Invalidate Token\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            refresh (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['refresh']\n        params.get('refresh')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_refresh_invalidate_create.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/login/refresh/invalidate',\n            params=params, **kwargs)\n        return response\n\n    def login_refresh_invalidate_user_create(self, kwargs: dict = None, **\n        params) -&gt; list:\n        \"\"\"Invalidate User\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            username (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['username']\n        params.get('username')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                login_refresh_invalidate_user_create.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/login/refresh/invalidate_user', params=params, **kwargs)\n        return response\n\n    def login_refresh_invalidate_tokens_create(self, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Invalidate User Tokens\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/login/refresh/invalidate_tokens', **kwargs)\n        return response\n\n    def login_current_user(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Get Current User\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/login/current_user',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def login_current_user_put(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update User\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            password (string optional): additional filter - payload\n            phone (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            email (string optional): additional filter - payload\n            stage (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['password', 'phone', 'profile', 'email',\n            'stage', 'active']\n        payload.get('password'), payload.get('phone'), payload.get('profile'\n            ), payload.get('email'), payload.get('stage'), payload.get('active'\n            )\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_current_user_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/login/current_user', payload\n            =payload, **kwargs)\n        return response\n\n    def login_current_user_dashboards(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Current User Dashboards\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            scope (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'scope', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('scope'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_current_user_dashboards.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/login/current_user/dashboards', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def login_current_user_virtual_domains(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Virtual Domains\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'code', 'status', 'description',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('code'), params.get('status'\n            ), params.get('description'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                login_current_user_virtual_domains.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/login/current_user/virtual_domains', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def login_current_user_image(self, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Get Image\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/login/current_user/image',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def login_current_user_image_put(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Image\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            image (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['image']\n        payload.get('image')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_current_user_image_put.\n                __name__, payload, official_payload_list)\n        response = self.execute('PUT', path=f'/login/current_user/image',\n            payload=payload, **kwargs)\n        return response\n\n    def login_current_user_push_tokens(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Tokens\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            token (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['token', 'sort_by', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('token'), params.get('sort_by'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_current_user_push_tokens.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/login/current_user/push_tokens', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def login_current_user_push_tokens_create(self, kwargs: dict = None, **\n        payload) -&gt; list:\n        \"\"\"Create Or Update Token\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            token (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['token']\n        payload.get('token')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                login_current_user_push_tokens_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/login/current_user/push_tokens', payload=payload, **kwargs)\n        return response\n\n    def login_current_user_push_tokens_delete(self, token: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Downtime\n\n        Args:\n            token (str, required): token\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/login/current_user/push_tokens/{token}', **kwargs)\n        return response\n\n    def login_current_user_notifications(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Notifications\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            title (string optional): additional filter - parameter\n            body (string optional): additional filter - parameter\n            read (boolean optional): additional filter - parameter\n            sent (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'title', 'body',\n            'read', 'sent', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('title'\n            ), params.get('body'), params.get('read'), params.get('sent'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.login_current_user_notifications.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/login/current_user/notifications', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def login_current_user_notifications_put(self, uuid: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Update Notification\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('PUT', path=\n            f'/login/current_user/notifications/{uuid}', **kwargs)\n        return response\n\n    def login_current_user_notifications_delete(self, uuid: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Notification\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/login/current_user/notifications/{uuid}', **kwargs)\n        return response\n\n    def login_current_user_notifications_put_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Set Read\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/login/current_user/notifications/bulk/update', single_page=\n            single_page, page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def login_current_user_terms_and_conditions(self,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Check If User Approved Tc\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            tc_version (integer optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['tc_version', 'sort_by', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('tc_version'), params.get('sort_by'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                login_current_user_terms_and_conditions.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/login/current_user/terms_and_conditions', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def login_current_user_terms_and_conditions_create(self,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"User Approved Or Declined Tc\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            tc_version (integer required): additional filter - payload\n            accepted (boolean required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['tc_version', 'accepted']\n        payload.get('tc_version'), payload.get('accepted')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                login_current_user_terms_and_conditions_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/login/current_user/terms_and_conditions', payload=payload,\n            **kwargs)\n        return response\n\n    def login_current_user_verify_email_create(self, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Send Request To Verify Current User Email\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/login/current_user/verify_email', **kwargs)\n        return response\n\n    def login_current_user_verify_email_put(self, kwargs: dict = None, **params\n        ) -&gt; list:\n        \"\"\"Verify Current User Email\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            verification_code (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['verification_code']\n        params.get('verification_code')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                login_current_user_verify_email_put.__name__, params,\n                official_params_list)\n        response = self.execute('PUT', path=\n            f'/login/current_user/verify_email', params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_access_token_create","title":"<code>login_access_token_create(params=False, kwargs=None, **payload)</code>","text":"<p>Login Access Token Oauth2</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>value_refresh_token</code> <code>string optional</code> <p>additional filter - parameter</p> <code>refresh</code> <code>string optional</code> <p>additional filter - parameter</p> <code>grant_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>username</code> <code>string required</code> <p>additional filter - payload</p> <code>password</code> <code>string required</code> <p>additional filter - payload</p> <code>scope</code> <code>string optional</code> <p>additional filter - payload</p> <code>client_id</code> <code>string optional</code> <p>additional filter - payload</p> <code>client_secret</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_access_token_create(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Login Access Token Oauth2\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        value_refresh_token (string optional): additional filter - parameter\n        refresh (string optional): additional filter - parameter\n        grant_type (string optional): additional filter - payload\n        username (string required): additional filter - payload\n        password (string required): additional filter - payload\n        scope (string optional): additional filter - payload\n        client_id (string optional): additional filter - payload\n        client_secret (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['grant_type', 'username', 'password',\n        'scope', 'client_id', 'client_secret']\n    payload.get('grant_type'), payload.get('username'), payload.get(\n        'password'), payload.get('scope'), payload.get('client_id'\n        ), payload.get('client_secret')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_access_token_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/login/access-token', params\n        =params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user","title":"<code>login_current_user(warm_start=False, kwargs=None)</code>","text":"<p>Get Current User</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Get Current User\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/login/current_user',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_dashboards","title":"<code>login_current_user_dashboards(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Current User Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>scope</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_dashboards(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Current User Dashboards\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        scope (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'scope', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('scope'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_current_user_dashboards.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/login/current_user/dashboards', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_image","title":"<code>login_current_user_image(warm_start=False, kwargs=None)</code>","text":"<p>Get Image</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_image(self, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Get Image\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/login/current_user/image',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_image_put","title":"<code>login_current_user_image_put(kwargs=None, **payload)</code>","text":"<p>Update Image</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>image</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_image_put(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Image\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        image (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['image']\n    payload.get('image')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_current_user_image_put.\n            __name__, payload, official_payload_list)\n    response = self.execute('PUT', path=f'/login/current_user/image',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_notifications","title":"<code>login_current_user_notifications(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Notifications</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>title</code> <code>string optional</code> <p>additional filter - parameter</p> <code>body</code> <code>string optional</code> <p>additional filter - parameter</p> <code>read</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>sent</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_notifications(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Notifications\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        title (string optional): additional filter - parameter\n        body (string optional): additional filter - parameter\n        read (boolean optional): additional filter - parameter\n        sent (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'title', 'body',\n        'read', 'sent', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('title'\n        ), params.get('body'), params.get('read'), params.get('sent'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_current_user_notifications.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/login/current_user/notifications', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_notifications_delete","title":"<code>login_current_user_notifications_delete(uuid, kwargs=None)</code>","text":"<p>Delete Notification</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_notifications_delete(self, uuid: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Notification\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/login/current_user/notifications/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_notifications_put","title":"<code>login_current_user_notifications_put(uuid, kwargs=None)</code>","text":"<p>Update Notification</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_notifications_put(self, uuid: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Update Notification\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('PUT', path=\n        f'/login/current_user/notifications/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_notifications_put_bulk","title":"<code>login_current_user_notifications_put_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Set Read</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_notifications_put_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Set Read\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/login/current_user/notifications/bulk/update', single_page=\n        single_page, page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_push_tokens","title":"<code>login_current_user_push_tokens(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Tokens</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>token</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_push_tokens(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Tokens\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        token (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['token', 'sort_by', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('token'), params.get('sort_by'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_current_user_push_tokens.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/login/current_user/push_tokens', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_push_tokens_create","title":"<code>login_current_user_push_tokens_create(kwargs=None, **payload)</code>","text":"<p>Create Or Update Token</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>token</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_push_tokens_create(self, kwargs: dict = None, **\n    payload) -&gt; list:\n    \"\"\"Create Or Update Token\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        token (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['token']\n    payload.get('token')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            login_current_user_push_tokens_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/login/current_user/push_tokens', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_push_tokens_delete","title":"<code>login_current_user_push_tokens_delete(token, kwargs=None)</code>","text":"<p>Delete Downtime</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>(str, required)</code> <p>token</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_push_tokens_delete(self, token: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Downtime\n\n    Args:\n        token (str, required): token\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/login/current_user/push_tokens/{token}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_put","title":"<code>login_current_user_put(kwargs=None, **payload)</code>","text":"<p>Update User</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>password</code> <code>string optional</code> <p>additional filter - payload</p> <code>phone</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>email</code> <code>string optional</code> <p>additional filter - payload</p> <code>stage</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_put(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update User\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        password (string optional): additional filter - payload\n        phone (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        email (string optional): additional filter - payload\n        stage (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['password', 'phone', 'profile', 'email',\n        'stage', 'active']\n    payload.get('password'), payload.get('phone'), payload.get('profile'\n        ), payload.get('email'), payload.get('stage'), payload.get('active'\n        )\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_current_user_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/login/current_user', payload\n        =payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_terms_and_conditions","title":"<code>login_current_user_terms_and_conditions(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Check If User Approved Tc</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tc_version</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_terms_and_conditions(self,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Check If User Approved Tc\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        tc_version (integer optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['tc_version', 'sort_by', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('tc_version'), params.get('sort_by'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            login_current_user_terms_and_conditions.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/login/current_user/terms_and_conditions', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_terms_and_conditions_create","title":"<code>login_current_user_terms_and_conditions_create(kwargs=None, **payload)</code>","text":"<p>User Approved Or Declined Tc</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tc_version</code> <code>integer required</code> <p>additional filter - payload</p> <code>accepted</code> <code>boolean required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_terms_and_conditions_create(self,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"User Approved Or Declined Tc\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        tc_version (integer required): additional filter - payload\n        accepted (boolean required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['tc_version', 'accepted']\n    payload.get('tc_version'), payload.get('accepted')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            login_current_user_terms_and_conditions_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/login/current_user/terms_and_conditions', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_verify_email_create","title":"<code>login_current_user_verify_email_create(kwargs=None)</code>","text":"<p>Send Request To Verify Current User Email</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_verify_email_create(self, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Send Request To Verify Current User Email\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/login/current_user/verify_email', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_verify_email_put","title":"<code>login_current_user_verify_email_put(kwargs=None, **params)</code>","text":"<p>Verify Current User Email</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>verification_code</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_verify_email_put(self, kwargs: dict = None, **params\n    ) -&gt; list:\n    \"\"\"Verify Current User Email\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        verification_code (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['verification_code']\n    params.get('verification_code')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            login_current_user_verify_email_put.__name__, params,\n            official_params_list)\n    response = self.execute('PUT', path=\n        f'/login/current_user/verify_email', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_current_user_virtual_domains","title":"<code>login_current_user_virtual_domains(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_current_user_virtual_domains(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Virtual Domains\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'code', 'status', 'description',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('code'), params.get('status'\n        ), params.get('description'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            login_current_user_virtual_domains.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/login/current_user/virtual_domains', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_refresh_create","title":"<code>login_refresh_create(kwargs=None, **params)</code>","text":"<p>Refresh Token</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>refresh</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_refresh_create(self, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Refresh Token\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        refresh (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['refresh']\n    params.get('refresh')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_refresh_create.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/login/refresh', params=\n        params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_refresh_invalidate_create","title":"<code>login_refresh_invalidate_create(kwargs=None, **params)</code>","text":"<p>Invalidate Token</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>refresh</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_refresh_invalidate_create(self, kwargs: dict = None, **params\n    ) -&gt; list:\n    \"\"\"Invalidate Token\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        refresh (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['refresh']\n    params.get('refresh')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.login_refresh_invalidate_create.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/login/refresh/invalidate',\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_refresh_invalidate_tokens_create","title":"<code>login_refresh_invalidate_tokens_create(kwargs=None)</code>","text":"<p>Invalidate User Tokens</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_refresh_invalidate_tokens_create(self, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Invalidate User Tokens\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/login/refresh/invalidate_tokens', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.login/#hive.cookbook.login.Login.login_refresh_invalidate_user_create","title":"<code>login_refresh_invalidate_user_create(kwargs=None, **params)</code>","text":"<p>Invalidate User</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>username</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/login.py</code> <pre><code>def login_refresh_invalidate_user_create(self, kwargs: dict = None, **\n    params) -&gt; list:\n    \"\"\"Invalidate User\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        username (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['username']\n    params.get('username')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            login_refresh_invalidate_user_create.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/login/refresh/invalidate_user', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/","title":"Hive.cookbook.messages","text":""},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages","title":"<code>Messages</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata messages APIs</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>class Messages(ApiManager):\n    \"\"\"Class that handles all the XAutomata messages APIs\"\"\"\n\n    def messages(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Messages\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            mask (string optional): additional filter - parameter\n            additional_mask (string optional): additional filter - parameter\n            mask_mime_type (string optional): additional filter - parameter\n            additional_mask_mime_type (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code',\n            'description', 'mask', 'additional_mask', 'mask_mime_type',\n            'additional_mask_mime_type', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('description'), params.get('mask'), params.get(\n            'additional_mask'), params.get('mask_mime_type'), params.get(\n            'additional_mask_mime_type'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/messages/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def messages_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Message\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            description (string required): additional filter - payload\n            mask (string required): additional filter - payload\n            additional_mask (string optional): additional filter - payload\n            mask_mime_type (string required): additional filter - payload\n            additional_mask_mime_type (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'mask',\n            'additional_mask', 'mask_mime_type', 'additional_mask_mime_type']\n        payload.get('code'), payload.get('description'), payload.get('mask'\n            ), payload.get('additional_mask'), payload.get('mask_mime_type'\n            ), payload.get('additional_mask_mime_type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/messages/', payload=payload,\n            **kwargs)\n        return response\n\n    def message(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Message\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/messages/{uuid}', warm_start\n            =warm_start, **kwargs)\n        return response\n\n    def messages_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Message\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            mask (string optional): additional filter - payload\n            additional_mask (string optional): additional filter - payload\n            mask_mime_type (string optional): additional filter - payload\n            additional_mask_mime_type (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'mask',\n            'additional_mask', 'mask_mime_type', 'additional_mask_mime_type']\n        payload.get('code'), payload.get('description'), payload.get('mask'\n            ), payload.get('additional_mask'), payload.get('mask_mime_type'\n            ), payload.get('additional_mask_mime_type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/messages/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def messages_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Message\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/messages/{uuid}', **kwargs)\n        return response\n\n    def messages_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Message Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'tag', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('tag'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/messages/{uuid}/dispatchers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def messages_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Messages\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/messages/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def messages_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Messages\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"code\": \"string\", required\n            \"description\": \"string\", required\n            \"mask\": \"string\", required\n            \"additional_mask\": \"string\", optional\n            \"mask_mime_type\": \"string\", required\n            \"additional_mask_mime_type\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/messages/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def messages_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Messages\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/messages/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def messages_tags(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Get Message Tags\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/messages/tags/', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def messages_compile(self, uuid_metric: str, uuid: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Compile Mask\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            service_profile (string optional): additional filter - parameter\n            timestamp (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['service_profile', 'timestamp']\n        params.get('service_profile'), params.get('timestamp')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_compile.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/messages/{uuid_metric}/compile/{uuid}', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def messages_compile_additional(self, uuid_metric: str, uuid: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Compile Additional Mask\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            service_profile (string optional): additional filter - parameter\n            timestamp (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['service_profile', 'timestamp']\n        params.get('service_profile'), params.get('timestamp')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.messages_compile_additional.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/messages/{uuid_metric}/compile_additional/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.message","title":"<code>message(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Message</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def message(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Message\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/messages/{uuid}', warm_start\n        =warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages","title":"<code>messages(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Messages</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mask</code> <code>string optional</code> <p>additional filter - parameter</p> <code>additional_mask</code> <code>string optional</code> <p>additional filter - parameter</p> <code>mask_mime_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>additional_mask_mime_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Messages\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        mask (string optional): additional filter - parameter\n        additional_mask (string optional): additional filter - parameter\n        mask_mime_type (string optional): additional filter - parameter\n        additional_mask_mime_type (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code',\n        'description', 'mask', 'additional_mask', 'mask_mime_type',\n        'additional_mask_mime_type', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('description'), params.get('mask'), params.get(\n        'additional_mask'), params.get('mask_mime_type'), params.get(\n        'additional_mask_mime_type'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/messages/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_bulk","title":"<code>messages_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Messages</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Messages\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/messages/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_compile","title":"<code>messages_compile(uuid_metric, uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Compile Mask</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_compile(self, uuid_metric: str, uuid: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Compile Mask\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        service_profile (string optional): additional filter - parameter\n        timestamp (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['service_profile', 'timestamp']\n    params.get('service_profile'), params.get('timestamp')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_compile.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/messages/{uuid_metric}/compile/{uuid}', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_compile_additional","title":"<code>messages_compile_additional(uuid_metric, uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Compile Additional Mask</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_compile_additional(self, uuid_metric: str, uuid: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Compile Additional Mask\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        service_profile (string optional): additional filter - parameter\n        timestamp (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['service_profile', 'timestamp']\n    params.get('service_profile'), params.get('timestamp')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_compile_additional.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/messages/{uuid_metric}/compile_additional/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_create","title":"<code>messages_create(kwargs=None, **payload)</code>","text":"<p>Create Message</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string required</code> <p>additional filter - payload</p> <code>mask</code> <code>string required</code> <p>additional filter - payload</p> <code>additional_mask</code> <code>string optional</code> <p>additional filter - payload</p> <code>mask_mime_type</code> <code>string required</code> <p>additional filter - payload</p> <code>additional_mask_mime_type</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Message\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        description (string required): additional filter - payload\n        mask (string required): additional filter - payload\n        additional_mask (string optional): additional filter - payload\n        mask_mime_type (string required): additional filter - payload\n        additional_mask_mime_type (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'mask',\n        'additional_mask', 'mask_mime_type', 'additional_mask_mime_type']\n    payload.get('code'), payload.get('description'), payload.get('mask'\n        ), payload.get('additional_mask'), payload.get('mask_mime_type'\n        ), payload.get('additional_mask_mime_type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/messages/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_create_bulk","title":"<code>messages_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Messages</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"code\": \"string\", required     \"description\": \"string\", required     \"mask\": \"string\", required     \"additional_mask\": \"string\", optional     \"mask_mime_type\": \"string\", required     \"additional_mask_mime_type\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Messages\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"code\": \"string\", required\n        \"description\": \"string\", required\n        \"mask\": \"string\", required\n        \"additional_mask\": \"string\", optional\n        \"mask_mime_type\": \"string\", required\n        \"additional_mask_mime_type\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/messages/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_delete","title":"<code>messages_delete(uuid, kwargs=None)</code>","text":"<p>Delete Message</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Message\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/messages/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_delete_bulk","title":"<code>messages_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Messages</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Messages\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/messages/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_dispatchers","title":"<code>messages_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Message Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Message Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'tag', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('tag'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/messages/{uuid}/dispatchers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_put","title":"<code>messages_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Message</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>mask</code> <code>string optional</code> <p>additional filter - payload</p> <code>additional_mask</code> <code>string optional</code> <p>additional filter - payload</p> <code>mask_mime_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>additional_mask_mime_type</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Message\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        mask (string optional): additional filter - payload\n        additional_mask (string optional): additional filter - payload\n        mask_mime_type (string optional): additional filter - payload\n        additional_mask_mime_type (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'mask',\n        'additional_mask', 'mask_mime_type', 'additional_mask_mime_type']\n    payload.get('code'), payload.get('description'), payload.get('mask'\n        ), payload.get('additional_mask'), payload.get('mask_mime_type'\n        ), payload.get('additional_mask_mime_type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.messages_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/messages/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.messages/#hive.cookbook.messages.Messages.messages_tags","title":"<code>messages_tags(warm_start=False, kwargs=None)</code>","text":"<p>Get Message Tags</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/messages.py</code> <pre><code>def messages_tags(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Get Message Tags\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/messages/tags/', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_ingest/","title":"Hive.cookbook.metric ingest","text":""},{"location":"hive.cookbook.metric_ingest/#hive.cookbook.metric_ingest.MetricIngest","title":"<code>MetricIngest</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata metric_ingest APIs</p> Source code in <code>hive/cookbook/metric_ingest.py</code> <pre><code>class MetricIngest(ApiManager):\n    \"\"\"Class that handles all the XAutomata metric_ingest APIs\"\"\"\n\n    def metric_ingest_create(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Insert Metric\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"extended_attributes_0\": \"string\", optional\n            \"uuid_metric_0\": \"string\", required\n            \"uuid_probe_0\": \"string\", required\n            \"timestamp_0\": \"integer\", required\n            \"object_type_0\": \"string\", optional\n            \"value_0\": \"string\", required\n            \"unit_0\": \"string\", required\n            \"description_0\": \"string\", required\n            \"status_0\": \"None\", required\n            \"ranking_0\": \"integer\", required\n            \"extended_attributes_1\": \"string\", optional\n            \"uuid_metric_1\": \"string\", required\n            \"uuid_probe_1\": \"string\", required\n            \"timestamp_1\": \"integer\", required\n            \"object_type_1\": \"string\", optional\n            \"status_1\": \"None\", required\n            \"ranking_1\": \"integer\", required\n            \"description_1\": \"string\", required\n            \"extended_attributes_2\": \"string\", required\n            \"uuid_metric_2\": \"string\", required\n            \"uuid_probe_2\": \"string\", required\n            \"timestamp_2\": \"integer\", required\n            \"object_type_2\": \"string\", optional\n            \"description_2\": \"string\", optional\n            \"uuid_metric_3\": \"string\", required\n            \"uuid_probe_3\": \"string\", required\n            \"timestamp_3\": \"integer\", required\n            \"object_type_3\": \"string\", optional\n            \"unit_3\": \"string\", required\n            \"value_3\": \"number\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/metric_ingest/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.metric_ingest/#hive.cookbook.metric_ingest.MetricIngest.metric_ingest_create","title":"<code>metric_ingest_create(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Insert Metric</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"extended_attributes_0\": \"string\", optional     \"uuid_metric_0\": \"string\", required     \"uuid_probe_0\": \"string\", required     \"timestamp_0\": \"integer\", required     \"object_type_0\": \"string\", optional     \"value_0\": \"string\", required     \"unit_0\": \"string\", required     \"description_0\": \"string\", required     \"status_0\": \"None\", required     \"ranking_0\": \"integer\", required     \"extended_attributes_1\": \"string\", optional     \"uuid_metric_1\": \"string\", required     \"uuid_probe_1\": \"string\", required     \"timestamp_1\": \"integer\", required     \"object_type_1\": \"string\", optional     \"status_1\": \"None\", required     \"ranking_1\": \"integer\", required     \"description_1\": \"string\", required     \"extended_attributes_2\": \"string\", required     \"uuid_metric_2\": \"string\", required     \"uuid_probe_2\": \"string\", required     \"timestamp_2\": \"integer\", required     \"object_type_2\": \"string\", optional     \"description_2\": \"string\", optional     \"uuid_metric_3\": \"string\", required     \"uuid_probe_3\": \"string\", required     \"timestamp_3\": \"integer\", required     \"object_type_3\": \"string\", optional     \"unit_3\": \"string\", required     \"value_3\": \"number\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_ingest.py</code> <pre><code>def metric_ingest_create(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Insert Metric\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"extended_attributes_0\": \"string\", optional\n        \"uuid_metric_0\": \"string\", required\n        \"uuid_probe_0\": \"string\", required\n        \"timestamp_0\": \"integer\", required\n        \"object_type_0\": \"string\", optional\n        \"value_0\": \"string\", required\n        \"unit_0\": \"string\", required\n        \"description_0\": \"string\", required\n        \"status_0\": \"None\", required\n        \"ranking_0\": \"integer\", required\n        \"extended_attributes_1\": \"string\", optional\n        \"uuid_metric_1\": \"string\", required\n        \"uuid_probe_1\": \"string\", required\n        \"timestamp_1\": \"integer\", required\n        \"object_type_1\": \"string\", optional\n        \"status_1\": \"None\", required\n        \"ranking_1\": \"integer\", required\n        \"description_1\": \"string\", required\n        \"extended_attributes_2\": \"string\", required\n        \"uuid_metric_2\": \"string\", required\n        \"uuid_probe_2\": \"string\", required\n        \"timestamp_2\": \"integer\", required\n        \"object_type_2\": \"string\", optional\n        \"description_2\": \"string\", optional\n        \"uuid_metric_3\": \"string\", required\n        \"uuid_probe_3\": \"string\", required\n        \"timestamp_3\": \"integer\", required\n        \"object_type_3\": \"string\", optional\n        \"unit_3\": \"string\", required\n        \"value_3\": \"number\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/metric_ingest/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/","title":"Hive.cookbook.metric types","text":""},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes","title":"<code>MetricTypes</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata metric_types APIs</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>class MetricTypes(ApiManager):\n    \"\"\"Class that handles all the XAutomata metric_types APIs\"\"\"\n\n    def metric_types(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Metric Types\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            feedback_for_operator (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            count_children (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'uuid_object', 'name', 'description', 'feedback_for_operator',\n            'profile', 'status', 'severity', 'extract_severity',\n            'count_children', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('uuid_object'), params.get('name'\n            ), params.get('description'), params.get('feedback_for_operator'\n            ), params.get('profile'), params.get('status'), params.get(\n            'severity'), params.get('extract_severity'), params.get(\n            'count_children'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/metric_types/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def metric_types_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Metric Type\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_object (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            feedback_for_operator (string optional): additional filter - payload\n            profile (string required): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_object', 'name', 'description',\n            'feedback_for_operator', 'profile', 'data_profile',\n            'automata_domain', 'status']\n        payload.get('uuid_object'), payload.get('name'), payload.get(\n            'description'), payload.get('feedback_for_operator'), payload.get(\n            'profile'), payload.get('data_profile'), payload.get(\n            'automata_domain'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/metric_types/', payload=\n            payload, **kwargs)\n        return response\n\n    def metric_type(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_type.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/metric_types/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def metric_types_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_object (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            feedback_for_operator (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_object', 'name', 'description',\n            'feedback_for_operator', 'profile', 'data_profile',\n            'automata_domain', 'status']\n        payload.get('uuid_object'), payload.get('name'), payload.get(\n            'description'), payload.get('feedback_for_operator'), payload.get(\n            'profile'), payload.get('data_profile'), payload.get(\n            'automata_domain'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/metric_types/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def metric_types_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/metric_types/{uuid}', **\n            kwargs)\n        return response\n\n    def metric_types_metrics(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metrics\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_metrics.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/metric_types/{uuid}/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def metric_types_downtimes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status',\n            'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('active_at_timestamp'), params.get(\n            'active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_downtimes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/metric_types/{uuid}/downtimes', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def metric_types_downtimes_create(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metric_types/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def metric_types_downtimes_delete(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metric_types/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def metric_types_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status',\n            'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('active_at_timestamp'), params.get(\n            'active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('tag'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/metric_types/{uuid}/dispatchers', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def metric_types_dispatchers_create(self, uuid: str,\n        uuid_dispatcher: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Add Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metric_types/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def metric_types_dispatchers_delete(self, uuid: str,\n        uuid_dispatcher: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metric_types/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def metric_types_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/metric_types/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def metric_types_read_by_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Read Metric Types By Uuid Object And Name\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_object\": \"string\", required\n            \"name\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/metric_types/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, payload=payload, **kwargs)\n        return response\n\n    def metric_types_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_object\": \"string\", required\n            \"name\": \"string\", required\n            \"description\": \"string\", optional\n            \"feedback_for_operator\": \"string\", optional\n            \"profile\": \"string\", required\n            \"data_profile\": \"array object\", optional\n            \"automata_domain\": \"array object\", optional\n            \"status\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/metric_types/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def metric_types_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/metric_types/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def metric_types_downtimes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                metric_types_downtimes_create_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/metric_types/bulk/create/downtimes', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def metric_types_downtimes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metric_types/bulk/delete/downtimes', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def metric_types_probes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric_types_probes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/metric_types/bulk/create/probes', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def metric_types_probes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metric_types/bulk/delete/probes', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_type","title":"<code>metric_type(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_type(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_type.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/metric_types/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types","title":"<code>metric_types(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>count_children</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Metric Types\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        feedback_for_operator (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        count_children (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'uuid_object', 'name', 'description', 'feedback_for_operator',\n        'profile', 'status', 'severity', 'extract_severity',\n        'count_children', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('uuid_object'), params.get('name'\n        ), params.get('description'), params.get('feedback_for_operator'\n        ), params.get('profile'), params.get('status'), params.get(\n        'severity'), params.get('extract_severity'), params.get(\n        'count_children'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/metric_types/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_bulk","title":"<code>metric_types_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/metric_types/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_create","title":"<code>metric_types_create(kwargs=None, **payload)</code>","text":"<p>Create Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_object</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Metric Type\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_object (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        feedback_for_operator (string optional): additional filter - payload\n        profile (string required): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_object', 'name', 'description',\n        'feedback_for_operator', 'profile', 'data_profile',\n        'automata_domain', 'status']\n    payload.get('uuid_object'), payload.get('name'), payload.get(\n        'description'), payload.get('feedback_for_operator'), payload.get(\n        'profile'), payload.get('data_profile'), payload.get(\n        'automata_domain'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/metric_types/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_create_bulk","title":"<code>metric_types_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_object\": \"string\", required     \"name\": \"string\", required     \"description\": \"string\", optional     \"feedback_for_operator\": \"string\", optional     \"profile\": \"string\", required     \"data_profile\": \"array object\", optional     \"automata_domain\": \"array object\", optional     \"status\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_object\": \"string\", required\n        \"name\": \"string\", required\n        \"description\": \"string\", optional\n        \"feedback_for_operator\": \"string\", optional\n        \"profile\": \"string\", required\n        \"data_profile\": \"array object\", optional\n        \"automata_domain\": \"array object\", optional\n        \"status\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/metric_types/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_delete","title":"<code>metric_types_delete(uuid, kwargs=None)</code>","text":"<p>Delete Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/metric_types/{uuid}', **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_delete_bulk","title":"<code>metric_types_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/metric_types/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_dispatchers","title":"<code>metric_types_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status',\n        'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('active_at_timestamp'), params.get(\n        'active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('tag'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/metric_types/{uuid}/dispatchers', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_dispatchers_create","title":"<code>metric_types_dispatchers_create(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Add Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_dispatchers_create(self, uuid: str,\n    uuid_dispatcher: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Add Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metric_types/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_dispatchers_delete","title":"<code>metric_types_dispatchers_delete(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Remove Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_dispatchers_delete(self, uuid: str,\n    uuid_dispatcher: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metric_types/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_downtimes","title":"<code>metric_types_downtimes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_downtimes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status',\n        'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('active_at_timestamp'), params.get(\n        'active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_downtimes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/metric_types/{uuid}/downtimes', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_downtimes_create","title":"<code>metric_types_downtimes_create(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Add Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_downtimes_create(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metric_types/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_downtimes_create_bulk","title":"<code>metric_types_downtimes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_downtimes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            metric_types_downtimes_create_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/metric_types/bulk/create/downtimes', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_downtimes_delete","title":"<code>metric_types_downtimes_delete(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Remove Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_downtimes_delete(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metric_types/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_downtimes_delete_bulk","title":"<code>metric_types_downtimes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_downtimes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metric_types/bulk/delete/downtimes', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_metrics","title":"<code>metric_types_metrics(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metrics</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_metrics(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metrics\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_metrics.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/metric_types/{uuid}/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_probes_create_bulk","title":"<code>metric_types_probes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_probes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_probes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/metric_types/bulk/create/probes', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_probes_delete_bulk","title":"<code>metric_types_probes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_probes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metric_types/bulk/delete/probes', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_put","title":"<code>metric_types_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_object</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_object (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        feedback_for_operator (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_object', 'name', 'description',\n        'feedback_for_operator', 'profile', 'data_profile',\n        'automata_domain', 'status']\n    payload.get('uuid_object'), payload.get('name'), payload.get(\n        'description'), payload.get('feedback_for_operator'), payload.get(\n        'profile'), payload.get('data_profile'), payload.get(\n        'automata_domain'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric_types_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/metric_types/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metric_types/#hive.cookbook.metric_types.MetricTypes.metric_types_read_by_bulk","title":"<code>metric_types_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Read Metric Types By Uuid Object And Name</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_object\": \"string\", required     \"name\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metric_types.py</code> <pre><code>def metric_types_read_by_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Read Metric Types By Uuid Object And Name\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_object\": \"string\", required\n        \"name\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/metric_types/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/","title":"Hive.cookbook.metrics","text":""},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics","title":"<code>Metrics</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata metrics APIs</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>class Metrics(ApiManager):\n    \"\"\"Class that handles all the XAutomata metrics APIs\"\"\"\n\n    def metrics(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Metrics\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            feedback_for_operator (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'uuid_metric_type', 'name', 'description',\n            'feedback_for_operator', 'profile', 'status', 'severity',\n            'extract_severity', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('uuid_metric_type'), params.get('name'\n            ), params.get('description'), params.get('feedback_for_operator'\n            ), params.get('profile'), params.get('status'), params.get(\n            'severity'), params.get('extract_severity'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/metrics/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def metrics_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Metric\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_metric_type (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            feedback_for_operator (string optional): additional filter - payload\n            profile (string required): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_metric_type', 'name', 'description',\n            'feedback_for_operator', 'profile', 'data_profile',\n            'automata_domain', 'status']\n        payload.get('uuid_metric_type'), payload.get('name'), payload.get(\n            'description'), payload.get('feedback_for_operator'), payload.get(\n            'profile'), payload.get('data_profile'), payload.get(\n            'automata_domain'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/metrics/', payload=payload,\n            **kwargs)\n        return response\n\n    def metric(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Metric\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metric.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/metrics/{uuid}', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def metrics_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Metric\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_metric_type (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            feedback_for_operator (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_metric_type', 'name', 'description',\n            'feedback_for_operator', 'profile', 'data_profile',\n            'automata_domain', 'status']\n        payload.get('uuid_metric_type'), payload.get('name'), payload.get(\n            'description'), payload.get('feedback_for_operator'), payload.get(\n            'profile'), payload.get('data_profile'), payload.get(\n            'automata_domain'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/metrics/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def metrics_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Metric\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/metrics/{uuid}', **kwargs)\n        return response\n\n    def metrics_last_value(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Last Value\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_last_value.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/metrics/{uuid}/last_value',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def metrics_services(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Services\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'not_fields',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('not_fields'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_services.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/metrics/{uuid}/services',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def metrics_services_create(self, uuid: str, uuid_service: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Service\n\n        Args:\n            uuid (str, required): uuid\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metrics/{uuid}/services/{uuid_service}', **kwargs)\n        return response\n\n    def metrics_services_delete(self, uuid: str, uuid_service: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Service\n\n        Args:\n            uuid (str, required): uuid\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metrics/{uuid}/services/{uuid_service}', **kwargs)\n        return response\n\n    def metrics_services_query(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Metrics Services Query\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_valueless_metrics (boolean optional): additional filter - parameter\n            extract_automata_domain (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_uuid_virtual_domain (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            topic (string optional): additional filter - parameter\n            last_value_uuid_probe (string optional): additional filter - parameter\n            last_value_timestamp_start (string optional): additional filter - parameter\n            last_value_timestamp_end (string optional): additional filter - parameter\n            last_value_object_type (string optional): additional filter - parameter\n            last_value_name (string optional): additional filter - parameter\n            last_value_value (string optional): additional filter - parameter\n            last_value_unit (string optional): additional filter - parameter\n            last_value_description (string optional): additional filter - parameter\n            last_value_status (string optional): additional filter - parameter\n            last_value_ranking (integer optional): additional filter - parameter\n            service_uuid_parent (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            service_profile (string optional): additional filter - parameter\n            service_name (string optional): additional filter - parameter\n            service_description (string optional): additional filter - parameter\n            service_status (string optional): additional filter - parameter\n            service_automata_domain (string optional): additional filter - parameter\n            service_uuid_customer (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_valueless_metrics',\n            'extract_automata_domain', 'sort_by', 'null_fields',\n            'uuid_customer', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_uuid_virtual_domain', 'group_name', 'group_status',\n            'group_type', 'uuid_object', 'object_name', 'object_status',\n            'object_profile', 'uuid_metric_type', 'metric_type_name',\n            'metric_type_status', 'uuid_metric', 'metric_name',\n            'metric_status', 'metric_profile', 'topic',\n            'last_value_uuid_probe', 'last_value_timestamp_start',\n            'last_value_timestamp_end', 'last_value_object_type',\n            'last_value_name', 'last_value_value', 'last_value_unit',\n            'last_value_description', 'last_value_status',\n            'last_value_ranking', 'service_uuid_parent', 'uuid_service',\n            'service_profile', 'service_name', 'service_description',\n            'service_status', 'service_automata_domain',\n            'service_uuid_customer', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('extract_valueless_metrics'), params.get(\n            'extract_automata_domain'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('uuid_customer'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get(\n            'group_uuid_virtual_domain'), params.get('group_name'), params.get(\n            'group_status'), params.get('group_type'), params.get('uuid_object'\n            ), params.get('object_name'), params.get('object_status'\n            ), params.get('object_profile'), params.get('uuid_metric_type'\n            ), params.get('metric_type_name'), params.get('metric_type_status'\n            ), params.get('uuid_metric'), params.get('metric_name'\n            ), params.get('metric_status'), params.get('metric_profile'\n            ), params.get('topic'), params.get('last_value_uuid_probe'\n            ), params.get('last_value_timestamp_start'), params.get(\n            'last_value_timestamp_end'), params.get('last_value_object_type'\n            ), params.get('last_value_name'), params.get('last_value_value'\n            ), params.get('last_value_unit'), params.get(\n            'last_value_description'), params.get('last_value_status'\n            ), params.get('last_value_ranking'), params.get(\n            'service_uuid_parent'), params.get('uuid_service'), params.get(\n            'service_profile'), params.get('service_name'), params.get(\n            'service_description'), params.get('service_status'), params.get(\n            'service_automata_domain'), params.get('service_uuid_customer'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_services_query.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/metrics/services/query',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def metrics_services_query_bulk(self, payload: dict = False,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Metrics Services Query List\n\n        Args:\n            payload (dict, optional): additional parameters for the API.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_valueless_metrics (boolean optional): additional filter - parameter\n            extract_automata_domain (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            last_value_timestamp_start (string optional): additional filter - parameter\n            last_value_timestamp_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n           {\n            \"uuid_customer\": \"array\", optional\n            \"customer_code\": \"array\", optional\n            \"customer_status\": \"array\", optional\n            \"uuid_site\": \"array\", optional\n            \"site_code\": \"array\", optional\n            \"site_description\": \"array\", optional\n            \"site_address\": \"array\", optional\n            \"site_zip_code\": \"array\", optional\n            \"site_city\": \"array\", optional\n            \"site_country\": \"array\", optional\n            \"site_state_province\": \"array\", optional\n            \"site_status\": \"array\", optional\n            \"uuid_group\": \"array\", optional\n            \"group_uuid_virtual_domain\": \"array\", optional\n            \"group_name\": \"array\", optional\n            \"group_status\": \"array\", optional\n            \"group_type\": \"array\", optional\n            \"uuid_object\": \"array\", optional\n            \"object_name\": \"array\", optional\n            \"object_status\": \"array\", optional\n            \"object_profile\": \"array\", optional\n            \"uuid_metric_type\": \"array\", optional\n            \"metric_type_name\": \"array\", optional\n            \"metric_type_status\": \"array\", optional\n            \"uuid_metric\": \"array\", optional\n            \"metric_name\": \"array\", optional\n            \"metric_status\": \"array\", optional\n            \"metric_profile\": \"array\", optional\n            \"topic\": \"array\", optional\n            \"last_value_uuid_probe\": \"array\", optional\n            \"last_value_object_type\": \"array\", optional\n            \"last_value_name\": \"array\", optional\n            \"last_value_value\": \"array\", optional\n            \"last_value_unit\": \"array\", optional\n            \"last_value_description\": \"array\", optional\n            \"last_value_status\": \"array\", optional\n            \"last_value_ranking\": \"array\", optional\n            \"service_uuid_parent\": \"array\", optional\n            \"uuid_service\": \"array\", optional\n            \"service_profile\": \"array\", optional\n            \"service_name\": \"array\", optional\n            \"service_description\": \"array\", optional\n            \"service_status\": \"array\", optional\n            \"service_automata_domain\": \"array\", optional\n            \"service_uuid_customer\": \"array\", optional\n           }\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_valueless_metrics',\n            'extract_automata_domain', 'sort_by', 'null_fields',\n            'last_value_timestamp_start', 'last_value_timestamp_end',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('extract_valueless_metrics'), params.get(\n            'extract_automata_domain'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('last_value_timestamp_start'\n            ), params.get('last_value_timestamp_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_services_query_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/metrics/services/query',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def metrics_downtimes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            fetch_all (boolean optional): additional filter - parameter\n            only_actives (boolean optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status', 'fetch_all',\n            'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('fetch_all'), params.get('only_actives'), params.get(\n            'active_at_timestamp'), params.get('active_after_timestamp'\n            ), params.get('active_at_or_after_timestamp'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_downtimes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/metrics/{uuid}/downtimes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def metrics_downtimes_create(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metrics/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def metrics_downtimes_delete(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metrics/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def metrics_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            fetch_all (boolean optional): additional filter - parameter\n            only_actives (boolean optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status', 'fetch_all',\n            'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('fetch_all'), params.get('only_actives'), params.get(\n            'active_at_timestamp'), params.get('active_after_timestamp'\n            ), params.get('active_at_or_after_timestamp'), params.get('tag'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/metrics/{uuid}/dispatchers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def metrics_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metrics/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def metrics_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metrics/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def metrics_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/metrics/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def metrics_services_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_services_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/metrics/bulk/read/services/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def metrics_downtimes_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            fetch_all (boolean optional): additional filter - parameter\n            only_actives (boolean optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['code', 'status', 'fetch_all',\n            'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('code'), params.get('status'), params.get('fetch_all'\n            ), params.get('only_actives'), params.get('active_at_timestamp'\n            ), params.get('active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_downtimes_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/metrics/bulk/read/downtimes/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def metrics_read_by_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Metrics By Uuid Metric Type And Name\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric_type\": \"string\", required\n            \"name\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/metrics/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, payload=payload, **kwargs)\n        return response\n\n    def metrics_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric_type\": \"string\", required\n            \"name\": \"string\", required\n            \"description\": \"string\", optional\n            \"feedback_for_operator\": \"string\", optional\n            \"profile\": \"string\", required\n            \"data_profile\": \"array object\", optional\n            \"automata_domain\": \"array object\", optional\n            \"status\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/metrics/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def metrics_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/metrics/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def metrics_downtimes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_downtimes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/metrics/bulk/create/downtimes', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def metrics_downtimes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metrics/bulk/delete/downtimes', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def metrics_services_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_services_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/metrics/bulk/create/services', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def metrics_services_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metrics/bulk/delete/services', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def metrics_probes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_probes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/metrics/bulk/create/probes',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def metrics_probes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/metrics/bulk/delete/probes',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def metrics_topic_consumer_create(self, group: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Create Kafka Consumer\n\n        Args:\n            group (str, required): group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/metrics/topic/consumer/{group}', **kwargs)\n        return response\n\n    def metrics_topic_consumer_delete(self, group: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Kafka Consumer\n\n        Args:\n            group (str, required): group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metrics/topic/consumer/{group}', **kwargs)\n        return response\n\n    def metrics_topic_consumer(self, group: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Kafka Consumer\n\n        Args:\n            group (str, required): group\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            num_messages (integer optional): additional filter - parameter\n            compute_lag (boolean optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['num_messages', 'compute_lag']\n        params.get('num_messages'), params.get('compute_lag')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_topic_consumer.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/metrics/topic/consumer/{group}', warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def metrics_topic_consumer_lag(self, group: str,\n        warm_start: bool = False, kwargs: dict = None) -&gt; list:\n        \"\"\"Get Lag Kafka Consumer\n\n        Args:\n            group (str, required): group\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=\n            f'/metrics/topic/consumer/{group}/lag', warm_start=warm_start,\n            **kwargs)\n        return response\n\n    def metrics_topic_consumer_seek(self, group: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Seek Kafka Consumer\n\n        Args:\n            group (str, required): group\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            offset (integer optional): additional filter - parameter\n            position (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['offset', 'position']\n        params.get('offset'), params.get('position')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.metrics_topic_consumer_seek.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/metrics/topic/consumer/{group}/seek', warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def metrics_topic_consumer_filter_create(self, group: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Bulk Create Metrics Consumer Group\n\n        Args:\n            group (str, required): group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid (str required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid']\n        payload.get('uuid')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                metrics_topic_consumer_filter_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/metrics/topic/consumer/{group}/filter', payload=payload, **\n            kwargs)\n        return response\n\n    def metrics_topic_consumer_delete_group(self, group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Metrics Consumer Group\n\n        Args:\n            group (str, required): group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/metrics/topic/consumer/{group}/delete', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metric","title":"<code>metric(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metric(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Metric\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metric.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/metrics/{uuid}', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics","title":"<code>metrics(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Metrics</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Metrics\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        feedback_for_operator (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'uuid_metric_type', 'name', 'description',\n        'feedback_for_operator', 'profile', 'status', 'severity',\n        'extract_severity', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('uuid_metric_type'), params.get('name'\n        ), params.get('description'), params.get('feedback_for_operator'\n        ), params.get('profile'), params.get('status'), params.get(\n        'severity'), params.get('extract_severity'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/metrics/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_bulk","title":"<code>metrics_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/metrics/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_create","title":"<code>metrics_create(kwargs=None, **payload)</code>","text":"<p>Create Metric</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_metric_type</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Metric\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_metric_type (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        feedback_for_operator (string optional): additional filter - payload\n        profile (string required): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_metric_type', 'name', 'description',\n        'feedback_for_operator', 'profile', 'data_profile',\n        'automata_domain', 'status']\n    payload.get('uuid_metric_type'), payload.get('name'), payload.get(\n        'description'), payload.get('feedback_for_operator'), payload.get(\n        'profile'), payload.get('data_profile'), payload.get(\n        'automata_domain'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/metrics/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_create_bulk","title":"<code>metrics_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric_type\": \"string\", required     \"name\": \"string\", required     \"description\": \"string\", optional     \"feedback_for_operator\": \"string\", optional     \"profile\": \"string\", required     \"data_profile\": \"array object\", optional     \"automata_domain\": \"array object\", optional     \"status\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric_type\": \"string\", required\n        \"name\": \"string\", required\n        \"description\": \"string\", optional\n        \"feedback_for_operator\": \"string\", optional\n        \"profile\": \"string\", required\n        \"data_profile\": \"array object\", optional\n        \"automata_domain\": \"array object\", optional\n        \"status\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/metrics/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_delete","title":"<code>metrics_delete(uuid, kwargs=None)</code>","text":"<p>Delete Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Metric\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/metrics/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_delete_bulk","title":"<code>metrics_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/metrics/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_dispatchers","title":"<code>metrics_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fetch_all</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>only_actives</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        fetch_all (boolean optional): additional filter - parameter\n        only_actives (boolean optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status', 'fetch_all',\n        'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('fetch_all'), params.get('only_actives'), params.get(\n        'active_at_timestamp'), params.get('active_after_timestamp'\n        ), params.get('active_at_or_after_timestamp'), params.get('tag'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/metrics/{uuid}/dispatchers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_dispatchers_create","title":"<code>metrics_dispatchers_create(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Add Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metrics/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_dispatchers_delete","title":"<code>metrics_dispatchers_delete(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Remove Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metrics/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_downtimes","title":"<code>metrics_downtimes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fetch_all</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>only_actives</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_downtimes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        fetch_all (boolean optional): additional filter - parameter\n        only_actives (boolean optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status', 'fetch_all',\n        'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('fetch_all'), params.get('only_actives'), params.get(\n        'active_at_timestamp'), params.get('active_after_timestamp'\n        ), params.get('active_at_or_after_timestamp'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_downtimes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/metrics/{uuid}/downtimes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_downtimes_bulk","title":"<code>metrics_downtimes_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fetch_all</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>only_actives</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_downtimes_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        fetch_all (boolean optional): additional filter - parameter\n        only_actives (boolean optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['code', 'status', 'fetch_all',\n        'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('code'), params.get('status'), params.get('fetch_all'\n        ), params.get('only_actives'), params.get('active_at_timestamp'\n        ), params.get('active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_downtimes_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/metrics/bulk/read/downtimes/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_downtimes_create","title":"<code>metrics_downtimes_create(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Add Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_downtimes_create(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metrics/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_downtimes_create_bulk","title":"<code>metrics_downtimes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_downtimes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_downtimes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/metrics/bulk/create/downtimes', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_downtimes_delete","title":"<code>metrics_downtimes_delete(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Remove Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_downtimes_delete(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metrics/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_downtimes_delete_bulk","title":"<code>metrics_downtimes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_downtimes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metrics/bulk/delete/downtimes', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_last_value","title":"<code>metrics_last_value(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Get Last Value</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_last_value(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Last Value\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_last_value.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/metrics/{uuid}/last_value',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_probes_create_bulk","title":"<code>metrics_probes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_probes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_probes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/metrics/bulk/create/probes',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_probes_delete_bulk","title":"<code>metrics_probes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_probes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/metrics/bulk/delete/probes',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_put","title":"<code>metrics_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Metric\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_metric_type (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        feedback_for_operator (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_metric_type', 'name', 'description',\n        'feedback_for_operator', 'profile', 'data_profile',\n        'automata_domain', 'status']\n    payload.get('uuid_metric_type'), payload.get('name'), payload.get(\n        'description'), payload.get('feedback_for_operator'), payload.get(\n        'profile'), payload.get('data_profile'), payload.get(\n        'automata_domain'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/metrics/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_read_by_bulk","title":"<code>metrics_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Read Metrics By Uuid Metric Type And Name</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric_type\": \"string\", required     \"name\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_read_by_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Metrics By Uuid Metric Type And Name\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric_type\": \"string\", required\n        \"name\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/metrics/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services","title":"<code>metrics_services(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Services</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Services\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'not_fields',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('not_fields'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_services.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/metrics/{uuid}/services',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_bulk","title":"<code>metrics_services_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_services_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/metrics/bulk/read/services/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_create","title":"<code>metrics_services_create(uuid, uuid_service, kwargs=None)</code>","text":"<p>Add Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_create(self, uuid: str, uuid_service: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Service\n\n    Args:\n        uuid (str, required): uuid\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metrics/{uuid}/services/{uuid_service}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_create_bulk","title":"<code>metrics_services_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_services_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/metrics/bulk/create/services', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_delete","title":"<code>metrics_services_delete(uuid, uuid_service, kwargs=None)</code>","text":"<p>Remove Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_delete(self, uuid: str, uuid_service: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Service\n\n    Args:\n        uuid (str, required): uuid\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metrics/{uuid}/services/{uuid_service}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_delete_bulk","title":"<code>metrics_services_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metrics/bulk/delete/services', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_query","title":"<code>metrics_services_query(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Metrics Services Query</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_valueless_metrics</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_automata_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>topic</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_uuid_probe</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_object_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_value</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>service_uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_automata_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_query(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Metrics Services Query\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_valueless_metrics (boolean optional): additional filter - parameter\n        extract_automata_domain (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_uuid_virtual_domain (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        topic (string optional): additional filter - parameter\n        last_value_uuid_probe (string optional): additional filter - parameter\n        last_value_timestamp_start (string optional): additional filter - parameter\n        last_value_timestamp_end (string optional): additional filter - parameter\n        last_value_object_type (string optional): additional filter - parameter\n        last_value_name (string optional): additional filter - parameter\n        last_value_value (string optional): additional filter - parameter\n        last_value_unit (string optional): additional filter - parameter\n        last_value_description (string optional): additional filter - parameter\n        last_value_status (string optional): additional filter - parameter\n        last_value_ranking (integer optional): additional filter - parameter\n        service_uuid_parent (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        service_profile (string optional): additional filter - parameter\n        service_name (string optional): additional filter - parameter\n        service_description (string optional): additional filter - parameter\n        service_status (string optional): additional filter - parameter\n        service_automata_domain (string optional): additional filter - parameter\n        service_uuid_customer (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_valueless_metrics',\n        'extract_automata_domain', 'sort_by', 'null_fields',\n        'uuid_customer', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_uuid_virtual_domain', 'group_name', 'group_status',\n        'group_type', 'uuid_object', 'object_name', 'object_status',\n        'object_profile', 'uuid_metric_type', 'metric_type_name',\n        'metric_type_status', 'uuid_metric', 'metric_name',\n        'metric_status', 'metric_profile', 'topic',\n        'last_value_uuid_probe', 'last_value_timestamp_start',\n        'last_value_timestamp_end', 'last_value_object_type',\n        'last_value_name', 'last_value_value', 'last_value_unit',\n        'last_value_description', 'last_value_status',\n        'last_value_ranking', 'service_uuid_parent', 'uuid_service',\n        'service_profile', 'service_name', 'service_description',\n        'service_status', 'service_automata_domain',\n        'service_uuid_customer', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('extract_valueless_metrics'), params.get(\n        'extract_automata_domain'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('uuid_customer'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get(\n        'group_uuid_virtual_domain'), params.get('group_name'), params.get(\n        'group_status'), params.get('group_type'), params.get('uuid_object'\n        ), params.get('object_name'), params.get('object_status'\n        ), params.get('object_profile'), params.get('uuid_metric_type'\n        ), params.get('metric_type_name'), params.get('metric_type_status'\n        ), params.get('uuid_metric'), params.get('metric_name'\n        ), params.get('metric_status'), params.get('metric_profile'\n        ), params.get('topic'), params.get('last_value_uuid_probe'\n        ), params.get('last_value_timestamp_start'), params.get(\n        'last_value_timestamp_end'), params.get('last_value_object_type'\n        ), params.get('last_value_name'), params.get('last_value_value'\n        ), params.get('last_value_unit'), params.get(\n        'last_value_description'), params.get('last_value_status'\n        ), params.get('last_value_ranking'), params.get(\n        'service_uuid_parent'), params.get('uuid_service'), params.get(\n        'service_profile'), params.get('service_name'), params.get(\n        'service_description'), params.get('service_status'), params.get(\n        'service_automata_domain'), params.get('service_uuid_customer'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_services_query.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/metrics/services/query',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_services_query_bulk","title":"<code>metrics_services_query_bulk(payload=False, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Metrics Services Query List</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_valueless_metrics</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_automata_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_value_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>{     \"uuid_customer\": \"array\", optional     \"customer_code\": \"array\", optional     \"customer_status\": \"array\", optional     \"uuid_site\": \"array\", optional     \"site_code\": \"array\", optional     \"site_description\": \"array\", optional     \"site_address\": \"array\", optional     \"site_zip_code\": \"array\", optional     \"site_city\": \"array\", optional     \"site_country\": \"array\", optional     \"site_state_province\": \"array\", optional     \"site_status\": \"array\", optional     \"uuid_group\": \"array\", optional     \"group_uuid_virtual_domain\": \"array\", optional     \"group_name\": \"array\", optional     \"group_status\": \"array\", optional     \"group_type\": \"array\", optional     \"uuid_object\": \"array\", optional     \"object_name\": \"array\", optional     \"object_status\": \"array\", optional     \"object_profile\": \"array\", optional     \"uuid_metric_type\": \"array\", optional     \"metric_type_name\": \"array\", optional     \"metric_type_status\": \"array\", optional     \"uuid_metric\": \"array\", optional     \"metric_name\": \"array\", optional     \"metric_status\": \"array\", optional     \"metric_profile\": \"array\", optional     \"topic\": \"array\", optional     \"last_value_uuid_probe\": \"array\", optional     \"last_value_object_type\": \"array\", optional     \"last_value_name\": \"array\", optional     \"last_value_value\": \"array\", optional     \"last_value_unit\": \"array\", optional     \"last_value_description\": \"array\", optional     \"last_value_status\": \"array\", optional     \"last_value_ranking\": \"array\", optional     \"service_uuid_parent\": \"array\", optional     \"uuid_service\": \"array\", optional     \"service_profile\": \"array\", optional     \"service_name\": \"array\", optional     \"service_description\": \"array\", optional     \"service_status\": \"array\", optional     \"service_automata_domain\": \"array\", optional     \"service_uuid_customer\": \"array\", optional    }</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_services_query_bulk(self, payload: dict = False,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Metrics Services Query List\n\n    Args:\n        payload (dict, optional): additional parameters for the API.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_valueless_metrics (boolean optional): additional filter - parameter\n        extract_automata_domain (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        last_value_timestamp_start (string optional): additional filter - parameter\n        last_value_timestamp_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n       {\n        \"uuid_customer\": \"array\", optional\n        \"customer_code\": \"array\", optional\n        \"customer_status\": \"array\", optional\n        \"uuid_site\": \"array\", optional\n        \"site_code\": \"array\", optional\n        \"site_description\": \"array\", optional\n        \"site_address\": \"array\", optional\n        \"site_zip_code\": \"array\", optional\n        \"site_city\": \"array\", optional\n        \"site_country\": \"array\", optional\n        \"site_state_province\": \"array\", optional\n        \"site_status\": \"array\", optional\n        \"uuid_group\": \"array\", optional\n        \"group_uuid_virtual_domain\": \"array\", optional\n        \"group_name\": \"array\", optional\n        \"group_status\": \"array\", optional\n        \"group_type\": \"array\", optional\n        \"uuid_object\": \"array\", optional\n        \"object_name\": \"array\", optional\n        \"object_status\": \"array\", optional\n        \"object_profile\": \"array\", optional\n        \"uuid_metric_type\": \"array\", optional\n        \"metric_type_name\": \"array\", optional\n        \"metric_type_status\": \"array\", optional\n        \"uuid_metric\": \"array\", optional\n        \"metric_name\": \"array\", optional\n        \"metric_status\": \"array\", optional\n        \"metric_profile\": \"array\", optional\n        \"topic\": \"array\", optional\n        \"last_value_uuid_probe\": \"array\", optional\n        \"last_value_object_type\": \"array\", optional\n        \"last_value_name\": \"array\", optional\n        \"last_value_value\": \"array\", optional\n        \"last_value_unit\": \"array\", optional\n        \"last_value_description\": \"array\", optional\n        \"last_value_status\": \"array\", optional\n        \"last_value_ranking\": \"array\", optional\n        \"service_uuid_parent\": \"array\", optional\n        \"uuid_service\": \"array\", optional\n        \"service_profile\": \"array\", optional\n        \"service_name\": \"array\", optional\n        \"service_description\": \"array\", optional\n        \"service_status\": \"array\", optional\n        \"service_automata_domain\": \"array\", optional\n        \"service_uuid_customer\": \"array\", optional\n       }\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_valueless_metrics',\n        'extract_automata_domain', 'sort_by', 'null_fields',\n        'last_value_timestamp_start', 'last_value_timestamp_end',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('extract_valueless_metrics'), params.get(\n        'extract_automata_domain'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('last_value_timestamp_start'\n        ), params.get('last_value_timestamp_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_services_query_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/metrics/services/query',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer","title":"<code>metrics_topic_consumer(group, warm_start=False, kwargs=None, **params)</code>","text":"<p>Kafka Consumer</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>num_messages</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>compute_lag</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer(self, group: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Kafka Consumer\n\n    Args:\n        group (str, required): group\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        num_messages (integer optional): additional filter - parameter\n        compute_lag (boolean optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['num_messages', 'compute_lag']\n    params.get('num_messages'), params.get('compute_lag')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_topic_consumer.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/metrics/topic/consumer/{group}', warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer_create","title":"<code>metrics_topic_consumer_create(group, kwargs=None)</code>","text":"<p>Create Kafka Consumer</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer_create(self, group: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Create Kafka Consumer\n\n    Args:\n        group (str, required): group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/metrics/topic/consumer/{group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer_delete","title":"<code>metrics_topic_consumer_delete(group, kwargs=None)</code>","text":"<p>Delete Kafka Consumer</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer_delete(self, group: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Kafka Consumer\n\n    Args:\n        group (str, required): group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metrics/topic/consumer/{group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer_delete_group","title":"<code>metrics_topic_consumer_delete_group(group, kwargs=None)</code>","text":"<p>Bulk Delete Metrics Consumer Group</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer_delete_group(self, group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Metrics Consumer Group\n\n    Args:\n        group (str, required): group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/metrics/topic/consumer/{group}/delete', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer_filter_create","title":"<code>metrics_topic_consumer_filter_create(group, kwargs=None, **payload)</code>","text":"<p>Bulk Create Metrics Consumer Group</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid</code> <code>str required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer_filter_create(self, group: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Bulk Create Metrics Consumer Group\n\n    Args:\n        group (str, required): group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid (str required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid']\n    payload.get('uuid')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            metrics_topic_consumer_filter_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/metrics/topic/consumer/{group}/filter', payload=payload, **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer_lag","title":"<code>metrics_topic_consumer_lag(group, warm_start=False, kwargs=None)</code>","text":"<p>Get Lag Kafka Consumer</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer_lag(self, group: str,\n    warm_start: bool = False, kwargs: dict = None) -&gt; list:\n    \"\"\"Get Lag Kafka Consumer\n\n    Args:\n        group (str, required): group\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=\n        f'/metrics/topic/consumer/{group}/lag', warm_start=warm_start,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.metrics/#hive.cookbook.metrics.Metrics.metrics_topic_consumer_seek","title":"<code>metrics_topic_consumer_seek(group, warm_start=False, kwargs=None, **params)</code>","text":"<p>Seek Kafka Consumer</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>(str, required)</code> <p>group</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>offset</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>position</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/metrics.py</code> <pre><code>def metrics_topic_consumer_seek(self, group: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Seek Kafka Consumer\n\n    Args:\n        group (str, required): group\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        offset (integer optional): additional filter - parameter\n        position (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['offset', 'position']\n    params.get('offset'), params.get('position')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.metrics_topic_consumer_seek.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/metrics/topic/consumer/{group}/seek', warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.microsoft/","title":"Hive.cookbook.microsoft","text":""},{"location":"hive.cookbook.microsoft/#hive.cookbook.microsoft.Microsoft","title":"<code>Microsoft</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata microsoft APIs</p> Source code in <code>hive/cookbook/microsoft.py</code> <pre><code>class Microsoft(ApiManager):\n    \"\"\"Class that handles all the XAutomata microsoft APIs\"\"\"\n\n    def microsoft_login(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Microsoft Login\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/microsoft/login', warm_start\n            =warm_start, **kwargs)\n        return response\n\n    def microsoft_callback(self, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Microsoft Callback\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/microsoft/callback',\n            warm_start=warm_start, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.microsoft/#hive.cookbook.microsoft.Microsoft.microsoft_callback","title":"<code>microsoft_callback(warm_start=False, kwargs=None)</code>","text":"<p>Microsoft Callback</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/microsoft.py</code> <pre><code>def microsoft_callback(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Microsoft Callback\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/microsoft/callback',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.microsoft/#hive.cookbook.microsoft.Microsoft.microsoft_login","title":"<code>microsoft_login(warm_start=False, kwargs=None)</code>","text":"<p>Microsoft Login</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/microsoft.py</code> <pre><code>def microsoft_login(self, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Microsoft Login\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/microsoft/login', warm_start\n        =warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/","title":"Hive.cookbook.notification provider types","text":""},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes","title":"<code>NotificationProviderTypes</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata notification_provider_types APIs</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>class NotificationProviderTypes(ApiManager):\n    \"\"\"Class that handles all the XAutomata notification_provider_types APIs\"\"\"\n\n    def notification_provider_types(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Notification Provider Types\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            json_schema (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code',\n            'json_schema', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('json_schema'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_provider_types.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/notification_provider_types/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def notification_provider_types_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Notification Provider Type\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            json_schema (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'json_schema']\n        payload.get('code'), payload.get('json_schema')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                notification_provider_types_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=\n            f'/notification_provider_types/', payload=payload, **kwargs)\n        return response\n\n    def notification_provider_type(self, uuid: str,\n        warm_start: bool = False, kwargs: dict = None) -&gt; list:\n        \"\"\"Read Notification Provider Type\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=\n            f'/notification_provider_types/{uuid}', warm_start=warm_start,\n            **kwargs)\n        return response\n\n    def notification_provider_types_put(self, uuid: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Notification Provider Type\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            json_schema (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'json_schema']\n        payload.get('code'), payload.get('json_schema')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_provider_types_put.\n                __name__, payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/notification_provider_types/{uuid}', payload=payload, **kwargs)\n        return response\n\n    def notification_provider_types_delete(self, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Notification Provider Type\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/notification_provider_types/{uuid}', **kwargs)\n        return response\n\n    def notification_provider_types_notification_providers(self, uuid: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Notification Providers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                notification_provider_types_notification_providers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/notification_provider_types/{uuid}/notification_providers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def notification_provider_types_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Notification Provider Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_provider_types_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/notification_provider_types/bulk/read/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, payload=payload, **kwargs)\n        return response\n\n    def notification_provider_types_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Notification Provider Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"code\": \"string\", required\n            \"json_schema\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                notification_provider_types_create_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/notification_provider_types/bulk/create/', single_page=\n            single_page, page_size=page_size, params=params, payload=\n            payload, **kwargs)\n        return response\n\n    def notification_provider_types_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Notification Provider Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/notification_provider_types/bulk/delete/', single_page=\n            single_page, page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_type","title":"<code>notification_provider_type(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Notification Provider Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_type(self, uuid: str,\n    warm_start: bool = False, kwargs: dict = None) -&gt; list:\n    \"\"\"Read Notification Provider Type\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=\n        f'/notification_provider_types/{uuid}', warm_start=warm_start,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types","title":"<code>notification_provider_types(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Notification Provider Types</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>json_schema</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Notification Provider Types\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        json_schema (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code',\n        'json_schema', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('json_schema'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_provider_types.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/notification_provider_types/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_bulk","title":"<code>notification_provider_types_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Notification Provider Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Notification Provider Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_provider_types_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/notification_provider_types/bulk/read/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_create","title":"<code>notification_provider_types_create(kwargs=None, **payload)</code>","text":"<p>Create Notification Provider Type</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>json_schema</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Notification Provider Type\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        json_schema (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'json_schema']\n    payload.get('code'), payload.get('json_schema')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            notification_provider_types_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=\n        f'/notification_provider_types/', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_create_bulk","title":"<code>notification_provider_types_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Notification Provider Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"code\": \"string\", required     \"json_schema\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Notification Provider Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"code\": \"string\", required\n        \"json_schema\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            notification_provider_types_create_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/notification_provider_types/bulk/create/', single_page=\n        single_page, page_size=page_size, params=params, payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_delete","title":"<code>notification_provider_types_delete(uuid, kwargs=None)</code>","text":"<p>Delete Notification Provider Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_delete(self, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Notification Provider Type\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/notification_provider_types/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_delete_bulk","title":"<code>notification_provider_types_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Notification Provider Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Notification Provider Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/notification_provider_types/bulk/delete/', single_page=\n        single_page, page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_notification_providers","title":"<code>notification_provider_types_notification_providers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Notification Providers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_notification_providers(self, uuid: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Notification Providers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            notification_provider_types_notification_providers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/notification_provider_types/{uuid}/notification_providers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_provider_types/#hive.cookbook.notification_provider_types.NotificationProviderTypes.notification_provider_types_put","title":"<code>notification_provider_types_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Notification Provider Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>json_schema</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_provider_types.py</code> <pre><code>def notification_provider_types_put(self, uuid: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Notification Provider Type\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        json_schema (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'json_schema']\n    payload.get('code'), payload.get('json_schema')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_provider_types_put.\n            __name__, payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/notification_provider_types/{uuid}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/","title":"Hive.cookbook.notification providers","text":""},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders","title":"<code>NotificationProviders</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata notification_providers APIs</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>class NotificationProviders(ApiManager):\n    \"\"\"Class that handles all the XAutomata notification_providers APIs\"\"\"\n\n    def notification_providers(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Notification Providers\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            app_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'app_name',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('app_name'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_providers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/notification_providers/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def notification_providers_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Notification Provider\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_notification_provider_type (string required): additional filter - payload\n            app_name (string required): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_notification_provider_type',\n            'app_name', 'endpoint']\n        payload.get('uuid_notification_provider_type'), payload.get('app_name'\n            ), payload.get('endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_providers_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/notification_providers/',\n            payload=payload, **kwargs)\n        return response\n\n    def notification_provider(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Notification Provider\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=\n            f'/notification_providers/{uuid}', warm_start=warm_start, **kwargs)\n        return response\n\n    def notification_providers_put(self, uuid: str, kwargs: dict = None, **\n        payload) -&gt; list:\n        \"\"\"Update Notification Provider\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_notification_provider_type (string optional): additional filter - payload\n            app_name (string optional): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_notification_provider_type',\n            'app_name', 'endpoint']\n        payload.get('uuid_notification_provider_type'), payload.get('app_name'\n            ), payload.get('endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_providers_put.\n                __name__, payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/notification_providers/{uuid}', payload=payload, **kwargs)\n        return response\n\n    def notification_providers_delete(self, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Notification Provider\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/notification_providers/{uuid}', **kwargs)\n        return response\n\n    def notification_providers_dispatchers(self, uuid: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Notification Provider Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'tag', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('tag'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                notification_providers_dispatchers.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/notification_providers/{uuid}/dispatchers', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def notification_providers_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Notification Providers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.notification_providers_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/notification_providers/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def notification_providers_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Notification Providers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_notification_provider_type\": \"string\", required\n            \"app_name\": \"string\", required\n            \"endpoint\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                notification_providers_create_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/notification_providers/bulk/create/', single_page=\n            single_page, page_size=page_size, params=params, payload=\n            payload, **kwargs)\n        return response\n\n    def notification_providers_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Notification Providers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/notification_providers/bulk/delete/', single_page=\n            single_page, page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_provider","title":"<code>notification_provider(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Notification Provider</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_provider(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Notification Provider\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=\n        f'/notification_providers/{uuid}', warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers","title":"<code>notification_providers(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Notification Providers</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>app_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Notification Providers\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        app_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'app_name',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('app_name'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_providers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/notification_providers/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_bulk","title":"<code>notification_providers_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Notification Providers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Notification Providers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_providers_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/notification_providers/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_create","title":"<code>notification_providers_create(kwargs=None, **payload)</code>","text":"<p>Create Notification Provider</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_notification_provider_type</code> <code>string required</code> <p>additional filter - payload</p> <code>app_name</code> <code>string required</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Notification Provider\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_notification_provider_type (string required): additional filter - payload\n        app_name (string required): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_notification_provider_type',\n        'app_name', 'endpoint']\n    payload.get('uuid_notification_provider_type'), payload.get('app_name'\n        ), payload.get('endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_providers_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/notification_providers/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_create_bulk","title":"<code>notification_providers_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Notification Providers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_notification_provider_type\": \"string\", required     \"app_name\": \"string\", required     \"endpoint\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Notification Providers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_notification_provider_type\": \"string\", required\n        \"app_name\": \"string\", required\n        \"endpoint\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            notification_providers_create_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/notification_providers/bulk/create/', single_page=\n        single_page, page_size=page_size, params=params, payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_delete","title":"<code>notification_providers_delete(uuid, kwargs=None)</code>","text":"<p>Delete Notification Provider</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_delete(self, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Notification Provider\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/notification_providers/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_delete_bulk","title":"<code>notification_providers_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Notification Providers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Notification Providers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/notification_providers/bulk/delete/', single_page=\n        single_page, page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_dispatchers","title":"<code>notification_providers_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Notification Provider Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_dispatchers(self, uuid: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Notification Provider Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'tag', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('tag'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            notification_providers_dispatchers.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/notification_providers/{uuid}/dispatchers', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.notification_providers/#hive.cookbook.notification_providers.NotificationProviders.notification_providers_put","title":"<code>notification_providers_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Notification Provider</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_notification_provider_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>app_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/notification_providers.py</code> <pre><code>def notification_providers_put(self, uuid: str, kwargs: dict = None, **\n    payload) -&gt; list:\n    \"\"\"Update Notification Provider\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_notification_provider_type (string optional): additional filter - payload\n        app_name (string optional): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_notification_provider_type',\n        'app_name', 'endpoint']\n    payload.get('uuid_notification_provider_type'), payload.get('app_name'\n        ), payload.get('endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.notification_providers_put.\n            __name__, payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/notification_providers/{uuid}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/","title":"Hive.cookbook.objects","text":""},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects","title":"<code>Objects</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata objects APIs</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>class Objects(ApiManager):\n    \"\"\"Class that handles all the XAutomata objects APIs\"\"\"\n\n    def objects(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Objects\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            feedback_for_operator (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            count_children (boolean optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            ip_cidr (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'name', 'description', 'feedback_for_operator', 'profile',\n            'status', 'extract_severity', 'count_children', 'severity',\n            'ip_cidr', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('name'), params.get('description'\n            ), params.get('feedback_for_operator'), params.get('profile'\n            ), params.get('status'), params.get('extract_severity'\n            ), params.get('count_children'), params.get('severity'\n            ), params.get('ip_cidr'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/objects/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def objects_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Object\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            feedback_for_operator (string optional): additional filter - payload\n            ip_cidr (array object optional): additional filter - payload\n            profile (string required): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'description',\n            'feedback_for_operator', 'ip_cidr', 'profile', 'data_profile',\n            'automata_domain', 'status']\n        payload.get('name'), payload.get('description'), payload.get(\n            'feedback_for_operator'), payload.get('ip_cidr'), payload.get(\n            'profile'), payload.get('data_profile'), payload.get(\n            'automata_domain'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/objects/', payload=payload,\n            **kwargs)\n        return response\n\n    def object(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Object\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/objects/{uuid}', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def objects_put(self, uuid: str, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Object\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_probe (string optional): additional filter - parameter\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            feedback_for_operator (string optional): additional filter - payload\n            ip_cidr (array object optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'description',\n            'feedback_for_operator', 'ip_cidr', 'profile', 'data_profile',\n            'automata_domain', 'status']\n        payload.get('name'), payload.get('description'), payload.get(\n            'feedback_for_operator'), payload.get('ip_cidr'), payload.get(\n            'profile'), payload.get('data_profile'), payload.get(\n            'automata_domain'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/objects/{uuid}', params=\n            params, payload=payload, **kwargs)\n        return response\n\n    def objects_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Object\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/objects/{uuid}', **kwargs)\n        return response\n\n    def objects_metric_types(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metric Types\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_metric_types.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/objects/{uuid}/metric_types',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def objects_hosted(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Hosteds\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_hosted.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/objects/{uuid}/hosted',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def objects_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            count_children (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'count_children', 'name',\n            'status', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('count_children'), params.get('name'\n            ), params.get('status'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/objects/{uuid}/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def objects_groups_create(self, uuid: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/objects/{uuid}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def objects_groups_delete(self, uuid: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/objects/{uuid}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def objects_probes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Probes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_probes.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/objects/{uuid}/probes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def objects_probes_create(self, uuid: str, uuid_probe: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Probe\n\n        Args:\n            uuid (str, required): uuid\n            uuid_probe (str, required): uuid_probe\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/objects/{uuid}/probes/{uuid_probe}', **kwargs)\n        return response\n\n    def objects_probes_delete(self, uuid: str, uuid_probe: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Probe\n\n        Args:\n            uuid (str, required): uuid\n            uuid_probe (str, required): uuid_probe\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/objects/{uuid}/probes/{uuid_probe}', **kwargs)\n        return response\n\n    def objects_downtimes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status',\n            'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('active_at_timestamp'), params.get(\n            'active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_downtimes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/objects/{uuid}/downtimes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def objects_downtimes_create(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/objects/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def objects_downtimes_delete(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/objects/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def objects_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status',\n            'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('active_at_timestamp'), params.get(\n            'active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('tag'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/objects/{uuid}/dispatchers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def objects_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/objects/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def objects_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/objects/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def objects_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/objects/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def objects_read_by_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read By Name\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"name\": \"string\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_read_by_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/objects/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def objects_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Objects With Relationship\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"name\": \"string\", required\n            \"description\": \"string\", optional\n            \"feedback_for_operator\": \"string\", optional\n            \"ip_cidr\": \"array object\", optional\n            \"profile\": \"string\", required\n            \"data_profile\": \"array object\", optional\n            \"automata_domain\": \"array object\", optional\n            \"status\": \"string\", required\n            \"uuid_groups\": \"array\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/objects/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def objects_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/objects/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def objects_groups_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_group\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_groups_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/objects/bulk/create/groups',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def objects_groups_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_group\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/objects/bulk/delete/groups',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def objects_downtimes_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['code', 'status', 'active_at_timestamp',\n            'active_after_timestamp', 'active_at_or_after_timestamp',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('code'), params.get('status'), params.get(\n            'active_at_timestamp'), params.get('active_after_timestamp'\n            ), params.get('active_at_or_after_timestamp'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_downtimes_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/objects/bulk/read/downtimes', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def objects_downtimes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_downtimes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/objects/bulk/create/downtimes', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def objects_downtimes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_object\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/objects/bulk/delete/downtimes', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def objects_probes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_object\": \"string\", required\n            \"uuid_probe\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.objects_probes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/objects/bulk/create/probes',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def objects_probes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_object\": \"string\", required\n            \"uuid_probe\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/objects/bulk/delete/probes',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.object","title":"<code>object(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def object(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Object\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/objects/{uuid}', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects","title":"<code>objects(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Objects</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>count_children</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ip_cidr</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Objects\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        feedback_for_operator (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        count_children (boolean optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        ip_cidr (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'name', 'description', 'feedback_for_operator', 'profile',\n        'status', 'extract_severity', 'count_children', 'severity',\n        'ip_cidr', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('name'), params.get('description'\n        ), params.get('feedback_for_operator'), params.get('profile'\n        ), params.get('status'), params.get('extract_severity'\n        ), params.get('count_children'), params.get('severity'\n        ), params.get('ip_cidr'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/objects/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_bulk","title":"<code>objects_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/objects/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_create","title":"<code>objects_create(kwargs=None, **payload)</code>","text":"<p>Create Object</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - payload</p> <code>ip_cidr</code> <code>array object optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Object\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        feedback_for_operator (string optional): additional filter - payload\n        ip_cidr (array object optional): additional filter - payload\n        profile (string required): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'description',\n        'feedback_for_operator', 'ip_cidr', 'profile', 'data_profile',\n        'automata_domain', 'status']\n    payload.get('name'), payload.get('description'), payload.get(\n        'feedback_for_operator'), payload.get('ip_cidr'), payload.get(\n        'profile'), payload.get('data_profile'), payload.get(\n        'automata_domain'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/objects/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_create_bulk","title":"<code>objects_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Objects With Relationship</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"name\": \"string\", required     \"description\": \"string\", optional     \"feedback_for_operator\": \"string\", optional     \"ip_cidr\": \"array object\", optional     \"profile\": \"string\", required     \"data_profile\": \"array object\", optional     \"automata_domain\": \"array object\", optional     \"status\": \"string\", required     \"uuid_groups\": \"array\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Objects With Relationship\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"name\": \"string\", required\n        \"description\": \"string\", optional\n        \"feedback_for_operator\": \"string\", optional\n        \"ip_cidr\": \"array object\", optional\n        \"profile\": \"string\", required\n        \"data_profile\": \"array object\", optional\n        \"automata_domain\": \"array object\", optional\n        \"status\": \"string\", required\n        \"uuid_groups\": \"array\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/objects/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_delete","title":"<code>objects_delete(uuid, kwargs=None)</code>","text":"<p>Delete Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Object\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/objects/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_delete_bulk","title":"<code>objects_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/objects/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_dispatchers","title":"<code>objects_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status',\n        'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'tag', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('active_at_timestamp'), params.get(\n        'active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('tag'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/objects/{uuid}/dispatchers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_dispatchers_create","title":"<code>objects_dispatchers_create(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Add Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/objects/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_dispatchers_delete","title":"<code>objects_dispatchers_delete(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Remove Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/objects/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_downtimes","title":"<code>objects_downtimes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_downtimes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status',\n        'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('active_at_timestamp'), params.get(\n        'active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_downtimes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/objects/{uuid}/downtimes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_downtimes_bulk","title":"<code>objects_downtimes_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_downtimes_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['code', 'status', 'active_at_timestamp',\n        'active_after_timestamp', 'active_at_or_after_timestamp',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('code'), params.get('status'), params.get(\n        'active_at_timestamp'), params.get('active_after_timestamp'\n        ), params.get('active_at_or_after_timestamp'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_downtimes_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/objects/bulk/read/downtimes', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_downtimes_create","title":"<code>objects_downtimes_create(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Add Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_downtimes_create(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/objects/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_downtimes_create_bulk","title":"<code>objects_downtimes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_downtimes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_downtimes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/objects/bulk/create/downtimes', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_downtimes_delete","title":"<code>objects_downtimes_delete(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Remove Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_downtimes_delete(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/objects/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_downtimes_delete_bulk","title":"<code>objects_downtimes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_downtimes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/objects/bulk/delete/downtimes', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_groups","title":"<code>objects_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>count_children</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        count_children (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'count_children', 'name',\n        'status', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('count_children'), params.get('name'\n        ), params.get('status'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/objects/{uuid}/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_groups_create","title":"<code>objects_groups_create(uuid, uuid_group, kwargs=None)</code>","text":"<p>Add Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_groups_create(self, uuid: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/objects/{uuid}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_groups_create_bulk","title":"<code>objects_groups_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_group\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_groups_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_group\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_groups_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/objects/bulk/create/groups',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_groups_delete","title":"<code>objects_groups_delete(uuid, uuid_group, kwargs=None)</code>","text":"<p>Remove Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_groups_delete(self, uuid: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/objects/{uuid}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_groups_delete_bulk","title":"<code>objects_groups_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_group\": \"string\", required     \"uuid_object\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_groups_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_group\": \"string\", required\n        \"uuid_object\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/objects/bulk/delete/groups',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_hosted","title":"<code>objects_hosted(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Hosteds</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_hosted(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Hosteds\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_hosted.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/objects/{uuid}/hosted',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_metric_types","title":"<code>objects_metric_types(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_metric_types(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metric Types\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_metric_types.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/objects/{uuid}/metric_types',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_probes","title":"<code>objects_probes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Probes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_probes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Probes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_probes.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/objects/{uuid}/probes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_probes_create","title":"<code>objects_probes_create(uuid, uuid_probe, kwargs=None)</code>","text":"<p>Add Probe</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_probe</code> <code>(str, required)</code> <p>uuid_probe</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_probes_create(self, uuid: str, uuid_probe: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Probe\n\n    Args:\n        uuid (str, required): uuid\n        uuid_probe (str, required): uuid_probe\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/objects/{uuid}/probes/{uuid_probe}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_probes_create_bulk","title":"<code>objects_probes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_object\": \"string\", required     \"uuid_probe\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_probes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_object\": \"string\", required\n        \"uuid_probe\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_probes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/objects/bulk/create/probes',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_probes_delete","title":"<code>objects_probes_delete(uuid, uuid_probe, kwargs=None)</code>","text":"<p>Remove Probe</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_probe</code> <code>(str, required)</code> <p>uuid_probe</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_probes_delete(self, uuid: str, uuid_probe: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Probe\n\n    Args:\n        uuid (str, required): uuid\n        uuid_probe (str, required): uuid_probe\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/objects/{uuid}/probes/{uuid_probe}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_probes_delete_bulk","title":"<code>objects_probes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_object\": \"string\", required     \"uuid_probe\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_probes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_object\": \"string\", required\n        \"uuid_probe\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/objects/bulk/delete/probes',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_put","title":"<code>objects_put(uuid, params=False, kwargs=None, **payload)</code>","text":"<p>Update Object</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_probe</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>feedback_for_operator</code> <code>string optional</code> <p>additional filter - payload</p> <code>ip_cidr</code> <code>array object optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_put(self, uuid: str, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Object\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_probe (string optional): additional filter - parameter\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        feedback_for_operator (string optional): additional filter - payload\n        ip_cidr (array object optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'description',\n        'feedback_for_operator', 'ip_cidr', 'profile', 'data_profile',\n        'automata_domain', 'status']\n    payload.get('name'), payload.get('description'), payload.get(\n        'feedback_for_operator'), payload.get('ip_cidr'), payload.get(\n        'profile'), payload.get('data_profile'), payload.get(\n        'automata_domain'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/objects/{uuid}', params=\n        params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.objects/#hive.cookbook.objects.Objects.objects_read_by_bulk","title":"<code>objects_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read By Name</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"name\": \"string\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/objects.py</code> <pre><code>def objects_read_by_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read By Name\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"name\": \"string\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.objects_read_by_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/objects/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/","title":"Hive.cookbook.opening reasons","text":""},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons","title":"<code>OpeningReasons</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata opening_reasons APIs</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>class OpeningReasons(ApiManager):\n    \"\"\"Class that handles all the XAutomata opening_reasons APIs\"\"\"\n\n    def opening_reasons(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Opening Reasons\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            sla_l1 (integer optional): additional filter - parameter\n            sla_l2 (integer optional): additional filter - parameter\n            sla_l3 (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code',\n            'description', 'severity', 'sla_l1', 'sla_l2', 'sla_l3', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('description'), params.get('severity'), params.get(\n            'sla_l1'), params.get('sla_l2'), params.get('sla_l3'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.opening_reasons.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/opening_reasons/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def opening_reasons_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Opening Reason\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            severity (string required): additional filter - payload\n            sla_l1 (integer required): additional filter - payload\n            sla_l2 (integer required): additional filter - payload\n            sla_l3 (integer required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'severity',\n            'sla_l1', 'sla_l2', 'sla_l3']\n        payload.get('code'), payload.get('description'), payload.get('severity'\n            ), payload.get('sla_l1'), payload.get('sla_l2'), payload.get(\n            'sla_l3')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.opening_reasons_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/opening_reasons/', payload=\n            payload, **kwargs)\n        return response\n\n    def opening_reason(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Opening Reason\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/opening_reasons/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def opening_reasons_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Opening Reason\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            severity (string optional): additional filter - payload\n            sla_l1 (integer optional): additional filter - payload\n            sla_l2 (integer optional): additional filter - payload\n            sla_l3 (integer optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'severity',\n            'sla_l1', 'sla_l2', 'sla_l3']\n        payload.get('code'), payload.get('description'), payload.get('severity'\n            ), payload.get('sla_l1'), payload.get('sla_l2'), payload.get(\n            'sla_l3')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.opening_reasons_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/opening_reasons/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def opening_reasons_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Opening Reason\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/opening_reasons/{uuid}',\n            **kwargs)\n        return response\n\n    def opening_reasons_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Opening Reasons\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.opening_reasons_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/opening_reasons/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def opening_reasons_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Opening Reasons\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"code\": \"string\", required\n            \"description\": \"string\", optional\n            \"severity\": \"string\", required\n            \"sla_l1\": \"integer\", required\n            \"sla_l2\": \"integer\", required\n            \"sla_l3\": \"integer\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.opening_reasons_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/opening_reasons/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def opening_reasons_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Opening Reasons\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/opening_reasons/bulk/delete/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reason","title":"<code>opening_reason(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Opening Reason</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reason(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Opening Reason\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/opening_reasons/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons","title":"<code>opening_reasons(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Opening Reasons</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sla_l1</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>sla_l2</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>sla_l3</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Opening Reasons\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        sla_l1 (integer optional): additional filter - parameter\n        sla_l2 (integer optional): additional filter - parameter\n        sla_l3 (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code',\n        'description', 'severity', 'sla_l1', 'sla_l2', 'sla_l3', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('description'), params.get('severity'), params.get(\n        'sla_l1'), params.get('sla_l2'), params.get('sla_l3'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.opening_reasons.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/opening_reasons/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons_bulk","title":"<code>opening_reasons_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Opening Reasons</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Opening Reasons\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.opening_reasons_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/opening_reasons/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons_create","title":"<code>opening_reasons_create(kwargs=None, **payload)</code>","text":"<p>Create Opening Reason</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>severity</code> <code>string required</code> <p>additional filter - payload</p> <code>sla_l1</code> <code>integer required</code> <p>additional filter - payload</p> <code>sla_l2</code> <code>integer required</code> <p>additional filter - payload</p> <code>sla_l3</code> <code>integer required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Opening Reason\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        severity (string required): additional filter - payload\n        sla_l1 (integer required): additional filter - payload\n        sla_l2 (integer required): additional filter - payload\n        sla_l3 (integer required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'severity',\n        'sla_l1', 'sla_l2', 'sla_l3']\n    payload.get('code'), payload.get('description'), payload.get('severity'\n        ), payload.get('sla_l1'), payload.get('sla_l2'), payload.get(\n        'sla_l3')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.opening_reasons_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/opening_reasons/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons_create_bulk","title":"<code>opening_reasons_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Opening Reasons</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"code\": \"string\", required     \"description\": \"string\", optional     \"severity\": \"string\", required     \"sla_l1\": \"integer\", required     \"sla_l2\": \"integer\", required     \"sla_l3\": \"integer\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Opening Reasons\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"code\": \"string\", required\n        \"description\": \"string\", optional\n        \"severity\": \"string\", required\n        \"sla_l1\": \"integer\", required\n        \"sla_l2\": \"integer\", required\n        \"sla_l3\": \"integer\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.opening_reasons_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/opening_reasons/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons_delete","title":"<code>opening_reasons_delete(uuid, kwargs=None)</code>","text":"<p>Delete Opening Reason</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Opening Reason\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/opening_reasons/{uuid}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons_delete_bulk","title":"<code>opening_reasons_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Opening Reasons</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Opening Reasons\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/opening_reasons/bulk/delete/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.opening_reasons/#hive.cookbook.opening_reasons.OpeningReasons.opening_reasons_put","title":"<code>opening_reasons_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Opening Reason</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>severity</code> <code>string optional</code> <p>additional filter - payload</p> <code>sla_l1</code> <code>integer optional</code> <p>additional filter - payload</p> <code>sla_l2</code> <code>integer optional</code> <p>additional filter - payload</p> <code>sla_l3</code> <code>integer optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/opening_reasons.py</code> <pre><code>def opening_reasons_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Opening Reason\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        severity (string optional): additional filter - payload\n        sla_l1 (integer optional): additional filter - payload\n        sla_l2 (integer optional): additional filter - payload\n        sla_l3 (integer optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'severity',\n        'sla_l1', 'sla_l2', 'sla_l3']\n    payload.get('code'), payload.get('description'), payload.get('severity'\n        ), payload.get('sla_l1'), payload.get('sla_l2'), payload.get(\n        'sla_l3')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.opening_reasons_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/opening_reasons/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/","title":"Hive.cookbook.probe types","text":""},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes","title":"<code>ProbeTypes</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata probe_types APIs</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>class ProbeTypes(ApiManager):\n    \"\"\"Class that handles all the XAutomata probe_types APIs\"\"\"\n\n    def probe_types(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Probe Types\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            app_code (string optional): additional filter - parameter\n            app_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'app_code',\n            'app_name', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('app_code'\n            ), params.get('app_name'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe_types.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/probe_types/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def probe_types_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Probe Type\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            app_code (string required): additional filter - payload\n            app_name (string optional): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['app_code', 'app_name', 'endpoint']\n        payload.get('app_code'), payload.get('app_name'), payload.get(\n            'endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe_types_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/probe_types/', payload=\n            payload, **kwargs)\n        return response\n\n    def probe_type(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Probe Type\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/probe_types/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def probe_types_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Probe Type\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            app_code (string optional): additional filter - payload\n            app_name (string optional): additional filter - payload\n            endpoint (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['app_code', 'app_name', 'endpoint']\n        payload.get('app_code'), payload.get('app_name'), payload.get(\n            'endpoint')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe_types_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/probe_types/{uuid}', payload\n            =payload, **kwargs)\n        return response\n\n    def probe_types_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Probe Type\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/probe_types/{uuid}', **kwargs\n            )\n        return response\n\n    def probe_types_probes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Probes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_severity', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('extract_severity'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe_types_probes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/probe_types/{uuid}/probes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def probe_types_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Probe Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe_types_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/probe_types/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def probe_types_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Probe Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"app_code\": \"string\", required\n            \"app_name\": \"string\", optional\n            \"endpoint\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe_types_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/probe_types/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def probe_types_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Probe Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/probe_types/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_type","title":"<code>probe_type(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Probe Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_type(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Probe Type\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/probe_types/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types","title":"<code>probe_types(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Probe Types</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>app_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>app_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Probe Types\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        app_code (string optional): additional filter - parameter\n        app_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'app_code',\n        'app_name', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('app_code'\n        ), params.get('app_name'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe_types.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/probe_types/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_bulk","title":"<code>probe_types_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Probe Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Probe Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe_types_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/probe_types/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_create","title":"<code>probe_types_create(kwargs=None, **payload)</code>","text":"<p>Create Probe Type</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_code</code> <code>string required</code> <p>additional filter - payload</p> <code>app_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Probe Type\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        app_code (string required): additional filter - payload\n        app_name (string optional): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['app_code', 'app_name', 'endpoint']\n    payload.get('app_code'), payload.get('app_name'), payload.get(\n        'endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe_types_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/probe_types/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_create_bulk","title":"<code>probe_types_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Probe Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"app_code\": \"string\", required     \"app_name\": \"string\", optional     \"endpoint\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Probe Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"app_code\": \"string\", required\n        \"app_name\": \"string\", optional\n        \"endpoint\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe_types_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/probe_types/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_delete","title":"<code>probe_types_delete(uuid, kwargs=None)</code>","text":"<p>Delete Probe Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Probe Type\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/probe_types/{uuid}', **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_delete_bulk","title":"<code>probe_types_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Probe Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Probe Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/probe_types/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_probes","title":"<code>probe_types_probes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Probes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_probes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Probes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_severity', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('extract_severity'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe_types_probes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/probe_types/{uuid}/probes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probe_types/#hive.cookbook.probe_types.ProbeTypes.probe_types_put","title":"<code>probe_types_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Probe Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>app_name</code> <code>string optional</code> <p>additional filter - payload</p> <code>endpoint</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probe_types.py</code> <pre><code>def probe_types_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Probe Type\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        app_code (string optional): additional filter - payload\n        app_name (string optional): additional filter - payload\n        endpoint (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['app_code', 'app_name', 'endpoint']\n    payload.get('app_code'), payload.get('app_name'), payload.get(\n        'endpoint')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe_types_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/probe_types/{uuid}', payload\n        =payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/","title":"Hive.cookbook.probes","text":""},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes","title":"<code>Probes</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata probes APIs</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>class Probes(ApiManager):\n    \"\"\"Class that handles all the XAutomata probes APIs\"\"\"\n\n    def probes(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Probes\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            uuid_probe_type (string optional): additional filter - parameter\n            uuid_host (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            notes (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            extract_last_status (boolean optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'uuid_virtual_domain', 'uuid_probe_type', 'uuid_host', 'name',\n            'description', 'notes', 'status', 'extract_severity',\n            'extract_last_status', 'severity', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('uuid_virtual_domain'), params.get(\n            'uuid_probe_type'), params.get('uuid_host'), params.get('name'\n            ), params.get('description'), params.get('notes'), params.get(\n            'status'), params.get('extract_severity'), params.get(\n            'extract_last_status'), params.get('severity'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/probes/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def probes_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Probe\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_virtual_domain (string required): additional filter - payload\n            uuid_probe_type (string required): additional filter - payload\n            uuid_host (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            data_profile (array object required): additional filter - payload\n            notes (string optional): additional filter - payload\n            status (string required): additional filter - payload\n            data_profile_backup (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_virtual_domain', 'uuid_probe_type',\n            'uuid_host', 'name', 'description', 'data_profile', 'notes',\n            'status', 'data_profile_backup']\n        payload.get('uuid_virtual_domain'), payload.get('uuid_probe_type'\n            ), payload.get('uuid_host'), payload.get('name'), payload.get(\n            'description'), payload.get('data_profile'), payload.get('notes'\n            ), payload.get('status'), payload.get('data_profile_backup')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/probes/', payload=payload,\n            **kwargs)\n        return response\n\n    def probe(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Probe\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join', 'extract_severity']\n        params.get('join'), params.get('extract_severity')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probe.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/probes/{uuid}', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def probes_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Probe\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_virtual_domain (string optional): additional filter - payload\n            uuid_probe_type (string optional): additional filter - payload\n            uuid_host (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            data_profile (array object optional): additional filter - payload\n            notes (string optional): additional filter - payload\n            status (string optional): additional filter - payload\n            data_profile_backup (array object optional): additional filter - payload\n            last_seen (string optional): additional filter - payload\n            ingest_frequency (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_virtual_domain', 'uuid_probe_type',\n            'uuid_host', 'name', 'description', 'data_profile', 'notes',\n            'status', 'data_profile_backup', 'last_seen', 'ingest_frequency']\n        payload.get('uuid_virtual_domain'), payload.get('uuid_probe_type'\n            ), payload.get('uuid_host'), payload.get('name'), payload.get(\n            'description'), payload.get('data_profile'), payload.get('notes'\n            ), payload.get('status'), payload.get('data_profile_backup'\n            ), payload.get('last_seen'), payload.get('ingest_frequency')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/probes/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def probes_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Probe\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/probes/{uuid}', **kwargs)\n        return response\n\n    def probes_agent_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Agent Update Probe\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            password (string optional): additional filter - payload\n            phone (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            email (string optional): additional filter - payload\n            stage (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n            acl (object optional): additional filter - payload\n            uuid_acl_override (string optional): additional filter - payload\n            verified_email (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['password', 'phone', 'profile', 'email',\n            'stage', 'active', 'acl', 'uuid_acl_override', 'verified_email']\n        payload.get('password'), payload.get('phone'), payload.get('profile'\n            ), payload.get('email'), payload.get('stage'), payload.get('active'\n            ), payload.get('acl'), payload.get('uuid_acl_override'\n            ), payload.get('verified_email')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_agent_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/probes/agent/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def probes_objects(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Objects\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'profile',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('profile'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_objects.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/probes/{uuid}/objects',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def probes_objects_create(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/probes/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def probes_objects_delete(self, uuid: str, uuid_object: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_object (str, required): uuid_object\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/probes/{uuid}/objects/{uuid_object}', **kwargs)\n        return response\n\n    def probes_metric_types(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metric Types\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_metric_types.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/probes/{uuid}/metric_types',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def probes_metric_types_create(self, uuid: str, uuid_metric_type: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric_type (str, required): uuid_metric_type\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/probes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n        return response\n\n    def probes_metric_types_delete(self, uuid: str, uuid_metric_type: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric Type\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric_type (str, required): uuid_metric_type\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/probes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n        return response\n\n    def probes_metrics(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metrics\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'profile',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('profile'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_metrics.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/probes/{uuid}/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def probes_metrics_create(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/probes/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def probes_metrics_delete(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/probes/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def probes_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/probes/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def probes_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_virtual_domain\": \"string\", required\n            \"uuid_probe_type\": \"string\", required\n            \"uuid_host\": \"string\", required\n            \"name\": \"string\", required\n            \"description\": \"string\", optional\n            \"data_profile\": \"array object\", required\n            \"notes\": \"string\", optional\n            \"status\": \"string\", required\n            \"data_profile_backup\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/probes/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def probes_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Probes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/probes/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def probes_objects_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_object\": \"string\", required\n            \"uuid_probe\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_objects_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/probes/bulk/create/objects',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def probes_objects_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Objects\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_object\": \"string\", required\n            \"uuid_probe\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/probes/bulk/delete/objects',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def probes_metric_types_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_metric_types_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/probes/bulk/create/metric_types', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def probes_metric_types_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metric Types\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric_type\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/probes/bulk/delete/metric_types', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def probes_metrics_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_metrics_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/probes/bulk/create/metrics',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def probes_metrics_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_probe\": \"string\", required\n            \"uuid_metric\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/probes/bulk/delete/metrics',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def probes_logs(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Consume Probe Log\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            key (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'key']\n        params.get('skip'), params.get('limit'), params.get('key')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_logs.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/probes/{uuid}/logs',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def probes_customers_create(self, uuid: str, kwargs: dict = None, **params\n        ) -&gt; list:\n        \"\"\"Create Probe User Customers Relationship\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            replace (boolean optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['replace']\n        params.get('replace')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_customers_create.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/probes/{uuid}/customers',\n            params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probe","title":"<code>probe(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Probe</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probe(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Probe\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join', 'extract_severity']\n    params.get('join'), params.get('extract_severity')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probe.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/probes/{uuid}', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes","title":"<code>probes(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Probes</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_probe_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_host</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>notes</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>extract_last_status</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Probes\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        uuid_probe_type (string optional): additional filter - parameter\n        uuid_host (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        notes (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        extract_last_status (boolean optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'uuid_virtual_domain', 'uuid_probe_type', 'uuid_host', 'name',\n        'description', 'notes', 'status', 'extract_severity',\n        'extract_last_status', 'severity', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('uuid_virtual_domain'), params.get(\n        'uuid_probe_type'), params.get('uuid_host'), params.get('name'\n        ), params.get('description'), params.get('notes'), params.get(\n        'status'), params.get('extract_severity'), params.get(\n        'extract_last_status'), params.get('severity'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/probes/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_agent_put","title":"<code>probes_agent_put(uuid, kwargs=None, **payload)</code>","text":"<p>Agent Update Probe</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>password</code> <code>string optional</code> <p>additional filter - payload</p> <code>phone</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>email</code> <code>string optional</code> <p>additional filter - payload</p> <code>stage</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>acl</code> <code>object optional</code> <p>additional filter - payload</p> <code>uuid_acl_override</code> <code>string optional</code> <p>additional filter - payload</p> <code>verified_email</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_agent_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Agent Update Probe\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        password (string optional): additional filter - payload\n        phone (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        email (string optional): additional filter - payload\n        stage (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n        acl (object optional): additional filter - payload\n        uuid_acl_override (string optional): additional filter - payload\n        verified_email (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['password', 'phone', 'profile', 'email',\n        'stage', 'active', 'acl', 'uuid_acl_override', 'verified_email']\n    payload.get('password'), payload.get('phone'), payload.get('profile'\n        ), payload.get('email'), payload.get('stage'), payload.get('active'\n        ), payload.get('acl'), payload.get('uuid_acl_override'\n        ), payload.get('verified_email')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_agent_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/probes/agent/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_bulk","title":"<code>probes_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/probes/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_create","title":"<code>probes_create(kwargs=None, **payload)</code>","text":"<p>Create Probe</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_virtual_domain</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_probe_type</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_host</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object required</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile_backup</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Probe\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_virtual_domain (string required): additional filter - payload\n        uuid_probe_type (string required): additional filter - payload\n        uuid_host (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        data_profile (array object required): additional filter - payload\n        notes (string optional): additional filter - payload\n        status (string required): additional filter - payload\n        data_profile_backup (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_virtual_domain', 'uuid_probe_type',\n        'uuid_host', 'name', 'description', 'data_profile', 'notes',\n        'status', 'data_profile_backup']\n    payload.get('uuid_virtual_domain'), payload.get('uuid_probe_type'\n        ), payload.get('uuid_host'), payload.get('name'), payload.get(\n        'description'), payload.get('data_profile'), payload.get('notes'\n        ), payload.get('status'), payload.get('data_profile_backup')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/probes/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_create_bulk","title":"<code>probes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_virtual_domain\": \"string\", required     \"uuid_probe_type\": \"string\", required     \"uuid_host\": \"string\", required     \"name\": \"string\", required     \"description\": \"string\", optional     \"data_profile\": \"array object\", required     \"notes\": \"string\", optional     \"status\": \"string\", required     \"data_profile_backup\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_virtual_domain\": \"string\", required\n        \"uuid_probe_type\": \"string\", required\n        \"uuid_host\": \"string\", required\n        \"name\": \"string\", required\n        \"description\": \"string\", optional\n        \"data_profile\": \"array object\", required\n        \"notes\": \"string\", optional\n        \"status\": \"string\", required\n        \"data_profile_backup\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/probes/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_customers_create","title":"<code>probes_customers_create(uuid, kwargs=None, **params)</code>","text":"<p>Create Probe User Customers Relationship</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>replace</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_customers_create(self, uuid: str, kwargs: dict = None, **params\n    ) -&gt; list:\n    \"\"\"Create Probe User Customers Relationship\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        replace (boolean optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['replace']\n    params.get('replace')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_customers_create.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/probes/{uuid}/customers',\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_delete","title":"<code>probes_delete(uuid, kwargs=None)</code>","text":"<p>Delete Probe</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Probe\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/probes/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_delete_bulk","title":"<code>probes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Probes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Probes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/probes/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_logs","title":"<code>probes_logs(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Consume Probe Log</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>key</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_logs(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Consume Probe Log\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        key (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'key']\n    params.get('skip'), params.get('limit'), params.get('key')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_logs.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/probes/{uuid}/logs',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metric_types","title":"<code>probes_metric_types(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metric_types(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metric Types\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_metric_types.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/probes/{uuid}/metric_types',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metric_types_create","title":"<code>probes_metric_types_create(uuid, uuid_metric_type, kwargs=None)</code>","text":"<p>Add Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric_type</code> <code>(str, required)</code> <p>uuid_metric_type</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metric_types_create(self, uuid: str, uuid_metric_type: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric_type (str, required): uuid_metric_type\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/probes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metric_types_create_bulk","title":"<code>probes_metric_types_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metric_types_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_metric_types_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/probes/bulk/create/metric_types', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metric_types_delete","title":"<code>probes_metric_types_delete(uuid, uuid_metric_type, kwargs=None)</code>","text":"<p>Remove Metric Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric_type</code> <code>(str, required)</code> <p>uuid_metric_type</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metric_types_delete(self, uuid: str, uuid_metric_type: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric Type\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric_type (str, required): uuid_metric_type\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/probes/{uuid}/metric_types/{uuid_metric_type}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metric_types_delete_bulk","title":"<code>probes_metric_types_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric_type\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metric_types_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metric Types\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric_type\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/probes/bulk/delete/metric_types', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metrics","title":"<code>probes_metrics(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metrics</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metrics(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metrics\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'profile',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('profile'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_metrics.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/probes/{uuid}/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metrics_create","title":"<code>probes_metrics_create(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Add Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metrics_create(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/probes/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metrics_create_bulk","title":"<code>probes_metrics_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metrics_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_metrics_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/probes/bulk/create/metrics',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metrics_delete","title":"<code>probes_metrics_delete(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Remove Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metrics_delete(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/probes/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_metrics_delete_bulk","title":"<code>probes_metrics_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_probe\": \"string\", required     \"uuid_metric\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_metrics_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_probe\": \"string\", required\n        \"uuid_metric\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/probes/bulk/delete/metrics',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_objects","title":"<code>probes_objects(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Objects</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_objects(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Objects\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'profile',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('profile'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_objects.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/probes/{uuid}/objects',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_objects_create","title":"<code>probes_objects_create(uuid, uuid_object, kwargs=None)</code>","text":"<p>Add Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_objects_create(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/probes/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_objects_create_bulk","title":"<code>probes_objects_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_object\": \"string\", required     \"uuid_probe\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_objects_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_object\": \"string\", required\n        \"uuid_probe\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_objects_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/probes/bulk/create/objects',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_objects_delete","title":"<code>probes_objects_delete(uuid, uuid_object, kwargs=None)</code>","text":"<p>Remove Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_object</code> <code>(str, required)</code> <p>uuid_object</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_objects_delete(self, uuid: str, uuid_object: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_object (str, required): uuid_object\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/probes/{uuid}/objects/{uuid_object}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_objects_delete_bulk","title":"<code>probes_objects_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Objects</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_object\": \"string\", required     \"uuid_probe\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_objects_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Objects\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_object\": \"string\", required\n        \"uuid_probe\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/probes/bulk/delete/objects',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes/#hive.cookbook.probes.Probes.probes_put","title":"<code>probes_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Probe</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_probe_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_host</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <code>data_profile_backup</code> <code>array object optional</code> <p>additional filter - payload</p> <code>last_seen</code> <code>string optional</code> <p>additional filter - payload</p> <code>ingest_frequency</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes.py</code> <pre><code>def probes_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Probe\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_virtual_domain (string optional): additional filter - payload\n        uuid_probe_type (string optional): additional filter - payload\n        uuid_host (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        data_profile (array object optional): additional filter - payload\n        notes (string optional): additional filter - payload\n        status (string optional): additional filter - payload\n        data_profile_backup (array object optional): additional filter - payload\n        last_seen (string optional): additional filter - payload\n        ingest_frequency (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_virtual_domain', 'uuid_probe_type',\n        'uuid_host', 'name', 'description', 'data_profile', 'notes',\n        'status', 'data_profile_backup', 'last_seen', 'ingest_frequency']\n    payload.get('uuid_virtual_domain'), payload.get('uuid_probe_type'\n        ), payload.get('uuid_host'), payload.get('name'), payload.get(\n        'description'), payload.get('data_profile'), payload.get('notes'\n        ), payload.get('status'), payload.get('data_profile_backup'\n        ), payload.get('last_seen'), payload.get('ingest_frequency')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/probes/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.probes_log_ingest/","title":"Hive.cookbook.probes log ingest","text":""},{"location":"hive.cookbook.probes_log_ingest/#hive.cookbook.probes_log_ingest.ProbesLogIngest","title":"<code>ProbesLogIngest</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata probes_log_ingest APIs</p> Source code in <code>hive/cookbook/probes_log_ingest.py</code> <pre><code>class ProbesLogIngest(ApiManager):\n    \"\"\"Class that handles all the XAutomata probes_log_ingest APIs\"\"\"\n\n    def probes_log_ingest_create(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Insert Probe Log\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            uuid_probe (string required): additional filter - parameter\n            key (string optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['uuid_probe', 'key']\n        params.get('uuid_probe'), params.get('key')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.probes_log_ingest_create.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/probes_log_ingest/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.probes_log_ingest/#hive.cookbook.probes_log_ingest.ProbesLogIngest.probes_log_ingest_create","title":"<code>probes_log_ingest_create(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Insert Probe Log</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_probe</code> <code>string required</code> <p>additional filter - parameter</p> <code>key</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/probes_log_ingest.py</code> <pre><code>def probes_log_ingest_create(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Insert Probe Log\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        uuid_probe (string required): additional filter - parameter\n        key (string optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['uuid_probe', 'key']\n    params.get('uuid_probe'), params.get('key')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.probes_log_ingest_create.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/probes_log_ingest/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/","title":"Hive.cookbook.profile topics","text":""},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics","title":"<code>ProfileTopics</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata profile_topics APIs</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>class ProfileTopics(ApiManager):\n    \"\"\"Class that handles all the XAutomata profile_topics APIs\"\"\"\n\n    def profile_topics(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Profile Topics\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            profile (string optional): additional filter - parameter\n            topic (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'profile', 'topic', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('profile'), params.get('topic'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.profile_topics.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/profile_topics/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def profile_topics_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Profile Topic\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            profile (string required): additional filter - payload\n            topic (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['profile', 'topic']\n        payload.get('profile'), payload.get('topic')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.profile_topics_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/profile_topics/', payload=\n            payload, **kwargs)\n        return response\n\n    def profile_topic(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Profile Topic\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/profile_topics/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def profile_topics_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Profile Topic\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            profile (string optional): additional filter - payload\n            topic (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['profile', 'topic']\n        payload.get('profile'), payload.get('topic')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.profile_topics_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/profile_topics/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def profile_topics_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Profile Topic\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/profile_topics/{uuid}',\n            **kwargs)\n        return response\n\n    def profile_topics_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Main Profile Topic\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.profile_topics_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/profile_topics/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def profile_topics_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Profile Topics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"profile\": \"string\", required\n            \"topic\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.profile_topics_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/profile_topics/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def profile_topics_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Profile Topics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/profile_topics/bulk/delete/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topic","title":"<code>profile_topic(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Profile Topic</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topic(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Profile Topic\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/profile_topics/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics","title":"<code>profile_topics(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Profile Topics</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>topic</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Profile Topics\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        profile (string optional): additional filter - parameter\n        topic (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'profile', 'topic', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('profile'), params.get('topic'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.profile_topics.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/profile_topics/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics_bulk","title":"<code>profile_topics_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Main Profile Topic</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Main Profile Topic\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.profile_topics_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/profile_topics/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics_create","title":"<code>profile_topics_create(kwargs=None, **payload)</code>","text":"<p>Create Profile Topic</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>profile</code> <code>string required</code> <p>additional filter - payload</p> <code>topic</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Profile Topic\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        profile (string required): additional filter - payload\n        topic (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['profile', 'topic']\n    payload.get('profile'), payload.get('topic')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.profile_topics_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/profile_topics/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics_create_bulk","title":"<code>profile_topics_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Profile Topics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"profile\": \"string\", required     \"topic\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Profile Topics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"profile\": \"string\", required\n        \"topic\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.profile_topics_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/profile_topics/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics_delete","title":"<code>profile_topics_delete(uuid, kwargs=None)</code>","text":"<p>Delete Profile Topic</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Profile Topic\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/profile_topics/{uuid}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics_delete_bulk","title":"<code>profile_topics_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Profile Topics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Profile Topics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/profile_topics/bulk/delete/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.profile_topics/#hive.cookbook.profile_topics.ProfileTopics.profile_topics_put","title":"<code>profile_topics_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Profile Topic</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>topic</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/profile_topics.py</code> <pre><code>def profile_topics_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Profile Topic\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        profile (string optional): additional filter - payload\n        topic (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['profile', 'topic']\n    payload.get('profile'), payload.get('topic')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.profile_topics_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/profile_topics/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.qr_code/","title":"Hive.cookbook.qr code","text":""},{"location":"hive.cookbook.qr_code/#hive.cookbook.qr_code.QrCode","title":"<code>QrCode</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata qr_code APIs</p> Source code in <code>hive/cookbook/qr_code.py</code> <pre><code>class QrCode(ApiManager):\n    \"\"\"Class that handles all the XAutomata qr_code APIs\"\"\"\n\n    def qr_code(self, warm_start: bool = False, kwargs: dict = None) -&gt; list:\n        \"\"\"Get Qr Code\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/qr_code', warm_start=\n            warm_start, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.qr_code/#hive.cookbook.qr_code.QrCode.qr_code","title":"<code>qr_code(warm_start=False, kwargs=None)</code>","text":"<p>Get Qr Code</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/qr_code.py</code> <pre><code>def qr_code(self, warm_start: bool = False, kwargs: dict = None) -&gt; list:\n    \"\"\"Get Qr Code\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/qr_code', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.questions/","title":"Hive.cookbook.questions","text":""},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions","title":"<code>Questions</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata questions APIs</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>class Questions(ApiManager):\n    \"\"\"Class that handles all the XAutomata questions APIs\"\"\"\n\n    def questions(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Tracking Questions\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            ts_response_start (string optional): additional filter - parameter\n            ts_response_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'type',\n            'ts_response_start', 'ts_response_end', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('type'\n            ), params.get('ts_response_start'), params.get('ts_response_end'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.questions.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/questions/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def questions_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Tracking Question\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n            expires_at (string required): additional filter - payload\n            data_profile (array object required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type', 'expires_at', 'data_profile']\n        payload.get('type'), payload.get('expires_at'), payload.get(\n            'data_profile')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.questions_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/questions/', payload=\n            payload, **kwargs)\n        return response\n\n    def question(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Tracking Question\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/questions/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def questions_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Tracking Question\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            token (string required): additional filter - payload\n            response (array object required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['token', 'response']\n        payload.get('token'), payload.get('response')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.questions_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/questions/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def questions_by_token(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Tracking Question By Token\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            q-token (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['q-token']\n        params.get('q-token')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.questions_by_token.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/questions/{uuid}/by_token',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def questions_reset_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Reset Tracking Question\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            expires_at (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['expires_at']\n        payload.get('expires_at')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.questions_reset_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/questions/{uuid}/reset',\n            payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions.question","title":"<code>question(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Tracking Question</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>def question(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Tracking Question\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/questions/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions.questions","title":"<code>questions(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Tracking Questions</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_response_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_response_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>def questions(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Tracking Questions\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        ts_response_start (string optional): additional filter - parameter\n        ts_response_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'type',\n        'ts_response_start', 'ts_response_end', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('type'\n        ), params.get('ts_response_start'), params.get('ts_response_end'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.questions.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/questions/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions.questions_by_token","title":"<code>questions_by_token(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Tracking Question By Token</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>q-token</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>def questions_by_token(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Tracking Question By Token\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        q-token (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['q-token']\n    params.get('q-token')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.questions_by_token.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/questions/{uuid}/by_token',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions.questions_create","title":"<code>questions_create(kwargs=None, **payload)</code>","text":"<p>Create Tracking Question</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <code>expires_at</code> <code>string required</code> <p>additional filter - payload</p> <code>data_profile</code> <code>array object required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>def questions_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Tracking Question\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n        expires_at (string required): additional filter - payload\n        data_profile (array object required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type', 'expires_at', 'data_profile']\n    payload.get('type'), payload.get('expires_at'), payload.get(\n        'data_profile')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.questions_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/questions/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions.questions_put","title":"<code>questions_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Tracking Question</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>token</code> <code>string required</code> <p>additional filter - payload</p> <code>response</code> <code>array object required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>def questions_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Tracking Question\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        token (string required): additional filter - payload\n        response (array object required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['token', 'response']\n    payload.get('token'), payload.get('response')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.questions_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/questions/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.questions/#hive.cookbook.questions.Questions.questions_reset_put","title":"<code>questions_reset_put(uuid, kwargs=None, **payload)</code>","text":"<p>Reset Tracking Question</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>expires_at</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/questions.py</code> <pre><code>def questions_reset_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Reset Tracking Question\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        expires_at (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['expires_at']\n    payload.get('expires_at')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.questions_reset_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/questions/{uuid}/reset',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/","title":"Hive.cookbook.reason for closure","text":""},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure","title":"<code>ReasonForClosure</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata reason_for_closure APIs</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>class ReasonForClosure(ApiManager):\n    \"\"\"Class that handles all the XAutomata reason_for_closure APIs\"\"\"\n\n    def reason_for_closure(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Reason For Closure\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            jurisdiction (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code',\n            'description', 'jurisdiction', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('description'), params.get('jurisdiction'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.reason_for_closure.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/reason_for_closure/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def reason_for_closure_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Reason For Closure\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            jurisdiction (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'jurisdiction']\n        payload.get('code'), payload.get('description'), payload.get(\n            'jurisdiction')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.reason_for_closure_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/reason_for_closure/',\n            payload=payload, **kwargs)\n        return response\n\n    def reason_for_closure_uuid(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Reason For Closure\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/reason_for_closure/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def reason_for_closure_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Reason For Closure\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            jurisdiction (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'jurisdiction']\n        payload.get('code'), payload.get('description'), payload.get(\n            'jurisdiction')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.reason_for_closure_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/reason_for_closure/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def reason_for_closure_delete(self, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Reason For Closure\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/reason_for_closure/{uuid}', **kwargs)\n        return response\n\n    def reason_for_closure_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Reasons For Closure\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.reason_for_closure_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/reason_for_closure/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def reason_for_closure_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Reasons For Closure\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"code\": \"string\", required\n            \"description\": \"string\", optional\n            \"jurisdiction\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.reason_for_closure_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/reason_for_closure/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def reason_for_closure_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Reasons For Closure\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/reason_for_closure/bulk/delete/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure","title":"<code>reason_for_closure(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Reason For Closure</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>jurisdiction</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Reason For Closure\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        jurisdiction (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code',\n        'description', 'jurisdiction', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('description'), params.get('jurisdiction'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.reason_for_closure.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/reason_for_closure/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_bulk","title":"<code>reason_for_closure_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Reasons For Closure</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Reasons For Closure\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.reason_for_closure_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/reason_for_closure/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_create","title":"<code>reason_for_closure_create(kwargs=None, **payload)</code>","text":"<p>Create Reason For Closure</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>jurisdiction</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Reason For Closure\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        jurisdiction (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'jurisdiction']\n    payload.get('code'), payload.get('description'), payload.get(\n        'jurisdiction')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.reason_for_closure_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/reason_for_closure/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_create_bulk","title":"<code>reason_for_closure_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Reasons For Closure</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"code\": \"string\", required     \"description\": \"string\", optional     \"jurisdiction\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Reasons For Closure\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"code\": \"string\", required\n        \"description\": \"string\", optional\n        \"jurisdiction\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.reason_for_closure_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/reason_for_closure/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_delete","title":"<code>reason_for_closure_delete(uuid, kwargs=None)</code>","text":"<p>Delete Reason For Closure</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_delete(self, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Reason For Closure\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/reason_for_closure/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_delete_bulk","title":"<code>reason_for_closure_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Reasons For Closure</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Reasons For Closure\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/reason_for_closure/bulk/delete/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_put","title":"<code>reason_for_closure_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Reason For Closure</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>jurisdiction</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Reason For Closure\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        jurisdiction (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'jurisdiction']\n    payload.get('code'), payload.get('description'), payload.get(\n        'jurisdiction')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.reason_for_closure_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/reason_for_closure/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.reason_for_closure/#hive.cookbook.reason_for_closure.ReasonForClosure.reason_for_closure_uuid","title":"<code>reason_for_closure_uuid(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Reason For Closure</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/reason_for_closure.py</code> <pre><code>def reason_for_closure_uuid(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Reason For Closure\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/reason_for_closure/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.retention_rules/","title":"Hive.cookbook.retention rules","text":""},{"location":"hive.cookbook.retention_rules/#hive.cookbook.retention_rules.RetentionRules","title":"<code>RetentionRules</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata retention_rules APIs</p> Source code in <code>hive/cookbook/retention_rules.py</code> <pre><code>class RetentionRules(ApiManager):\n    \"\"\"Class that handles all the XAutomata retention_rules APIs\"\"\"\n\n    def retention_rules(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Admin Retention Rules\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            priority (integer optional): additional filter - parameter\n            average_after_days (integer optional): additional filter - parameter\n            average_over_minutes (integer optional): additional filter - parameter\n            deletion_after_days (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'metric_profile',\n            'priority', 'average_after_days', 'average_over_minutes',\n            'deletion_after_days', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'metric_profile'), params.get('priority'), params.get(\n            'average_after_days'), params.get('average_over_minutes'\n            ), params.get('deletion_after_days'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.retention_rules.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/retention_rules/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def retention_rules_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Retention Rule\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string required): additional filter - payload\n            metric_profile (string optional): additional filter - payload\n            priority (integer required): additional filter - payload\n            average_after_days (integer optional): additional filter - payload\n            average_over_minutes ( optional): additional filter - payload\n            deletion_after_days (integer optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'metric_profile',\n            'priority', 'average_after_days', 'average_over_minutes',\n            'deletion_after_days']\n        payload.get('uuid_customer'), payload.get('metric_profile'\n            ), payload.get('priority'), payload.get('average_after_days'\n            ), payload.get('average_over_minutes'), payload.get(\n            'deletion_after_days')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.retention_rules_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/retention_rules/', payload=\n            payload, **kwargs)\n        return response\n\n    def retention_rule(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Admin Retention Rule\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/retention_rules/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def retention_rules_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Retention Rule\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string optional): additional filter - payload\n            metric_profile (string optional): additional filter - payload\n            priority (integer optional): additional filter - payload\n            average_after_days (integer optional): additional filter - payload\n            average_over_minutes ( optional): additional filter - payload\n            deletion_after_days (integer optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'metric_profile',\n            'priority', 'average_after_days', 'average_over_minutes',\n            'deletion_after_days']\n        payload.get('uuid_customer'), payload.get('metric_profile'\n            ), payload.get('priority'), payload.get('average_after_days'\n            ), payload.get('average_over_minutes'), payload.get(\n            'deletion_after_days')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.retention_rules_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/retention_rules/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def retention_rules_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Retention Rule\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/retention_rules/{uuid}',\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.retention_rules/#hive.cookbook.retention_rules.RetentionRules.retention_rule","title":"<code>retention_rule(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Admin Retention Rule</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/retention_rules.py</code> <pre><code>def retention_rule(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Admin Retention Rule\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/retention_rules/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.retention_rules/#hive.cookbook.retention_rules.RetentionRules.retention_rules","title":"<code>retention_rules(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Admin Retention Rules</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>priority</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>average_after_days</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>average_over_minutes</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>deletion_after_days</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/retention_rules.py</code> <pre><code>def retention_rules(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Admin Retention Rules\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        priority (integer optional): additional filter - parameter\n        average_after_days (integer optional): additional filter - parameter\n        average_over_minutes (integer optional): additional filter - parameter\n        deletion_after_days (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'metric_profile',\n        'priority', 'average_after_days', 'average_over_minutes',\n        'deletion_after_days', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'metric_profile'), params.get('priority'), params.get(\n        'average_after_days'), params.get('average_over_minutes'\n        ), params.get('deletion_after_days'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.retention_rules.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/retention_rules/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.retention_rules/#hive.cookbook.retention_rules.RetentionRules.retention_rules_create","title":"<code>retention_rules_create(kwargs=None, **payload)</code>","text":"<p>Create Retention Rule</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>priority</code> <code>integer required</code> <p>additional filter - payload</p> <code>average_after_days</code> <code>integer optional</code> <p>additional filter - payload</p> <code>average_over_minutes</code> <code>optional</code> <p>additional filter - payload</p> <code>deletion_after_days</code> <code>integer optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/retention_rules.py</code> <pre><code>def retention_rules_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Retention Rule\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string required): additional filter - payload\n        metric_profile (string optional): additional filter - payload\n        priority (integer required): additional filter - payload\n        average_after_days (integer optional): additional filter - payload\n        average_over_minutes ( optional): additional filter - payload\n        deletion_after_days (integer optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'metric_profile',\n        'priority', 'average_after_days', 'average_over_minutes',\n        'deletion_after_days']\n    payload.get('uuid_customer'), payload.get('metric_profile'\n        ), payload.get('priority'), payload.get('average_after_days'\n        ), payload.get('average_over_minutes'), payload.get(\n        'deletion_after_days')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.retention_rules_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/retention_rules/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.retention_rules/#hive.cookbook.retention_rules.RetentionRules.retention_rules_delete","title":"<code>retention_rules_delete(uuid, kwargs=None)</code>","text":"<p>Delete Retention Rule</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/retention_rules.py</code> <pre><code>def retention_rules_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Retention Rule\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/retention_rules/{uuid}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.retention_rules/#hive.cookbook.retention_rules.RetentionRules.retention_rules_put","title":"<code>retention_rules_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Retention Rule</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string optional</code> <p>additional filter - payload</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>priority</code> <code>integer optional</code> <p>additional filter - payload</p> <code>average_after_days</code> <code>integer optional</code> <p>additional filter - payload</p> <code>average_over_minutes</code> <code>optional</code> <p>additional filter - payload</p> <code>deletion_after_days</code> <code>integer optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/retention_rules.py</code> <pre><code>def retention_rules_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Retention Rule\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string optional): additional filter - payload\n        metric_profile (string optional): additional filter - payload\n        priority (integer optional): additional filter - payload\n        average_after_days (integer optional): additional filter - payload\n        average_over_minutes ( optional): additional filter - payload\n        deletion_after_days (integer optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'metric_profile',\n        'priority', 'average_after_days', 'average_over_minutes',\n        'deletion_after_days']\n    payload.get('uuid_customer'), payload.get('metric_profile'\n        ), payload.get('priority'), payload.get('average_after_days'\n        ), payload.get('average_over_minutes'), payload.get(\n        'deletion_after_days')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.retention_rules_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/retention_rules/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.schedules/","title":"Hive.cookbook.schedules","text":""},{"location":"hive.cookbook.schedules/#hive.cookbook.schedules.Schedules","title":"<code>Schedules</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata schedules APIs</p> Source code in <code>hive/cookbook/schedules.py</code> <pre><code>class Schedules(ApiManager):\n    \"\"\"Class that handles all the XAutomata schedules APIs\"\"\"\n\n    def schedules(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Tracking Schedules\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_customer (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            ical (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_customer', 'code', 'ical',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_customer'), params.get('code'\n            ), params.get('ical'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.schedules.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/schedules/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def schedules_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Tracking Schedule\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string required): additional filter - payload\n            code (string required): additional filter - payload\n            ical (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'code', 'ical']\n        payload.get('uuid_customer'), payload.get('code'), payload.get('ical')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.schedules_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/schedules/', payload=\n            payload, **kwargs)\n        return response\n\n    def schedule(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Tracking Schedule\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.schedule.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/schedules/{uuid}',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def schedules_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Tracking Schedule\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_customer (string optional): additional filter - payload\n            code (string optional): additional filter - payload\n            ical (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'code', 'ical']\n        payload.get('uuid_customer'), payload.get('code'), payload.get('ical')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.schedules_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/schedules/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def schedules_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Tracking Schedule\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/schedules/{uuid}', **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.schedules/#hive.cookbook.schedules.Schedules.schedule","title":"<code>schedule(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Tracking Schedule</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/schedules.py</code> <pre><code>def schedule(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Tracking Schedule\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.schedule.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/schedules/{uuid}',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.schedules/#hive.cookbook.schedules.Schedules.schedules","title":"<code>schedules(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Tracking Schedules</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ical</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/schedules.py</code> <pre><code>def schedules(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Tracking Schedules\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_customer (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        ical (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_customer', 'code', 'ical',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_customer'), params.get('code'\n        ), params.get('ical'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.schedules.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/schedules/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.schedules/#hive.cookbook.schedules.Schedules.schedules_create","title":"<code>schedules_create(kwargs=None, **payload)</code>","text":"<p>Create Tracking Schedule</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>ical</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/schedules.py</code> <pre><code>def schedules_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Tracking Schedule\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string required): additional filter - payload\n        code (string required): additional filter - payload\n        ical (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'code', 'ical']\n    payload.get('uuid_customer'), payload.get('code'), payload.get('ical')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.schedules_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/schedules/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.schedules/#hive.cookbook.schedules.Schedules.schedules_delete","title":"<code>schedules_delete(uuid, kwargs=None)</code>","text":"<p>Delete Tracking Schedule</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/schedules.py</code> <pre><code>def schedules_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Tracking Schedule\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/schedules/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.schedules/#hive.cookbook.schedules.Schedules.schedules_put","title":"<code>schedules_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Tracking Schedule</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_customer</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>ical</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/schedules.py</code> <pre><code>def schedules_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Tracking Schedule\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_customer (string optional): additional filter - payload\n        code (string optional): additional filter - payload\n        ical (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'code', 'ical']\n    payload.get('uuid_customer'), payload.get('code'), payload.get('ical')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.schedules_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/schedules/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/","title":"Hive.cookbook.services","text":""},{"location":"hive.cookbook.services/#hive.cookbook.services.Services","title":"<code>Services</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata services APIs</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>class Services(ApiManager):\n    \"\"\"Class that handles all the XAutomata services APIs\"\"\"\n\n    def services(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Services\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            uuid_parent (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'uuid_parent', 'uuid_customer', 'profile', 'name',\n            'description', 'status', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('uuid_parent'), params.get(\n            'uuid_customer'), params.get('profile'), params.get('name'\n            ), params.get('description'), params.get('status'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/services/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def services_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Service\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_parent (string optional): additional filter - payload\n            uuid_customer (string required): additional filter - payload\n            profile (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string required): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            rule (array object optional): additional filter - payload\n            status (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_parent', 'uuid_customer', 'profile',\n            'name', 'description', 'automata_domain', 'rule', 'status']\n        payload.get('uuid_parent'), payload.get('uuid_customer'), payload.get(\n            'profile'), payload.get('name'), payload.get('description'\n            ), payload.get('automata_domain'), payload.get('rule'\n            ), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/services/', payload=payload,\n            **kwargs)\n        return response\n\n    def service(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Service\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.service.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/services/{uuid}', warm_start\n            =warm_start, params=params, **kwargs)\n        return response\n\n    def services_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Service\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_parent (string optional): additional filter - payload\n            uuid_customer (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            automata_domain (array object optional): additional filter - payload\n            rule (array object optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_parent', 'uuid_customer', 'profile',\n            'name', 'description', 'automata_domain', 'rule', 'status']\n        payload.get('uuid_parent'), payload.get('uuid_customer'), payload.get(\n            'profile'), payload.get('name'), payload.get('description'\n            ), payload.get('automata_domain'), payload.get('rule'\n            ), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/services/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def services_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Service\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/services/{uuid}', **kwargs)\n        return response\n\n    def services_metrics(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Metrics\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_metrics.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/services/{uuid}/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def services_metrics_create(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/services/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def services_metrics_delete(self, uuid: str, uuid_metric: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Metric\n\n        Args:\n            uuid (str, required): uuid\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/services/{uuid}/metrics/{uuid_metric}', **kwargs)\n        return response\n\n    def services_downtimes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Downtimes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            fetch_all (boolean optional): additional filter - parameter\n            only_actives (boolean optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            active_after_timestamp (string optional): additional filter - parameter\n            active_at_or_after_timestamp (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'fetch_all',\n            'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n            'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n            'count']\n        params.get('not_in'), params.get('code'), params.get('fetch_all'\n            ), params.get('only_actives'), params.get('active_at_timestamp'\n            ), params.get('active_after_timestamp'), params.get(\n            'active_at_or_after_timestamp'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_downtimes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/services/{uuid}/downtimes',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def services_downtimes_create(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/services/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def services_downtimes_delete(self, uuid: str, uuid_downtime: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Downtime\n\n        Args:\n            uuid (str, required): uuid\n            uuid_downtime (str, required): uuid_downtime\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/services/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n        return response\n\n    def services_dispatchers(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dispatchers\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            fetch_all (boolean optional): additional filter - parameter\n            only_actives (boolean optional): additional filter - parameter\n            active_at_timestamp (string optional): additional filter - parameter\n            tag (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'code', 'status', 'fetch_all',\n            'only_actives', 'active_at_timestamp', 'tag', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('code'), params.get('status'\n            ), params.get('fetch_all'), params.get('only_actives'), params.get(\n            'active_at_timestamp'), params.get('tag'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_dispatchers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/services/{uuid}/dispatchers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def services_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/services/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def services_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Dispatcher\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dispatcher (str, required): uuid_dispatcher\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/services/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n        return response\n\n    def services_query(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_company_name (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            service_uuid_parent (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            service_profile (string optional): additional filter - parameter\n            service_name (string optional): additional filter - parameter\n            service_description (string optional): additional filter - parameter\n            service_status (string optional): additional filter - parameter\n            service_uuid_customer (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n            'customer_company_name', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'service_uuid_parent', 'uuid_service', 'service_profile',\n            'service_name', 'service_description', 'service_status',\n            'service_uuid_customer', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_company_name'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('uuid_metric_type'), params.get('metric_type_name'\n            ), params.get('metric_type_status'), params.get('uuid_metric'\n            ), params.get('metric_name'), params.get('metric_status'\n            ), params.get('metric_profile'), params.get('service_uuid_parent'\n            ), params.get('uuid_service'), params.get('service_profile'\n            ), params.get('service_name'), params.get('service_description'\n            ), params.get('service_status'), params.get('service_uuid_customer'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_query.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/services/query/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def services_query_bulk(self, payload: dict = False,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query Lists\n\n        Args:\n            payload (dict, optional): additional parameters for the API.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n           {\n            \"uuid_customer\": \"array\", optional\n            \"customer_company_name\": \"array\", optional\n            \"customer_code\": \"array\", optional\n            \"customer_status\": \"array\", optional\n            \"uuid_site\": \"array\", optional\n            \"site_code\": \"array\", optional\n            \"site_description\": \"array\", optional\n            \"site_address\": \"array\", optional\n            \"site_zip_code\": \"array\", optional\n            \"site_city\": \"array\", optional\n            \"site_country\": \"array\", optional\n            \"site_state_province\": \"array\", optional\n            \"site_status\": \"array\", optional\n            \"uuid_group\": \"array\", optional\n            \"group_name\": \"array\", optional\n            \"group_status\": \"array\", optional\n            \"group_type\": \"array\", optional\n            \"uuid_object\": \"array\", optional\n            \"object_name\": \"array\", optional\n            \"object_status\": \"array\", optional\n            \"object_profile\": \"array\", optional\n            \"uuid_metric_type\": \"array\", optional\n            \"metric_type_name\": \"array\", optional\n            \"metric_type_status\": \"array\", optional\n            \"uuid_metric\": \"array\", optional\n            \"metric_name\": \"array\", optional\n            \"metric_status\": \"array\", optional\n            \"metric_profile\": \"array\", optional\n            \"service_uuid_parent\": \"array\", optional\n            \"uuid_service\": \"array\", optional\n            \"service_profile\": \"array\", optional\n            \"service_name\": \"array\", optional\n            \"service_description\": \"array\", optional\n            \"service_status\": \"array\", optional\n            \"service_uuid_customer\": \"array\", optional\n           }\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_query_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/services/query/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def services_last_status_query(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query Last Status\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_data_profile (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_company_name (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            group_uuid_virtual_domain (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            service_uuid_parent (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            service_profile (string optional): additional filter - parameter\n            service_name (string optional): additional filter - parameter\n            service_description (string optional): additional filter - parameter\n            service_status (string optional): additional filter - parameter\n            service_uuid_customer (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ranking (integer optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            unit (string optional): additional filter - parameter\n            value (number optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_data_profile', 'sort_by',\n            'null_fields', 'uuid_customer', 'customer_company_name',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'group_uuid_virtual_domain', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'service_uuid_parent', 'uuid_service', 'service_profile',\n            'service_name', 'service_description', 'service_status',\n            'service_uuid_customer', 'timestamp_start', 'timestamp_end',\n            'database_timestamp_start', 'database_timestamp_end', 'status',\n            'ranking', 'description', 'unit', 'value', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('extract_data_profile'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('uuid_customer'), params.get(\n            'customer_company_name'), params.get('customer_code'), params.get(\n            'customer_status'), params.get('uuid_site'), params.get('site_code'\n            ), params.get('site_description'), params.get('site_address'\n            ), params.get('site_zip_code'), params.get('site_city'\n            ), params.get('site_country'), params.get('site_state_province'\n            ), params.get('site_status'), params.get('uuid_group'), params.get(\n            'group_name'), params.get('group_status'), params.get('group_type'\n            ), params.get('group_uuid_virtual_domain'), params.get(\n            'uuid_object'), params.get('object_name'), params.get(\n            'object_status'), params.get('object_profile'), params.get(\n            'uuid_metric_type'), params.get('metric_type_name'), params.get(\n            'metric_type_status'), params.get('uuid_metric'), params.get(\n            'metric_name'), params.get('metric_status'), params.get(\n            'metric_profile'), params.get('service_uuid_parent'), params.get(\n            'uuid_service'), params.get('service_profile'), params.get(\n            'service_name'), params.get('service_description'), params.get(\n            'service_status'), params.get('service_uuid_customer'), params.get(\n            'timestamp_start'), params.get('timestamp_end'), params.get(\n            'database_timestamp_start'), params.get('database_timestamp_end'\n            ), params.get('status'), params.get('ranking'), params.get(\n            'description'), params.get('unit'), params.get('value'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_last_status_query.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=f'/services/query/last_status',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def services_last_status_query_bulk(self, payload: dict = False,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query Last Status List\n\n        Args:\n            payload (dict, optional): additional parameters for the API.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_data_profile (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n           {\n            \"uuid_customer\": \"array\", optional\n            \"customer_company_name\": \"array\", optional\n            \"customer_code\": \"array\", optional\n            \"customer_status\": \"array\", optional\n            \"uuid_site\": \"array\", optional\n            \"site_code\": \"array\", optional\n            \"site_description\": \"array\", optional\n            \"site_address\": \"array\", optional\n            \"site_zip_code\": \"array\", optional\n            \"site_city\": \"array\", optional\n            \"site_country\": \"array\", optional\n            \"site_state_province\": \"array\", optional\n            \"site_status\": \"array\", optional\n            \"uuid_group\": \"array\", optional\n            \"group_name\": \"array\", optional\n            \"group_status\": \"array\", optional\n            \"group_type\": \"array\", optional\n            \"group_uuid_virtual_domain\": \"array\", optional\n            \"uuid_object\": \"array\", optional\n            \"object_name\": \"array\", optional\n            \"object_status\": \"array\", optional\n            \"object_profile\": \"array\", optional\n            \"uuid_metric_type\": \"array\", optional\n            \"metric_type_name\": \"array\", optional\n            \"metric_type_status\": \"array\", optional\n            \"uuid_metric\": \"array\", optional\n            \"metric_name\": \"array\", optional\n            \"metric_status\": \"array\", optional\n            \"metric_profile\": \"array\", optional\n            \"service_uuid_parent\": \"array\", optional\n            \"uuid_service\": \"array\", optional\n            \"service_profile\": \"array\", optional\n            \"service_name\": \"array\", optional\n            \"service_description\": \"array\", optional\n            \"service_status\": \"array\", optional\n            \"service_uuid_customer\": \"array\", optional\n            \"status\": \"array\", optional\n            \"ranking\": \"array\", optional\n            \"description\": \"array\", optional\n            \"unit\": \"array\", optional\n            \"value\": \"array\", optional\n           }\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_data_profile', 'sort_by',\n            'null_fields', 'timestamp_start', 'timestamp_end',\n            'database_timestamp_start', 'database_timestamp_end', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('extract_data_profile'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('timestamp_start'), params.get(\n            'timestamp_end'), params.get('database_timestamp_start'\n            ), params.get('database_timestamp_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_last_status_query_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/services/query/last_status',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def services_last_status_query_v2(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query Last Status V2\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_data_profile (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_company_name (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            group_uuid_virtual_domain (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            service_uuid_parent (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            service_profile (string optional): additional filter - parameter\n            service_name (string optional): additional filter - parameter\n            service_description (string optional): additional filter - parameter\n            service_status (string optional): additional filter - parameter\n            service_uuid_customer (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ranking (integer optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            unit (string optional): additional filter - parameter\n            value (number optional): additional filter - parameter\n            fields_to_select (array optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_data_profile', 'sort_by',\n            'null_fields', 'uuid_customer', 'customer_company_name',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'group_uuid_virtual_domain', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'service_uuid_parent', 'uuid_service', 'service_profile',\n            'service_name', 'service_description', 'service_status',\n            'service_uuid_customer', 'timestamp_start', 'timestamp_end',\n            'database_timestamp_start', 'database_timestamp_end', 'status',\n            'ranking', 'description', 'unit', 'value', 'fields_to_select',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('extract_data_profile'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('uuid_customer'), params.get(\n            'customer_company_name'), params.get('customer_code'), params.get(\n            'customer_status'), params.get('uuid_site'), params.get('site_code'\n            ), params.get('site_description'), params.get('site_address'\n            ), params.get('site_zip_code'), params.get('site_city'\n            ), params.get('site_country'), params.get('site_state_province'\n            ), params.get('site_status'), params.get('uuid_group'), params.get(\n            'group_name'), params.get('group_status'), params.get('group_type'\n            ), params.get('group_uuid_virtual_domain'), params.get(\n            'uuid_object'), params.get('object_name'), params.get(\n            'object_status'), params.get('object_profile'), params.get(\n            'uuid_metric_type'), params.get('metric_type_name'), params.get(\n            'metric_type_status'), params.get('uuid_metric'), params.get(\n            'metric_name'), params.get('metric_status'), params.get(\n            'metric_profile'), params.get('service_uuid_parent'), params.get(\n            'uuid_service'), params.get('service_profile'), params.get(\n            'service_name'), params.get('service_description'), params.get(\n            'service_status'), params.get('service_uuid_customer'), params.get(\n            'timestamp_start'), params.get('timestamp_end'), params.get(\n            'database_timestamp_start'), params.get('database_timestamp_end'\n            ), params.get('status'), params.get('ranking'), params.get(\n            'description'), params.get('unit'), params.get('value'\n            ), params.get('fields_to_select'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_last_status_query_v2.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/services/query/last_status_v2', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def services_last_status_query_bulk_v2(self, payload: dict = False,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query Last Status List V2\n\n        Args:\n            payload (dict, optional): additional parameters for the API.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_data_profile (string optional): additional filter - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Examples:\n            payload = \n           {\n            \"uuid_customer\": \"array\", optional\n            \"customer_company_name\": \"array\", optional\n            \"customer_code\": \"array\", optional\n            \"customer_status\": \"array\", optional\n            \"uuid_site\": \"array\", optional\n            \"site_code\": \"array\", optional\n            \"site_description\": \"array\", optional\n            \"site_address\": \"array\", optional\n            \"site_zip_code\": \"array\", optional\n            \"site_city\": \"array\", optional\n            \"site_country\": \"array\", optional\n            \"site_state_province\": \"array\", optional\n            \"site_status\": \"array\", optional\n            \"uuid_group\": \"array\", optional\n            \"group_name\": \"array\", optional\n            \"group_status\": \"array\", optional\n            \"group_type\": \"array\", optional\n            \"group_uuid_virtual_domain\": \"array\", optional\n            \"uuid_object\": \"array\", optional\n            \"object_name\": \"array\", optional\n            \"object_status\": \"array\", optional\n            \"object_profile\": \"array\", optional\n            \"uuid_metric_type\": \"array\", optional\n            \"metric_type_name\": \"array\", optional\n            \"metric_type_status\": \"array\", optional\n            \"uuid_metric\": \"array\", optional\n            \"metric_name\": \"array\", optional\n            \"metric_status\": \"array\", optional\n            \"metric_profile\": \"array\", optional\n            \"service_uuid_parent\": \"array\", optional\n            \"uuid_service\": \"array\", optional\n            \"service_profile\": \"array\", optional\n            \"service_name\": \"array\", optional\n            \"service_description\": \"array\", optional\n            \"service_status\": \"array\", optional\n            \"service_uuid_customer\": \"array\", optional\n            \"status\": \"array\", optional\n            \"ranking\": \"array\", optional\n            \"description\": \"array\", optional\n            \"unit\": \"array\", optional\n            \"value\": \"array\", optional\n            \"fields_to_select\": \"array\", optional\n           }\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_data_profile', 'sort_by',\n            'null_fields', 'timestamp_start', 'timestamp_end',\n            'database_timestamp_start', 'database_timestamp_end', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('extract_data_profile'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('timestamp_start'), params.get(\n            'timestamp_end'), params.get('database_timestamp_start'\n            ), params.get('database_timestamp_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                services_last_status_query_bulk_v2.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/services/query/last_status_v2', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def services_last_status_by_automaton_id_query(self,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Service Query Last Status By Automaton Id\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_company_name (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            group_uuid_virtual_domain (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            service_uuid_parent (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            service_profile (string optional): additional filter - parameter\n            service_name (string optional): additional filter - parameter\n            service_description (string optional): additional filter - parameter\n            service_status (string optional): additional filter - parameter\n            service_uuid_customer (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ranking (integer optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n            'customer_company_name', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type',\n            'group_uuid_virtual_domain', 'uuid_object', 'object_name',\n            'object_status', 'object_profile', 'uuid_metric_type',\n            'metric_type_name', 'metric_type_status', 'uuid_metric',\n            'metric_name', 'metric_status', 'metric_profile',\n            'service_uuid_parent', 'uuid_service', 'service_profile',\n            'service_name', 'service_description', 'service_status',\n            'service_uuid_customer', 'timestamp_start', 'timestamp_end',\n            'database_timestamp_start', 'database_timestamp_end', 'status',\n            'ranking', 'description', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_company_name'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('group_uuid_virtual_domain'), params.get(\n            'uuid_object'), params.get('object_name'), params.get(\n            'object_status'), params.get('object_profile'), params.get(\n            'uuid_metric_type'), params.get('metric_type_name'), params.get(\n            'metric_type_status'), params.get('uuid_metric'), params.get(\n            'metric_name'), params.get('metric_status'), params.get(\n            'metric_profile'), params.get('service_uuid_parent'), params.get(\n            'uuid_service'), params.get('service_profile'), params.get(\n            'service_name'), params.get('service_description'), params.get(\n            'service_status'), params.get('service_uuid_customer'), params.get(\n            'timestamp_start'), params.get('timestamp_end'), params.get(\n            'database_timestamp_start'), params.get('database_timestamp_end'\n            ), params.get('status'), params.get('ranking'), params.get(\n            'description'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                services_last_status_by_automaton_id_query.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/services/query/last_status/by_automaton_id', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def services_check_rules_create(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Check Service Rules\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_group (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            uuid_metric_type (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            services_rules (array required): additional filter - payload\n            default_service (None required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['services_rules', 'default_service']\n        payload.get('services_rules'), payload.get('default_service')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_check_rules_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/services/check_rules/',\n            params=params, payload=payload, **kwargs)\n        return response\n\n    def services_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/services/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def services_metrics_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_metrics_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/services/bulk/read/metrics/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def services_read_by_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Services By Uuid Customer And Name And Profile\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_customer\": \"string\", required\n            \"profile\": \"string\", required\n            \"name\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/services/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, payload=payload, **kwargs)\n        return response\n\n    def services_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_parent\": \"string\", optional\n            \"uuid_customer\": \"string\", required\n            \"profile\": \"string\", required\n            \"name\": \"string\", required\n            \"description\": \"string\", required\n            \"automata_domain\": \"array object\", optional\n            \"rule\": \"array object\", optional\n            \"status\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/services/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def services_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Services\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/services/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def services_metrics_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_metrics_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/services/bulk/create/metrics', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def services_metrics_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/services/bulk/delete/metrics', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def services_downtimes_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.services_downtimes_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/services/bulk/create/downtimes', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def services_downtimes_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Downtimes\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_downtime\": \"string\", required\n            \"uuid_service\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/services/bulk/delete/downtimes', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.service","title":"<code>service(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def service(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Service\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.service.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/services/{uuid}', warm_start\n        =warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services","title":"<code>services(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Services</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Services\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        uuid_parent (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'uuid_parent', 'uuid_customer', 'profile', 'name',\n        'description', 'status', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('uuid_parent'), params.get(\n        'uuid_customer'), params.get('profile'), params.get('name'\n        ), params.get('description'), params.get('status'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/services/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_bulk","title":"<code>services_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/services/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_check_rules_create","title":"<code>services_check_rules_create(params=False, kwargs=None, **payload)</code>","text":"<p>Check Service Rules</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>services_rules</code> <code>array required</code> <p>additional filter - payload</p> <code>default_service</code> <code>None required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_check_rules_create(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Check Service Rules\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_group (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        services_rules (array required): additional filter - payload\n        default_service (None required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['services_rules', 'default_service']\n    payload.get('services_rules'), payload.get('default_service')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_check_rules_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/services/check_rules/',\n        params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_create","title":"<code>services_create(kwargs=None, **payload)</code>","text":"<p>Create Service</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_parent</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>profile</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string required</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>rule</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Service\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_parent (string optional): additional filter - payload\n        uuid_customer (string required): additional filter - payload\n        profile (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string required): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        rule (array object optional): additional filter - payload\n        status (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_parent', 'uuid_customer', 'profile',\n        'name', 'description', 'automata_domain', 'rule', 'status']\n    payload.get('uuid_parent'), payload.get('uuid_customer'), payload.get(\n        'profile'), payload.get('name'), payload.get('description'\n        ), payload.get('automata_domain'), payload.get('rule'\n        ), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/services/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_create_bulk","title":"<code>services_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_parent\": \"string\", optional     \"uuid_customer\": \"string\", required     \"profile\": \"string\", required     \"name\": \"string\", required     \"description\": \"string\", required     \"automata_domain\": \"array object\", optional     \"rule\": \"array object\", optional     \"status\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_parent\": \"string\", optional\n        \"uuid_customer\": \"string\", required\n        \"profile\": \"string\", required\n        \"name\": \"string\", required\n        \"description\": \"string\", required\n        \"automata_domain\": \"array object\", optional\n        \"rule\": \"array object\", optional\n        \"status\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/services/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_delete","title":"<code>services_delete(uuid, kwargs=None)</code>","text":"<p>Delete Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Service\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/services/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_delete_bulk","title":"<code>services_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Services</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Services\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/services/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_dispatchers","title":"<code>services_dispatchers(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dispatchers</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fetch_all</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>only_actives</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>tag</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_dispatchers(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dispatchers\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        fetch_all (boolean optional): additional filter - parameter\n        only_actives (boolean optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        tag (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'status', 'fetch_all',\n        'only_actives', 'active_at_timestamp', 'tag', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('code'), params.get('status'\n        ), params.get('fetch_all'), params.get('only_actives'), params.get(\n        'active_at_timestamp'), params.get('tag'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_dispatchers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/services/{uuid}/dispatchers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_dispatchers_create","title":"<code>services_dispatchers_create(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Add Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_dispatchers_create(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/services/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_dispatchers_delete","title":"<code>services_dispatchers_delete(uuid, uuid_dispatcher, kwargs=None)</code>","text":"<p>Remove Dispatcher</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dispatcher</code> <code>(str, required)</code> <p>uuid_dispatcher</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_dispatchers_delete(self, uuid: str, uuid_dispatcher: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Dispatcher\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dispatcher (str, required): uuid_dispatcher\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/services/{uuid}/dispatchers/{uuid_dispatcher}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_downtimes","title":"<code>services_downtimes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fetch_all</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>only_actives</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>active_at_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active_at_or_after_timestamp</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_downtimes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Downtimes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        fetch_all (boolean optional): additional filter - parameter\n        only_actives (boolean optional): additional filter - parameter\n        active_at_timestamp (string optional): additional filter - parameter\n        active_after_timestamp (string optional): additional filter - parameter\n        active_at_or_after_timestamp (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'code', 'fetch_all',\n        'only_actives', 'active_at_timestamp', 'active_after_timestamp',\n        'active_at_or_after_timestamp', 'skip', 'limit', 'like', 'join',\n        'count']\n    params.get('not_in'), params.get('code'), params.get('fetch_all'\n        ), params.get('only_actives'), params.get('active_at_timestamp'\n        ), params.get('active_after_timestamp'), params.get(\n        'active_at_or_after_timestamp'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_downtimes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/services/{uuid}/downtimes',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_downtimes_create","title":"<code>services_downtimes_create(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Add Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_downtimes_create(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/services/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_downtimes_create_bulk","title":"<code>services_downtimes_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_downtimes_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_downtimes_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/services/bulk/create/downtimes', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_downtimes_delete","title":"<code>services_downtimes_delete(uuid, uuid_downtime, kwargs=None)</code>","text":"<p>Remove Downtime</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_downtime</code> <code>(str, required)</code> <p>uuid_downtime</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_downtimes_delete(self, uuid: str, uuid_downtime: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Downtime\n\n    Args:\n        uuid (str, required): uuid\n        uuid_downtime (str, required): uuid_downtime\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/services/{uuid}/downtimes/{uuid_downtime}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_downtimes_delete_bulk","title":"<code>services_downtimes_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Downtimes</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_downtime\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_downtimes_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Downtimes\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_downtime\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/services/bulk/delete/downtimes', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_last_status_by_automaton_id_query","title":"<code>services_last_status_by_automaton_id_query(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query Last Status By Automaton Id</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_last_status_by_automaton_id_query(self,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query Last Status By Automaton Id\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_company_name (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        group_uuid_virtual_domain (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        service_uuid_parent (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        service_profile (string optional): additional filter - parameter\n        service_name (string optional): additional filter - parameter\n        service_description (string optional): additional filter - parameter\n        service_status (string optional): additional filter - parameter\n        service_uuid_customer (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ranking (integer optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n        'customer_company_name', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type',\n        'group_uuid_virtual_domain', 'uuid_object', 'object_name',\n        'object_status', 'object_profile', 'uuid_metric_type',\n        'metric_type_name', 'metric_type_status', 'uuid_metric',\n        'metric_name', 'metric_status', 'metric_profile',\n        'service_uuid_parent', 'uuid_service', 'service_profile',\n        'service_name', 'service_description', 'service_status',\n        'service_uuid_customer', 'timestamp_start', 'timestamp_end',\n        'database_timestamp_start', 'database_timestamp_end', 'status',\n        'ranking', 'description', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_company_name'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('group_uuid_virtual_domain'), params.get(\n        'uuid_object'), params.get('object_name'), params.get(\n        'object_status'), params.get('object_profile'), params.get(\n        'uuid_metric_type'), params.get('metric_type_name'), params.get(\n        'metric_type_status'), params.get('uuid_metric'), params.get(\n        'metric_name'), params.get('metric_status'), params.get(\n        'metric_profile'), params.get('service_uuid_parent'), params.get(\n        'uuid_service'), params.get('service_profile'), params.get(\n        'service_name'), params.get('service_description'), params.get(\n        'service_status'), params.get('service_uuid_customer'), params.get(\n        'timestamp_start'), params.get('timestamp_end'), params.get(\n        'database_timestamp_start'), params.get('database_timestamp_end'\n        ), params.get('status'), params.get('ranking'), params.get(\n        'description'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            services_last_status_by_automaton_id_query.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/services/query/last_status/by_automaton_id', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_last_status_query","title":"<code>services_last_status_query(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query Last Status</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>value</code> <code>number optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_last_status_query(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query Last Status\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_data_profile (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_company_name (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        group_uuid_virtual_domain (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        service_uuid_parent (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        service_profile (string optional): additional filter - parameter\n        service_name (string optional): additional filter - parameter\n        service_description (string optional): additional filter - parameter\n        service_status (string optional): additional filter - parameter\n        service_uuid_customer (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ranking (integer optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        unit (string optional): additional filter - parameter\n        value (number optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_data_profile', 'sort_by',\n        'null_fields', 'uuid_customer', 'customer_company_name',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'group_uuid_virtual_domain', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'service_uuid_parent', 'uuid_service', 'service_profile',\n        'service_name', 'service_description', 'service_status',\n        'service_uuid_customer', 'timestamp_start', 'timestamp_end',\n        'database_timestamp_start', 'database_timestamp_end', 'status',\n        'ranking', 'description', 'unit', 'value', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('extract_data_profile'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('uuid_customer'), params.get(\n        'customer_company_name'), params.get('customer_code'), params.get(\n        'customer_status'), params.get('uuid_site'), params.get('site_code'\n        ), params.get('site_description'), params.get('site_address'\n        ), params.get('site_zip_code'), params.get('site_city'\n        ), params.get('site_country'), params.get('site_state_province'\n        ), params.get('site_status'), params.get('uuid_group'), params.get(\n        'group_name'), params.get('group_status'), params.get('group_type'\n        ), params.get('group_uuid_virtual_domain'), params.get(\n        'uuid_object'), params.get('object_name'), params.get(\n        'object_status'), params.get('object_profile'), params.get(\n        'uuid_metric_type'), params.get('metric_type_name'), params.get(\n        'metric_type_status'), params.get('uuid_metric'), params.get(\n        'metric_name'), params.get('metric_status'), params.get(\n        'metric_profile'), params.get('service_uuid_parent'), params.get(\n        'uuid_service'), params.get('service_profile'), params.get(\n        'service_name'), params.get('service_description'), params.get(\n        'service_status'), params.get('service_uuid_customer'), params.get(\n        'timestamp_start'), params.get('timestamp_end'), params.get(\n        'database_timestamp_start'), params.get('database_timestamp_end'\n        ), params.get('status'), params.get('ranking'), params.get(\n        'description'), params.get('unit'), params.get('value'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_last_status_query.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=f'/services/query/last_status',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_last_status_query_bulk","title":"<code>services_last_status_query_bulk(payload=False, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query Last Status List</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>{     \"uuid_customer\": \"array\", optional     \"customer_company_name\": \"array\", optional     \"customer_code\": \"array\", optional     \"customer_status\": \"array\", optional     \"uuid_site\": \"array\", optional     \"site_code\": \"array\", optional     \"site_description\": \"array\", optional     \"site_address\": \"array\", optional     \"site_zip_code\": \"array\", optional     \"site_city\": \"array\", optional     \"site_country\": \"array\", optional     \"site_state_province\": \"array\", optional     \"site_status\": \"array\", optional     \"uuid_group\": \"array\", optional     \"group_name\": \"array\", optional     \"group_status\": \"array\", optional     \"group_type\": \"array\", optional     \"group_uuid_virtual_domain\": \"array\", optional     \"uuid_object\": \"array\", optional     \"object_name\": \"array\", optional     \"object_status\": \"array\", optional     \"object_profile\": \"array\", optional     \"uuid_metric_type\": \"array\", optional     \"metric_type_name\": \"array\", optional     \"metric_type_status\": \"array\", optional     \"uuid_metric\": \"array\", optional     \"metric_name\": \"array\", optional     \"metric_status\": \"array\", optional     \"metric_profile\": \"array\", optional     \"service_uuid_parent\": \"array\", optional     \"uuid_service\": \"array\", optional     \"service_profile\": \"array\", optional     \"service_name\": \"array\", optional     \"service_description\": \"array\", optional     \"service_status\": \"array\", optional     \"service_uuid_customer\": \"array\", optional     \"status\": \"array\", optional     \"ranking\": \"array\", optional     \"description\": \"array\", optional     \"unit\": \"array\", optional     \"value\": \"array\", optional    }</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_last_status_query_bulk(self, payload: dict = False,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query Last Status List\n\n    Args:\n        payload (dict, optional): additional parameters for the API.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_data_profile (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n       {\n        \"uuid_customer\": \"array\", optional\n        \"customer_company_name\": \"array\", optional\n        \"customer_code\": \"array\", optional\n        \"customer_status\": \"array\", optional\n        \"uuid_site\": \"array\", optional\n        \"site_code\": \"array\", optional\n        \"site_description\": \"array\", optional\n        \"site_address\": \"array\", optional\n        \"site_zip_code\": \"array\", optional\n        \"site_city\": \"array\", optional\n        \"site_country\": \"array\", optional\n        \"site_state_province\": \"array\", optional\n        \"site_status\": \"array\", optional\n        \"uuid_group\": \"array\", optional\n        \"group_name\": \"array\", optional\n        \"group_status\": \"array\", optional\n        \"group_type\": \"array\", optional\n        \"group_uuid_virtual_domain\": \"array\", optional\n        \"uuid_object\": \"array\", optional\n        \"object_name\": \"array\", optional\n        \"object_status\": \"array\", optional\n        \"object_profile\": \"array\", optional\n        \"uuid_metric_type\": \"array\", optional\n        \"metric_type_name\": \"array\", optional\n        \"metric_type_status\": \"array\", optional\n        \"uuid_metric\": \"array\", optional\n        \"metric_name\": \"array\", optional\n        \"metric_status\": \"array\", optional\n        \"metric_profile\": \"array\", optional\n        \"service_uuid_parent\": \"array\", optional\n        \"uuid_service\": \"array\", optional\n        \"service_profile\": \"array\", optional\n        \"service_name\": \"array\", optional\n        \"service_description\": \"array\", optional\n        \"service_status\": \"array\", optional\n        \"service_uuid_customer\": \"array\", optional\n        \"status\": \"array\", optional\n        \"ranking\": \"array\", optional\n        \"description\": \"array\", optional\n        \"unit\": \"array\", optional\n        \"value\": \"array\", optional\n       }\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_data_profile', 'sort_by',\n        'null_fields', 'timestamp_start', 'timestamp_end',\n        'database_timestamp_start', 'database_timestamp_end', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('extract_data_profile'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('timestamp_start'), params.get(\n        'timestamp_end'), params.get('database_timestamp_start'\n        ), params.get('database_timestamp_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_last_status_query_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/services/query/last_status',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_last_status_query_bulk_v2","title":"<code>services_last_status_query_bulk_v2(payload=False, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query Last Status List V2</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>{     \"uuid_customer\": \"array\", optional     \"customer_company_name\": \"array\", optional     \"customer_code\": \"array\", optional     \"customer_status\": \"array\", optional     \"uuid_site\": \"array\", optional     \"site_code\": \"array\", optional     \"site_description\": \"array\", optional     \"site_address\": \"array\", optional     \"site_zip_code\": \"array\", optional     \"site_city\": \"array\", optional     \"site_country\": \"array\", optional     \"site_state_province\": \"array\", optional     \"site_status\": \"array\", optional     \"uuid_group\": \"array\", optional     \"group_name\": \"array\", optional     \"group_status\": \"array\", optional     \"group_type\": \"array\", optional     \"group_uuid_virtual_domain\": \"array\", optional     \"uuid_object\": \"array\", optional     \"object_name\": \"array\", optional     \"object_status\": \"array\", optional     \"object_profile\": \"array\", optional     \"uuid_metric_type\": \"array\", optional     \"metric_type_name\": \"array\", optional     \"metric_type_status\": \"array\", optional     \"uuid_metric\": \"array\", optional     \"metric_name\": \"array\", optional     \"metric_status\": \"array\", optional     \"metric_profile\": \"array\", optional     \"service_uuid_parent\": \"array\", optional     \"uuid_service\": \"array\", optional     \"service_profile\": \"array\", optional     \"service_name\": \"array\", optional     \"service_description\": \"array\", optional     \"service_status\": \"array\", optional     \"service_uuid_customer\": \"array\", optional     \"status\": \"array\", optional     \"ranking\": \"array\", optional     \"description\": \"array\", optional     \"unit\": \"array\", optional     \"value\": \"array\", optional     \"fields_to_select\": \"array\", optional    }</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_last_status_query_bulk_v2(self, payload: dict = False,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query Last Status List V2\n\n    Args:\n        payload (dict, optional): additional parameters for the API.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_data_profile (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n       {\n        \"uuid_customer\": \"array\", optional\n        \"customer_company_name\": \"array\", optional\n        \"customer_code\": \"array\", optional\n        \"customer_status\": \"array\", optional\n        \"uuid_site\": \"array\", optional\n        \"site_code\": \"array\", optional\n        \"site_description\": \"array\", optional\n        \"site_address\": \"array\", optional\n        \"site_zip_code\": \"array\", optional\n        \"site_city\": \"array\", optional\n        \"site_country\": \"array\", optional\n        \"site_state_province\": \"array\", optional\n        \"site_status\": \"array\", optional\n        \"uuid_group\": \"array\", optional\n        \"group_name\": \"array\", optional\n        \"group_status\": \"array\", optional\n        \"group_type\": \"array\", optional\n        \"group_uuid_virtual_domain\": \"array\", optional\n        \"uuid_object\": \"array\", optional\n        \"object_name\": \"array\", optional\n        \"object_status\": \"array\", optional\n        \"object_profile\": \"array\", optional\n        \"uuid_metric_type\": \"array\", optional\n        \"metric_type_name\": \"array\", optional\n        \"metric_type_status\": \"array\", optional\n        \"uuid_metric\": \"array\", optional\n        \"metric_name\": \"array\", optional\n        \"metric_status\": \"array\", optional\n        \"metric_profile\": \"array\", optional\n        \"service_uuid_parent\": \"array\", optional\n        \"uuid_service\": \"array\", optional\n        \"service_profile\": \"array\", optional\n        \"service_name\": \"array\", optional\n        \"service_description\": \"array\", optional\n        \"service_status\": \"array\", optional\n        \"service_uuid_customer\": \"array\", optional\n        \"status\": \"array\", optional\n        \"ranking\": \"array\", optional\n        \"description\": \"array\", optional\n        \"unit\": \"array\", optional\n        \"value\": \"array\", optional\n        \"fields_to_select\": \"array\", optional\n       }\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_data_profile', 'sort_by',\n        'null_fields', 'timestamp_start', 'timestamp_end',\n        'database_timestamp_start', 'database_timestamp_end', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('extract_data_profile'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('timestamp_start'), params.get(\n        'timestamp_end'), params.get('database_timestamp_start'\n        ), params.get('database_timestamp_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            services_last_status_query_bulk_v2.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/services/query/last_status_v2', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_last_status_query_v2","title":"<code>services_last_status_query_v2(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query Last Status V2</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_data_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>value</code> <code>number optional</code> <p>additional filter - parameter</p> <code>fields_to_select</code> <code>array optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_last_status_query_v2(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query Last Status V2\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_data_profile (string optional): additional filter - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_company_name (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        group_uuid_virtual_domain (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        service_uuid_parent (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        service_profile (string optional): additional filter - parameter\n        service_name (string optional): additional filter - parameter\n        service_description (string optional): additional filter - parameter\n        service_status (string optional): additional filter - parameter\n        service_uuid_customer (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ranking (integer optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        unit (string optional): additional filter - parameter\n        value (number optional): additional filter - parameter\n        fields_to_select (array optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_data_profile', 'sort_by',\n        'null_fields', 'uuid_customer', 'customer_company_name',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'group_uuid_virtual_domain', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'service_uuid_parent', 'uuid_service', 'service_profile',\n        'service_name', 'service_description', 'service_status',\n        'service_uuid_customer', 'timestamp_start', 'timestamp_end',\n        'database_timestamp_start', 'database_timestamp_end', 'status',\n        'ranking', 'description', 'unit', 'value', 'fields_to_select',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('extract_data_profile'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('uuid_customer'), params.get(\n        'customer_company_name'), params.get('customer_code'), params.get(\n        'customer_status'), params.get('uuid_site'), params.get('site_code'\n        ), params.get('site_description'), params.get('site_address'\n        ), params.get('site_zip_code'), params.get('site_city'\n        ), params.get('site_country'), params.get('site_state_province'\n        ), params.get('site_status'), params.get('uuid_group'), params.get(\n        'group_name'), params.get('group_status'), params.get('group_type'\n        ), params.get('group_uuid_virtual_domain'), params.get(\n        'uuid_object'), params.get('object_name'), params.get(\n        'object_status'), params.get('object_profile'), params.get(\n        'uuid_metric_type'), params.get('metric_type_name'), params.get(\n        'metric_type_status'), params.get('uuid_metric'), params.get(\n        'metric_name'), params.get('metric_status'), params.get(\n        'metric_profile'), params.get('service_uuid_parent'), params.get(\n        'uuid_service'), params.get('service_profile'), params.get(\n        'service_name'), params.get('service_description'), params.get(\n        'service_status'), params.get('service_uuid_customer'), params.get(\n        'timestamp_start'), params.get('timestamp_end'), params.get(\n        'database_timestamp_start'), params.get('database_timestamp_end'\n        ), params.get('status'), params.get('ranking'), params.get(\n        'description'), params.get('unit'), params.get('value'\n        ), params.get('fields_to_select'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_last_status_query_v2.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/services/query/last_status_v2', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_metrics","title":"<code>services_metrics(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Metrics</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_metrics(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Metrics\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'status', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_metrics.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/services/{uuid}/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_metrics_bulk","title":"<code>services_metrics_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_metrics_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_metrics_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/services/bulk/read/metrics/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_metrics_create","title":"<code>services_metrics_create(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Add Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_metrics_create(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/services/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_metrics_create_bulk","title":"<code>services_metrics_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_metrics_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_metrics_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/services/bulk/create/metrics', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_metrics_delete","title":"<code>services_metrics_delete(uuid, uuid_metric, kwargs=None)</code>","text":"<p>Remove Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_metrics_delete(self, uuid: str, uuid_metric: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Metric\n\n    Args:\n        uuid (str, required): uuid\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/services/{uuid}/metrics/{uuid_metric}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_metrics_delete_bulk","title":"<code>services_metrics_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric\": \"string\", required     \"uuid_service\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_metrics_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric\": \"string\", required\n        \"uuid_service\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/services/bulk/delete/metrics', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_put","title":"<code>services_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Service</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_parent</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>automata_domain</code> <code>array object optional</code> <p>additional filter - payload</p> <code>rule</code> <code>array object optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Service\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_parent (string optional): additional filter - payload\n        uuid_customer (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        automata_domain (array object optional): additional filter - payload\n        rule (array object optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_parent', 'uuid_customer', 'profile',\n        'name', 'description', 'automata_domain', 'rule', 'status']\n    payload.get('uuid_parent'), payload.get('uuid_customer'), payload.get(\n        'profile'), payload.get('name'), payload.get('description'\n        ), payload.get('automata_domain'), payload.get('rule'\n        ), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/services/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_query","title":"<code>services_query(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>service_uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_query(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_company_name (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_metric_type (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        service_uuid_parent (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        service_profile (string optional): additional filter - parameter\n        service_name (string optional): additional filter - parameter\n        service_description (string optional): additional filter - parameter\n        service_status (string optional): additional filter - parameter\n        service_uuid_customer (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n        'customer_company_name', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_metric_type', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'service_uuid_parent', 'uuid_service', 'service_profile',\n        'service_name', 'service_description', 'service_status',\n        'service_uuid_customer', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_company_name'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('uuid_metric_type'), params.get('metric_type_name'\n        ), params.get('metric_type_status'), params.get('uuid_metric'\n        ), params.get('metric_name'), params.get('metric_status'\n        ), params.get('metric_profile'), params.get('service_uuid_parent'\n        ), params.get('uuid_service'), params.get('service_profile'\n        ), params.get('service_name'), params.get('service_description'\n        ), params.get('service_status'), params.get('service_uuid_customer'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_query.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/services/query/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_query_bulk","title":"<code>services_query_bulk(payload=False, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Service Query Lists</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Examples:</p> <p>payload = </p> <p>{     \"uuid_customer\": \"array\", optional     \"customer_company_name\": \"array\", optional     \"customer_code\": \"array\", optional     \"customer_status\": \"array\", optional     \"uuid_site\": \"array\", optional     \"site_code\": \"array\", optional     \"site_description\": \"array\", optional     \"site_address\": \"array\", optional     \"site_zip_code\": \"array\", optional     \"site_city\": \"array\", optional     \"site_country\": \"array\", optional     \"site_state_province\": \"array\", optional     \"site_status\": \"array\", optional     \"uuid_group\": \"array\", optional     \"group_name\": \"array\", optional     \"group_status\": \"array\", optional     \"group_type\": \"array\", optional     \"uuid_object\": \"array\", optional     \"object_name\": \"array\", optional     \"object_status\": \"array\", optional     \"object_profile\": \"array\", optional     \"uuid_metric_type\": \"array\", optional     \"metric_type_name\": \"array\", optional     \"metric_type_status\": \"array\", optional     \"uuid_metric\": \"array\", optional     \"metric_name\": \"array\", optional     \"metric_status\": \"array\", optional     \"metric_profile\": \"array\", optional     \"service_uuid_parent\": \"array\", optional     \"uuid_service\": \"array\", optional     \"service_profile\": \"array\", optional     \"service_name\": \"array\", optional     \"service_description\": \"array\", optional     \"service_status\": \"array\", optional     \"service_uuid_customer\": \"array\", optional    }</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_query_bulk(self, payload: dict = False,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Service Query Lists\n\n    Args:\n        payload (dict, optional): additional parameters for the API.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Examples:\n        payload = \n       {\n        \"uuid_customer\": \"array\", optional\n        \"customer_company_name\": \"array\", optional\n        \"customer_code\": \"array\", optional\n        \"customer_status\": \"array\", optional\n        \"uuid_site\": \"array\", optional\n        \"site_code\": \"array\", optional\n        \"site_description\": \"array\", optional\n        \"site_address\": \"array\", optional\n        \"site_zip_code\": \"array\", optional\n        \"site_city\": \"array\", optional\n        \"site_country\": \"array\", optional\n        \"site_state_province\": \"array\", optional\n        \"site_status\": \"array\", optional\n        \"uuid_group\": \"array\", optional\n        \"group_name\": \"array\", optional\n        \"group_status\": \"array\", optional\n        \"group_type\": \"array\", optional\n        \"uuid_object\": \"array\", optional\n        \"object_name\": \"array\", optional\n        \"object_status\": \"array\", optional\n        \"object_profile\": \"array\", optional\n        \"uuid_metric_type\": \"array\", optional\n        \"metric_type_name\": \"array\", optional\n        \"metric_type_status\": \"array\", optional\n        \"uuid_metric\": \"array\", optional\n        \"metric_name\": \"array\", optional\n        \"metric_status\": \"array\", optional\n        \"metric_profile\": \"array\", optional\n        \"service_uuid_parent\": \"array\", optional\n        \"uuid_service\": \"array\", optional\n        \"service_profile\": \"array\", optional\n        \"service_name\": \"array\", optional\n        \"service_description\": \"array\", optional\n        \"service_status\": \"array\", optional\n        \"service_uuid_customer\": \"array\", optional\n       }\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.services_query_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/services/query/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.services/#hive.cookbook.services.Services.services_read_by_bulk","title":"<code>services_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Read Services By Uuid Customer And Name And Profile</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_customer\": \"string\", required     \"profile\": \"string\", required     \"name\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/services.py</code> <pre><code>def services_read_by_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Services By Uuid Customer And Name And Profile\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_customer\": \"string\", required\n        \"profile\": \"string\", required\n        \"name\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/services/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/","title":"Hive.cookbook.sites","text":""},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites","title":"<code>Sites</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata sites APIs</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>class Sites(ApiManager):\n    \"\"\"Class that handles all the XAutomata sites APIs\"\"\"\n\n    def sites(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Sites\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            not_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            address (string optional): additional filter - parameter\n            zip_code (string optional): additional filter - parameter\n            city (string optional): additional filter - parameter\n            country (string optional): additional filter - parameter\n            notes (string optional): additional filter - parameter\n            state_province (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            severity (string optional): additional filter - parameter\n            filter_group_types (string optional): additional filter - parameter\n            count_children (boolean optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'not_fields',\n            'uuid_customer', 'type', 'code', 'description', 'address',\n            'zip_code', 'city', 'country', 'notes', 'state_province',\n            'status', 'severity', 'filter_group_types', 'count_children',\n            'extract_severity', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'not_fields'), params.get('uuid_customer'), params.get('type'\n            ), params.get('code'), params.get('description'), params.get(\n            'address'), params.get('zip_code'), params.get('city'), params.get(\n            'country'), params.get('notes'), params.get('state_province'\n            ), params.get('status'), params.get('severity'), params.get(\n            'filter_group_types'), params.get('count_children'), params.get(\n            'extract_severity'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/sites/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def sites_create(self, params: dict = False, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Site\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            geocode (boolean optional): additional filter - parameter\n            uuid_customer (string required): additional filter - payload\n            type (string optional): additional filter - payload\n            code (string required): additional filter - payload\n            description (string required): additional filter - payload\n            address (string required): additional filter - payload\n            zip_code (string required): additional filter - payload\n            city (string required): additional filter - payload\n            country (string required): additional filter - payload\n            notes (string optional): additional filter - payload\n            state_province (string required): additional filter - payload\n            status (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'type', 'code',\n            'description', 'address', 'zip_code', 'city', 'country',\n            'notes', 'state_province', 'status']\n        payload.get('uuid_customer'), payload.get('type'), payload.get('code'\n            ), payload.get('description'), payload.get('address'), payload.get(\n            'zip_code'), payload.get('city'), payload.get('country'\n            ), payload.get('notes'), payload.get('state_province'\n            ), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/sites/', params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def site(self, uuid: str, warm_start: bool = False, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Read Site\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.site.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/sites/{uuid}', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def sites_put(self, uuid: str, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Site\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            geocode (boolean optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - payload\n            type (string optional): additional filter - payload\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            address (string optional): additional filter - payload\n            zip_code (string optional): additional filter - payload\n            city (string optional): additional filter - payload\n            country (string optional): additional filter - payload\n            notes (string optional): additional filter - payload\n            state_province (string optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_customer', 'type', 'code',\n            'description', 'address', 'zip_code', 'city', 'country',\n            'notes', 'state_province', 'status']\n        payload.get('uuid_customer'), payload.get('type'), payload.get('code'\n            ), payload.get('description'), payload.get('address'), payload.get(\n            'zip_code'), payload.get('city'), payload.get('country'\n            ), payload.get('notes'), payload.get('state_province'\n            ), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/sites/{uuid}', params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def sites_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Site\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/sites/{uuid}', **kwargs)\n        return response\n\n    def sites_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/sites/{uuid}/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def sites_contacts(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Contacts\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            type (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'type', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('type'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_contacts.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/sites/{uuid}/contacts',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def sites_contacts_create(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_contacts_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/sites/{uuid}/contacts/{uuid_contact}', payload=payload, **kwargs\n            )\n        return response\n\n    def sites_contacts_put(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            type (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['type']\n        payload.get('type')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_contacts_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/sites/{uuid}/contacts/{uuid_contact}', payload=payload, **kwargs\n            )\n        return response\n\n    def sites_contacts_delete(self, uuid: str, uuid_contact: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Contact\n\n        Args:\n            uuid (str, required): uuid\n            uuid_contact (str, required): uuid_contact\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/sites/{uuid}/contacts/{uuid_contact}', **kwargs)\n        return response\n\n    def sites_coordinates(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Coordinates\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_site (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_site', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_site'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_coordinates.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/sites/coordinates/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def sites_coordinates_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Coordinates\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            longitude (number required): additional filter - payload\n            latitude (number required): additional filter - payload\n            uuid_site (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['longitude', 'latitude', 'uuid_site']\n        payload.get('longitude'), payload.get('latitude'), payload.get(\n            'uuid_site')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_coordinates_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/sites/coordinates/',\n            payload=payload, **kwargs)\n        return response\n\n    def sites_coordinates_put(self, uuid_site: str, kwargs: dict = None, **\n        payload) -&gt; list:\n        \"\"\"Update Coordinates\n\n        Args:\n            uuid_site (str, required): uuid_site\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            longitude (number optional): additional filter - payload\n            latitude (number optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['longitude', 'latitude']\n        payload.get('longitude'), payload.get('latitude')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_coordinates_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/sites/coordinates/{uuid_site}', payload=payload, **kwargs)\n        return response\n\n    def sites_coordinates_delete(self, uuid_site: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Coordinates\n\n        Args:\n            uuid_site (str, required): uuid_site\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/sites/coordinates/{uuid_site}', **kwargs)\n        return response\n\n    def sites_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Sites\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/sites/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def sites_read_by_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Read Sites By Uuid Customer And Code\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_customer\": \"string\", required\n            \"code\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/sites/bulk/read_by/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, payload=payload, **kwargs)\n        return response\n\n    def sites_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Sites\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            geocode (boolean optional): additional filter - parameter\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_customer\": \"string\", required\n            \"type\": \"string\", optional\n            \"code\": \"string\", required\n            \"description\": \"string\", required\n            \"address\": \"string\", required\n            \"zip_code\": \"string\", required\n            \"city\": \"string\", required\n            \"country\": \"string\", required\n            \"notes\": \"string\", optional\n            \"state_province\": \"string\", required\n            \"status\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['geocode', 'best_effort']\n        params.get('geocode'), params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/sites/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def sites_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Sites\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/sites/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def sites_contacts_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_site\": \"string\", required\n            \"type\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_contacts_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=f'/sites/bulk/create/contacts',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def sites_contacts_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Contacts\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_contact\": \"string\", required\n            \"uuid_site\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/sites/bulk/delete/contacts',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def sites_coordinates_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Coordinates\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"longitude\": \"number\", required\n            \"latitude\": \"number\", required\n            \"uuid_site\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.sites_coordinates_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/sites/coordinates/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.site","title":"<code>site(uuid, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Site</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def site(self, uuid: str, warm_start: bool = False, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Read Site\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.site.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/sites/{uuid}', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites","title":"<code>sites(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Sites</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>not_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>notes</code> <code>string optional</code> <p>additional filter - parameter</p> <code>state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>severity</code> <code>string optional</code> <p>additional filter - parameter</p> <code>filter_group_types</code> <code>string optional</code> <p>additional filter - parameter</p> <code>count_children</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Sites\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        not_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        address (string optional): additional filter - parameter\n        zip_code (string optional): additional filter - parameter\n        city (string optional): additional filter - parameter\n        country (string optional): additional filter - parameter\n        notes (string optional): additional filter - parameter\n        state_province (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        severity (string optional): additional filter - parameter\n        filter_group_types (string optional): additional filter - parameter\n        count_children (boolean optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'not_fields',\n        'uuid_customer', 'type', 'code', 'description', 'address',\n        'zip_code', 'city', 'country', 'notes', 'state_province',\n        'status', 'severity', 'filter_group_types', 'count_children',\n        'extract_severity', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'not_fields'), params.get('uuid_customer'), params.get('type'\n        ), params.get('code'), params.get('description'), params.get(\n        'address'), params.get('zip_code'), params.get('city'), params.get(\n        'country'), params.get('notes'), params.get('state_province'\n        ), params.get('status'), params.get('severity'), params.get(\n        'filter_group_types'), params.get('count_children'), params.get(\n        'extract_severity'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/sites/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_bulk","title":"<code>sites_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Sites</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Sites\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/sites/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_contacts","title":"<code>sites_contacts(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Contacts</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_contacts(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Contacts\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        type (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'type', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('type'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_contacts.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/sites/{uuid}/contacts',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_contacts_create","title":"<code>sites_contacts_create(uuid, uuid_contact, kwargs=None, **payload)</code>","text":"<p>Add Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_contacts_create(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_contacts_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/sites/{uuid}/contacts/{uuid_contact}', payload=payload, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_contacts_create_bulk","title":"<code>sites_contacts_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_site\": \"string\", required     \"type\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_contacts_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_site\": \"string\", required\n        \"type\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_contacts_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=f'/sites/bulk/create/contacts',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_contacts_delete","title":"<code>sites_contacts_delete(uuid, uuid_contact, kwargs=None)</code>","text":"<p>Remove Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_contacts_delete(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/sites/{uuid}/contacts/{uuid_contact}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_contacts_delete_bulk","title":"<code>sites_contacts_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Contacts</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_contact\": \"string\", required     \"uuid_site\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_contacts_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Contacts\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_contact\": \"string\", required\n        \"uuid_site\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/sites/bulk/delete/contacts',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_contacts_put","title":"<code>sites_contacts_put(uuid, uuid_contact, kwargs=None, **payload)</code>","text":"<p>Update Contact</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_contact</code> <code>(str, required)</code> <p>uuid_contact</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>type</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_contacts_put(self, uuid: str, uuid_contact: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Contact\n\n    Args:\n        uuid (str, required): uuid\n        uuid_contact (str, required): uuid_contact\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        type (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['type']\n    payload.get('type')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_contacts_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/sites/{uuid}/contacts/{uuid_contact}', payload=payload, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_coordinates","title":"<code>sites_coordinates(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Coordinates</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_coordinates(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Coordinates\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_site (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_site', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_site'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_coordinates.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/sites/coordinates/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_coordinates_create","title":"<code>sites_coordinates_create(kwargs=None, **payload)</code>","text":"<p>Create Coordinates</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>longitude</code> <code>number required</code> <p>additional filter - payload</p> <code>latitude</code> <code>number required</code> <p>additional filter - payload</p> <code>uuid_site</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_coordinates_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Coordinates\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        longitude (number required): additional filter - payload\n        latitude (number required): additional filter - payload\n        uuid_site (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['longitude', 'latitude', 'uuid_site']\n    payload.get('longitude'), payload.get('latitude'), payload.get(\n        'uuid_site')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_coordinates_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/sites/coordinates/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_coordinates_create_bulk","title":"<code>sites_coordinates_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Coordinates</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"longitude\": \"number\", required     \"latitude\": \"number\", required     \"uuid_site\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_coordinates_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Coordinates\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"longitude\": \"number\", required\n        \"latitude\": \"number\", required\n        \"uuid_site\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_coordinates_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/sites/coordinates/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_coordinates_delete","title":"<code>sites_coordinates_delete(uuid_site, kwargs=None)</code>","text":"<p>Delete Coordinates</p> <p>Parameters:</p> Name Type Description Default <code>uuid_site</code> <code>(str, required)</code> <p>uuid_site</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_coordinates_delete(self, uuid_site: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Coordinates\n\n    Args:\n        uuid_site (str, required): uuid_site\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/sites/coordinates/{uuid_site}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_coordinates_put","title":"<code>sites_coordinates_put(uuid_site, kwargs=None, **payload)</code>","text":"<p>Update Coordinates</p> <p>Parameters:</p> Name Type Description Default <code>uuid_site</code> <code>(str, required)</code> <p>uuid_site</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>longitude</code> <code>number optional</code> <p>additional filter - payload</p> <code>latitude</code> <code>number optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_coordinates_put(self, uuid_site: str, kwargs: dict = None, **\n    payload) -&gt; list:\n    \"\"\"Update Coordinates\n\n    Args:\n        uuid_site (str, required): uuid_site\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        longitude (number optional): additional filter - payload\n        latitude (number optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['longitude', 'latitude']\n    payload.get('longitude'), payload.get('latitude')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_coordinates_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/sites/coordinates/{uuid_site}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_create","title":"<code>sites_create(params=False, kwargs=None, **payload)</code>","text":"<p>Create Site</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>geocode</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string required</code> <p>additional filter - payload</p> <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string required</code> <p>additional filter - payload</p> <code>address</code> <code>string required</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string required</code> <p>additional filter - payload</p> <code>city</code> <code>string required</code> <p>additional filter - payload</p> <code>country</code> <code>string required</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string required</code> <p>additional filter - payload</p> <code>status</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_create(self, params: dict = False, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Site\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        geocode (boolean optional): additional filter - parameter\n        uuid_customer (string required): additional filter - payload\n        type (string optional): additional filter - payload\n        code (string required): additional filter - payload\n        description (string required): additional filter - payload\n        address (string required): additional filter - payload\n        zip_code (string required): additional filter - payload\n        city (string required): additional filter - payload\n        country (string required): additional filter - payload\n        notes (string optional): additional filter - payload\n        state_province (string required): additional filter - payload\n        status (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'type', 'code',\n        'description', 'address', 'zip_code', 'city', 'country',\n        'notes', 'state_province', 'status']\n    payload.get('uuid_customer'), payload.get('type'), payload.get('code'\n        ), payload.get('description'), payload.get('address'), payload.get(\n        'zip_code'), payload.get('city'), payload.get('country'\n        ), payload.get('notes'), payload.get('state_province'\n        ), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/sites/', params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_create_bulk","title":"<code>sites_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Sites</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>geocode</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_customer\": \"string\", required     \"type\": \"string\", optional     \"code\": \"string\", required     \"description\": \"string\", required     \"address\": \"string\", required     \"zip_code\": \"string\", required     \"city\": \"string\", required     \"country\": \"string\", required     \"notes\": \"string\", optional     \"state_province\": \"string\", required     \"status\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Sites\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        geocode (boolean optional): additional filter - parameter\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_customer\": \"string\", required\n        \"type\": \"string\", optional\n        \"code\": \"string\", required\n        \"description\": \"string\", required\n        \"address\": \"string\", required\n        \"zip_code\": \"string\", required\n        \"city\": \"string\", required\n        \"country\": \"string\", required\n        \"notes\": \"string\", optional\n        \"state_province\": \"string\", required\n        \"status\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['geocode', 'best_effort']\n    params.get('geocode'), params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/sites/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_delete","title":"<code>sites_delete(uuid, kwargs=None)</code>","text":"<p>Delete Site</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Site\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/sites/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_delete_bulk","title":"<code>sites_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Sites</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Sites\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/sites/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_groups","title":"<code>sites_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/sites/{uuid}/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_put","title":"<code>sites_put(uuid, params=False, kwargs=None, **payload)</code>","text":"<p>Update Site</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>geocode</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - payload</p> <code>type</code> <code>string optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>address</code> <code>string optional</code> <p>additional filter - payload</p> <code>zip_code</code> <code>string optional</code> <p>additional filter - payload</p> <code>city</code> <code>string optional</code> <p>additional filter - payload</p> <code>country</code> <code>string optional</code> <p>additional filter - payload</p> <code>notes</code> <code>string optional</code> <p>additional filter - payload</p> <code>state_province</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_put(self, uuid: str, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Site\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        geocode (boolean optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - payload\n        type (string optional): additional filter - payload\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        address (string optional): additional filter - payload\n        zip_code (string optional): additional filter - payload\n        city (string optional): additional filter - payload\n        country (string optional): additional filter - payload\n        notes (string optional): additional filter - payload\n        state_province (string optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_customer', 'type', 'code',\n        'description', 'address', 'zip_code', 'city', 'country',\n        'notes', 'state_province', 'status']\n    payload.get('uuid_customer'), payload.get('type'), payload.get('code'\n        ), payload.get('description'), payload.get('address'), payload.get(\n        'zip_code'), payload.get('city'), payload.get('country'\n        ), payload.get('notes'), payload.get('state_province'\n        ), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.sites_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/sites/{uuid}', params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.sites/#hive.cookbook.sites.Sites.sites_read_by_bulk","title":"<code>sites_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Read Sites By Uuid Customer And Code</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_customer\": \"string\", required     \"code\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/sites.py</code> <pre><code>def sites_read_by_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Read Sites By Uuid Customer And Code\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_customer\": \"string\", required\n        \"code\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/sites/bulk/read_by/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.terms_and_conditions/","title":"Hive.cookbook.terms and conditions","text":""},{"location":"hive.cookbook.terms_and_conditions/#hive.cookbook.terms_and_conditions.TermsAndConditions","title":"<code>TermsAndConditions</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata terms_and_conditions APIs</p> Source code in <code>hive/cookbook/terms_and_conditions.py</code> <pre><code>class TermsAndConditions(ApiManager):\n    \"\"\"Class that handles all the XAutomata terms_and_conditions APIs\"\"\"\n\n    def terms_and_conditions(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Terms And Conditions\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            version (integer optional): additional filter - parameter\n            privacy (string optional): additional filter - parameter\n            terms (string optional): additional filter - parameter\n            publication_date_start (string optional): additional filter - parameter\n            publication_date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'version',\n            'privacy', 'terms', 'publication_date_start',\n            'publication_date_end', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('version'\n            ), params.get('privacy'), params.get('terms'), params.get(\n            'publication_date_start'), params.get('publication_date_end'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.terms_and_conditions.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/terms_and_conditions/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def terms_and_conditions_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Terms And Conditions\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            privacy (string optional): additional filter - payload\n            terms (string optional): additional filter - payload\n            version (integer required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['privacy', 'terms', 'version']\n        payload.get('privacy'), payload.get('terms'), payload.get('version')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.terms_and_conditions_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/terms_and_conditions/',\n            payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.terms_and_conditions/#hive.cookbook.terms_and_conditions.TermsAndConditions.terms_and_conditions","title":"<code>terms_and_conditions(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Terms And Conditions</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>version</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>privacy</code> <code>string optional</code> <p>additional filter - parameter</p> <code>terms</code> <code>string optional</code> <p>additional filter - parameter</p> <code>publication_date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>publication_date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/terms_and_conditions.py</code> <pre><code>def terms_and_conditions(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Terms And Conditions\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        version (integer optional): additional filter - parameter\n        privacy (string optional): additional filter - parameter\n        terms (string optional): additional filter - parameter\n        publication_date_start (string optional): additional filter - parameter\n        publication_date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'version',\n        'privacy', 'terms', 'publication_date_start',\n        'publication_date_end', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('version'\n        ), params.get('privacy'), params.get('terms'), params.get(\n        'publication_date_start'), params.get('publication_date_end'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.terms_and_conditions.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/terms_and_conditions/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.terms_and_conditions/#hive.cookbook.terms_and_conditions.TermsAndConditions.terms_and_conditions_create","title":"<code>terms_and_conditions_create(kwargs=None, **payload)</code>","text":"<p>Create Terms And Conditions</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>privacy</code> <code>string optional</code> <p>additional filter - payload</p> <code>terms</code> <code>string optional</code> <p>additional filter - payload</p> <code>version</code> <code>integer required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/terms_and_conditions.py</code> <pre><code>def terms_and_conditions_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Terms And Conditions\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        privacy (string optional): additional filter - payload\n        terms (string optional): additional filter - payload\n        version (integer required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['privacy', 'terms', 'version']\n    payload.get('privacy'), payload.get('terms'), payload.get('version')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.terms_and_conditions_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/terms_and_conditions/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy/","title":"Hive.cookbook.tree hierarchy","text":""},{"location":"hive.cookbook.tree_hierarchy/#hive.cookbook.tree_hierarchy.TreeHierarchy","title":"<code>TreeHierarchy</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata tree_hierarchy APIs</p> Source code in <code>hive/cookbook/tree_hierarchy.py</code> <pre><code>class TreeHierarchy(ApiManager):\n    \"\"\"Class that handles all the XAutomata tree_hierarchy APIs\"\"\"\n\n    def tree_hierarchy_groups(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Groups\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            site_type (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            virtual_domain_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_severity', 'sort_by',\n            'null_fields', 'uuid_customer', 'customer_code',\n            'customer_status', 'uuid_site', 'site_code', 'site_description',\n            'site_address', 'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'site_type', 'uuid_group',\n            'group_name', 'group_status', 'group_type',\n            'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('extract_severity'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('uuid_customer'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('site_type'), params.get('uuid_group'\n            ), params.get('group_name'), params.get('group_status'\n            ), params.get('group_type'), params.get('uuid_virtual_domain'\n            ), params.get('virtual_domain_name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_groups.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def tree_hierarchy_objects(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Objects\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            extract_data_profile (boolean optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            extract_ip_cidr (boolean optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            virtual_domain_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields',\n            'extract_data_profile', 'extract_severity', 'extract_ip_cidr',\n            'uuid_customer', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'extract_data_profile'), params.get('extract_severity'\n            ), params.get('extract_ip_cidr'), params.get('uuid_customer'\n            ), params.get('customer_code'), params.get('customer_status'\n            ), params.get('uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('uuid_virtual_domain'), params.get(\n            'virtual_domain_name'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_objects.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy/objects',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def tree_hierarchy_metric_types(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Metric Types\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            metric_type_profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'uuid_object', 'object_name', 'object_status',\n            'object_profile', 'metric_type_name', 'metric_type_status',\n            'metric_type_profile', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_code'), params.get(\n            'customer_status'), params.get('uuid_site'), params.get('site_code'\n            ), params.get('site_description'), params.get('site_address'\n            ), params.get('site_zip_code'), params.get('site_city'\n            ), params.get('site_country'), params.get('site_state_province'\n            ), params.get('site_status'), params.get('uuid_group'), params.get(\n            'group_name'), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('metric_type_name'), params.get('metric_type_status'\n            ), params.get('metric_type_profile'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_metric_types.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy/metric_types',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def tree_hierarchy_metrics(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Metrics\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'uuid_object', 'object_name', 'object_status',\n            'object_profile', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_code'), params.get(\n            'customer_status'), params.get('uuid_site'), params.get('site_code'\n            ), params.get('site_description'), params.get('site_address'\n            ), params.get('site_zip_code'), params.get('site_city'\n            ), params.get('site_country'), params.get('site_state_province'\n            ), params.get('site_status'), params.get('uuid_group'), params.get(\n            'group_name'), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('metric_type_name'), params.get('metric_type_status'\n            ), params.get('uuid_metric'), params.get('metric_name'\n            ), params.get('metric_status'), params.get('metric_profile'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_metrics.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def tree_hierarchy_metrics_average(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Metrics Average\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'ts_start',\n            'ts_end', 'uuid_customer', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'metric_type_name', 'metric_type_status', 'uuid_metric',\n            'metric_name', 'metric_status', 'metric_profile', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('ts_start'\n            ), params.get('ts_end'), params.get('uuid_customer'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('metric_type_name'), params.get('metric_type_status'\n            ), params.get('uuid_metric'), params.get('metric_name'\n            ), params.get('metric_status'), params.get('metric_profile'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_metrics_average.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/tree_hierarchy/metrics/average/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy/#hive.cookbook.tree_hierarchy.TreeHierarchy.tree_hierarchy_groups","title":"<code>tree_hierarchy_groups(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Groups</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>virtual_domain_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy.py</code> <pre><code>def tree_hierarchy_groups(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Groups\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        site_type (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        virtual_domain_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_severity', 'sort_by',\n        'null_fields', 'uuid_customer', 'customer_code',\n        'customer_status', 'uuid_site', 'site_code', 'site_description',\n        'site_address', 'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'site_type', 'uuid_group',\n        'group_name', 'group_status', 'group_type',\n        'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('extract_severity'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('uuid_customer'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('site_type'), params.get('uuid_group'\n        ), params.get('group_name'), params.get('group_status'\n        ), params.get('group_type'), params.get('uuid_virtual_domain'\n        ), params.get('virtual_domain_name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_groups.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy/#hive.cookbook.tree_hierarchy.TreeHierarchy.tree_hierarchy_metric_types","title":"<code>tree_hierarchy_metric_types(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy.py</code> <pre><code>def tree_hierarchy_metric_types(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Metric Types\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        metric_type_profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'uuid_object', 'object_name', 'object_status',\n        'object_profile', 'metric_type_name', 'metric_type_status',\n        'metric_type_profile', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_code'), params.get(\n        'customer_status'), params.get('uuid_site'), params.get('site_code'\n        ), params.get('site_description'), params.get('site_address'\n        ), params.get('site_zip_code'), params.get('site_city'\n        ), params.get('site_country'), params.get('site_state_province'\n        ), params.get('site_status'), params.get('uuid_group'), params.get(\n        'group_name'), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('metric_type_name'), params.get('metric_type_status'\n        ), params.get('metric_type_profile'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_metric_types.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy/metric_types',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy/#hive.cookbook.tree_hierarchy.TreeHierarchy.tree_hierarchy_metrics","title":"<code>tree_hierarchy_metrics(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Metrics</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy.py</code> <pre><code>def tree_hierarchy_metrics(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Metrics\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'uuid_object', 'object_name', 'object_status',\n        'object_profile', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_code'), params.get(\n        'customer_status'), params.get('uuid_site'), params.get('site_code'\n        ), params.get('site_description'), params.get('site_address'\n        ), params.get('site_zip_code'), params.get('site_city'\n        ), params.get('site_country'), params.get('site_state_province'\n        ), params.get('site_status'), params.get('uuid_group'), params.get(\n        'group_name'), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('metric_type_name'), params.get('metric_type_status'\n        ), params.get('uuid_metric'), params.get('metric_name'\n        ), params.get('metric_status'), params.get('metric_profile'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_metrics.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy/#hive.cookbook.tree_hierarchy.TreeHierarchy.tree_hierarchy_metrics_average","title":"<code>tree_hierarchy_metrics_average(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Metrics Average</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy.py</code> <pre><code>def tree_hierarchy_metrics_average(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Metrics Average\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'ts_start',\n        'ts_end', 'uuid_customer', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'metric_type_name', 'metric_type_status', 'uuid_metric',\n        'metric_name', 'metric_status', 'metric_profile', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('ts_start'\n        ), params.get('ts_end'), params.get('uuid_customer'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('metric_type_name'), params.get('metric_type_status'\n        ), params.get('uuid_metric'), params.get('metric_name'\n        ), params.get('metric_status'), params.get('metric_profile'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_metrics_average.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/tree_hierarchy/metrics/average/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy/#hive.cookbook.tree_hierarchy.TreeHierarchy.tree_hierarchy_objects","title":"<code>tree_hierarchy_objects(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Objects</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_data_profile</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>extract_ip_cidr</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>virtual_domain_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy.py</code> <pre><code>def tree_hierarchy_objects(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Objects\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        extract_data_profile (boolean optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        extract_ip_cidr (boolean optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        virtual_domain_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields',\n        'extract_data_profile', 'extract_severity', 'extract_ip_cidr',\n        'uuid_customer', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'extract_data_profile'), params.get('extract_severity'\n        ), params.get('extract_ip_cidr'), params.get('uuid_customer'\n        ), params.get('customer_code'), params.get('customer_status'\n        ), params.get('uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('uuid_virtual_domain'), params.get(\n        'virtual_domain_name'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_objects.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy/objects',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy_v2/","title":"Hive.cookbook.tree hierarchy v2","text":""},{"location":"hive.cookbook.tree_hierarchy_v2/#hive.cookbook.tree_hierarchy_v2.TreeHierarchyV2","title":"<code>TreeHierarchyV2</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata tree_hierarchy_v2 APIs</p> Source code in <code>hive/cookbook/tree_hierarchy_v2.py</code> <pre><code>class TreeHierarchyV2(ApiManager):\n    \"\"\"Class that handles all the XAutomata tree_hierarchy_v2 APIs\"\"\"\n\n    def tree_hierarchy_v2_groups(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Groups\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            site_type (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            virtual_domain_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['extract_severity', 'sort_by',\n            'null_fields', 'uuid_customer', 'customer_code',\n            'customer_status', 'uuid_site', 'site_code', 'site_description',\n            'site_address', 'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'site_type', 'uuid_group',\n            'group_name', 'group_status', 'group_type',\n            'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('extract_severity'), params.get('sort_by'), params.get(\n            'null_fields'), params.get('uuid_customer'), params.get(\n            'customer_code'), params.get('customer_status'), params.get(\n            'uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('site_type'), params.get('uuid_group'\n            ), params.get('group_name'), params.get('group_status'\n            ), params.get('group_type'), params.get('uuid_virtual_domain'\n            ), params.get('virtual_domain_name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_v2_groups.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy_v2/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def tree_hierarchy_v2_objects(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Objects\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            extract_data_profile (boolean optional): additional filter - parameter\n            extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n            extract_ip_cidr (boolean optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            uuid_virtual_domain (string optional): additional filter - parameter\n            virtual_domain_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields',\n            'extract_data_profile', 'extract_severity', 'extract_ip_cidr',\n            'uuid_customer', 'customer_code', 'customer_status',\n            'uuid_site', 'site_code', 'site_description', 'site_address',\n            'site_zip_code', 'site_city', 'site_country',\n            'site_state_province', 'site_status', 'uuid_group',\n            'group_name', 'group_status', 'group_type', 'uuid_object',\n            'object_name', 'object_status', 'object_profile',\n            'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'extract_data_profile'), params.get('extract_severity'\n            ), params.get('extract_ip_cidr'), params.get('uuid_customer'\n            ), params.get('customer_code'), params.get('customer_status'\n            ), params.get('uuid_site'), params.get('site_code'), params.get(\n            'site_description'), params.get('site_address'), params.get(\n            'site_zip_code'), params.get('site_city'), params.get(\n            'site_country'), params.get('site_state_province'), params.get(\n            'site_status'), params.get('uuid_group'), params.get('group_name'\n            ), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('uuid_virtual_domain'), params.get(\n            'virtual_domain_name'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_v2_objects.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy_v2/objects',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def tree_hierarchy_v2_metric_types(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Metric Types\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            metric_type_profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'uuid_object', 'object_name', 'object_status',\n            'object_profile', 'metric_type_name', 'metric_type_status',\n            'metric_type_profile', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_code'), params.get(\n            'customer_status'), params.get('uuid_site'), params.get('site_code'\n            ), params.get('site_description'), params.get('site_address'\n            ), params.get('site_zip_code'), params.get('site_city'\n            ), params.get('site_country'), params.get('site_state_province'\n            ), params.get('site_status'), params.get('uuid_group'), params.get(\n            'group_name'), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('metric_type_name'), params.get('metric_type_status'\n            ), params.get('metric_type_profile'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_v2_metric_types.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/tree_hierarchy_v2/metric_types', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def tree_hierarchy_v2_metrics(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Tree Hierarchy Metrics\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            customer_code (string optional): additional filter - parameter\n            customer_status (string optional): additional filter - parameter\n            uuid_site (string optional): additional filter - parameter\n            site_code (string optional): additional filter - parameter\n            site_description (string optional): additional filter - parameter\n            site_address (string optional): additional filter - parameter\n            site_zip_code (string optional): additional filter - parameter\n            site_city (string optional): additional filter - parameter\n            site_country (string optional): additional filter - parameter\n            site_state_province (string optional): additional filter - parameter\n            site_status (string optional): additional filter - parameter\n            uuid_group (string optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            group_status (string optional): additional filter - parameter\n            group_type (string optional): additional filter - parameter\n            uuid_object (string optional): additional filter - parameter\n            object_name (string optional): additional filter - parameter\n            object_status (string optional): additional filter - parameter\n            object_profile (string optional): additional filter - parameter\n            metric_type_name (string optional): additional filter - parameter\n            metric_type_status (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            metric_name (string optional): additional filter - parameter\n            metric_status (string optional): additional filter - parameter\n            metric_profile (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n            'customer_code', 'customer_status', 'uuid_site', 'site_code',\n            'site_description', 'site_address', 'site_zip_code',\n            'site_city', 'site_country', 'site_state_province',\n            'site_status', 'uuid_group', 'group_name', 'group_status',\n            'group_type', 'uuid_object', 'object_name', 'object_status',\n            'object_profile', 'metric_type_name', 'metric_type_status',\n            'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_customer'), params.get('customer_code'), params.get(\n            'customer_status'), params.get('uuid_site'), params.get('site_code'\n            ), params.get('site_description'), params.get('site_address'\n            ), params.get('site_zip_code'), params.get('site_city'\n            ), params.get('site_country'), params.get('site_state_province'\n            ), params.get('site_status'), params.get('uuid_group'), params.get(\n            'group_name'), params.get('group_status'), params.get('group_type'\n            ), params.get('uuid_object'), params.get('object_name'\n            ), params.get('object_status'), params.get('object_profile'\n            ), params.get('metric_type_name'), params.get('metric_type_status'\n            ), params.get('uuid_metric'), params.get('metric_name'\n            ), params.get('metric_status'), params.get('metric_profile'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.tree_hierarchy_v2_metrics.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=f'/tree_hierarchy_v2/metrics',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy_v2/#hive.cookbook.tree_hierarchy_v2.TreeHierarchyV2.tree_hierarchy_v2_groups","title":"<code>tree_hierarchy_v2_groups(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Groups</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>virtual_domain_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy_v2.py</code> <pre><code>def tree_hierarchy_v2_groups(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Groups\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        site_type (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        virtual_domain_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['extract_severity', 'sort_by',\n        'null_fields', 'uuid_customer', 'customer_code',\n        'customer_status', 'uuid_site', 'site_code', 'site_description',\n        'site_address', 'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'site_type', 'uuid_group',\n        'group_name', 'group_status', 'group_type',\n        'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('extract_severity'), params.get('sort_by'), params.get(\n        'null_fields'), params.get('uuid_customer'), params.get(\n        'customer_code'), params.get('customer_status'), params.get(\n        'uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('site_type'), params.get('uuid_group'\n        ), params.get('group_name'), params.get('group_status'\n        ), params.get('group_type'), params.get('uuid_virtual_domain'\n        ), params.get('virtual_domain_name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_v2_groups.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy_v2/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy_v2/#hive.cookbook.tree_hierarchy_v2.TreeHierarchyV2.tree_hierarchy_v2_metric_types","title":"<code>tree_hierarchy_v2_metric_types(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Metric Types</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy_v2.py</code> <pre><code>def tree_hierarchy_v2_metric_types(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Metric Types\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        metric_type_profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'uuid_object', 'object_name', 'object_status',\n        'object_profile', 'metric_type_name', 'metric_type_status',\n        'metric_type_profile', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_code'), params.get(\n        'customer_status'), params.get('uuid_site'), params.get('site_code'\n        ), params.get('site_description'), params.get('site_address'\n        ), params.get('site_zip_code'), params.get('site_city'\n        ), params.get('site_country'), params.get('site_state_province'\n        ), params.get('site_status'), params.get('uuid_group'), params.get(\n        'group_name'), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('metric_type_name'), params.get('metric_type_status'\n        ), params.get('metric_type_profile'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_v2_metric_types.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/tree_hierarchy_v2/metric_types', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy_v2/#hive.cookbook.tree_hierarchy_v2.TreeHierarchyV2.tree_hierarchy_v2_metrics","title":"<code>tree_hierarchy_v2_metrics(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Metrics</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_type_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy_v2.py</code> <pre><code>def tree_hierarchy_v2_metrics(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Metrics\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        metric_type_name (string optional): additional filter - parameter\n        metric_type_status (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        metric_name (string optional): additional filter - parameter\n        metric_status (string optional): additional filter - parameter\n        metric_profile (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_customer',\n        'customer_code', 'customer_status', 'uuid_site', 'site_code',\n        'site_description', 'site_address', 'site_zip_code',\n        'site_city', 'site_country', 'site_state_province',\n        'site_status', 'uuid_group', 'group_name', 'group_status',\n        'group_type', 'uuid_object', 'object_name', 'object_status',\n        'object_profile', 'metric_type_name', 'metric_type_status',\n        'uuid_metric', 'metric_name', 'metric_status', 'metric_profile',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_customer'), params.get('customer_code'), params.get(\n        'customer_status'), params.get('uuid_site'), params.get('site_code'\n        ), params.get('site_description'), params.get('site_address'\n        ), params.get('site_zip_code'), params.get('site_city'\n        ), params.get('site_country'), params.get('site_state_province'\n        ), params.get('site_status'), params.get('uuid_group'), params.get(\n        'group_name'), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('metric_type_name'), params.get('metric_type_status'\n        ), params.get('uuid_metric'), params.get('metric_name'\n        ), params.get('metric_status'), params.get('metric_profile'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_v2_metrics.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy_v2/metrics',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.tree_hierarchy_v2/#hive.cookbook.tree_hierarchy_v2.TreeHierarchyV2.tree_hierarchy_v2_objects","title":"<code>tree_hierarchy_v2_objects(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Tree Hierarchy Objects</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>extract_data_profile</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>extract_severity</code> <code>boolean optional</code> <p>Se True nella risposta e' anche presente la severita, Default to False. - parameter</p> <code>extract_ip_cidr</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>customer_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_address</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_zip_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_city</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_country</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_state_province</code> <code>string optional</code> <p>additional filter - parameter</p> <code>site_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object_profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_virtual_domain</code> <code>string optional</code> <p>additional filter - parameter</p> <code>virtual_domain_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/tree_hierarchy_v2.py</code> <pre><code>def tree_hierarchy_v2_objects(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Tree Hierarchy Objects\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        extract_data_profile (boolean optional): additional filter - parameter\n        extract_severity (boolean optional): Se True nella risposta e' anche presente la severita, Default to False. - parameter\n        extract_ip_cidr (boolean optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        customer_code (string optional): additional filter - parameter\n        customer_status (string optional): additional filter - parameter\n        uuid_site (string optional): additional filter - parameter\n        site_code (string optional): additional filter - parameter\n        site_description (string optional): additional filter - parameter\n        site_address (string optional): additional filter - parameter\n        site_zip_code (string optional): additional filter - parameter\n        site_city (string optional): additional filter - parameter\n        site_country (string optional): additional filter - parameter\n        site_state_province (string optional): additional filter - parameter\n        site_status (string optional): additional filter - parameter\n        uuid_group (string optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        group_status (string optional): additional filter - parameter\n        group_type (string optional): additional filter - parameter\n        uuid_object (string optional): additional filter - parameter\n        object_name (string optional): additional filter - parameter\n        object_status (string optional): additional filter - parameter\n        object_profile (string optional): additional filter - parameter\n        uuid_virtual_domain (string optional): additional filter - parameter\n        virtual_domain_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields',\n        'extract_data_profile', 'extract_severity', 'extract_ip_cidr',\n        'uuid_customer', 'customer_code', 'customer_status',\n        'uuid_site', 'site_code', 'site_description', 'site_address',\n        'site_zip_code', 'site_city', 'site_country',\n        'site_state_province', 'site_status', 'uuid_group',\n        'group_name', 'group_status', 'group_type', 'uuid_object',\n        'object_name', 'object_status', 'object_profile',\n        'uuid_virtual_domain', 'virtual_domain_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'extract_data_profile'), params.get('extract_severity'\n        ), params.get('extract_ip_cidr'), params.get('uuid_customer'\n        ), params.get('customer_code'), params.get('customer_status'\n        ), params.get('uuid_site'), params.get('site_code'), params.get(\n        'site_description'), params.get('site_address'), params.get(\n        'site_zip_code'), params.get('site_city'), params.get(\n        'site_country'), params.get('site_state_province'), params.get(\n        'site_status'), params.get('uuid_group'), params.get('group_name'\n        ), params.get('group_status'), params.get('group_type'\n        ), params.get('uuid_object'), params.get('object_name'\n        ), params.get('object_status'), params.get('object_profile'\n        ), params.get('uuid_virtual_domain'), params.get(\n        'virtual_domain_name'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.tree_hierarchy_v2_objects.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=f'/tree_hierarchy_v2/objects',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_automata_state/","title":"Hive.cookbook.ts automata state","text":""},{"location":"hive.cookbook.ts_automata_state/#hive.cookbook.ts_automata_state.TsAutomataState","title":"<code>TsAutomataState</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_automata_state APIs</p> Source code in <code>hive/cookbook/ts_automata_state.py</code> <pre><code>class TsAutomataState(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_automata_state APIs\"\"\"\n\n    def ts_automata_state(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Automaton States\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            ingest_timestamp_start (string optional): additional filter - parameter\n            ingest_timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            group_label (string optional): additional filter - parameter\n            xal_name (string optional): additional filter - parameter\n            automata_name (string optional): additional filter - parameter\n            automata_version (string optional): additional filter - parameter\n            current_state (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'timestamp_start',\n            'timestamp_end', 'ingest_timestamp_start',\n            'ingest_timestamp_end', 'database_timestamp_start',\n            'database_timestamp_end', 'group_label', 'xal_name',\n            'automata_name', 'automata_version', 'current_state',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('timestamp_start'), params.get(\n            'timestamp_end'), params.get('ingest_timestamp_start'), params.get(\n            'ingest_timestamp_end'), params.get('database_timestamp_start'\n            ), params.get('database_timestamp_end'), params.get('group_label'\n            ), params.get('xal_name'), params.get('automata_name'), params.get(\n            'automata_version'), params.get('current_state'), params.get(\n            'null_fields'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_automata_state.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_automata_state/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_automata_state_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Read Automaton States\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_automata_state_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_automata_state/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_automata_state/#hive.cookbook.ts_automata_state.TsAutomataState.ts_automata_state","title":"<code>ts_automata_state(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Automaton States</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ingest_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ingest_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>group_label</code> <code>string optional</code> <p>additional filter - parameter</p> <code>xal_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>automata_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>automata_version</code> <code>string optional</code> <p>additional filter - parameter</p> <code>current_state</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_automata_state.py</code> <pre><code>def ts_automata_state(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Automaton States\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        ingest_timestamp_start (string optional): additional filter - parameter\n        ingest_timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        group_label (string optional): additional filter - parameter\n        xal_name (string optional): additional filter - parameter\n        automata_name (string optional): additional filter - parameter\n        automata_version (string optional): additional filter - parameter\n        current_state (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'timestamp_start',\n        'timestamp_end', 'ingest_timestamp_start',\n        'ingest_timestamp_end', 'database_timestamp_start',\n        'database_timestamp_end', 'group_label', 'xal_name',\n        'automata_name', 'automata_version', 'current_state',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('timestamp_start'), params.get(\n        'timestamp_end'), params.get('ingest_timestamp_start'), params.get(\n        'ingest_timestamp_end'), params.get('database_timestamp_start'\n        ), params.get('database_timestamp_end'), params.get('group_label'\n        ), params.get('xal_name'), params.get('automata_name'), params.get(\n        'automata_version'), params.get('current_state'), params.get(\n        'null_fields'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_automata_state.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_automata_state/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_automata_state/#hive.cookbook.ts_automata_state.TsAutomataState.ts_automata_state_bulk","title":"<code>ts_automata_state_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Automaton States</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_automata_state.py</code> <pre><code>def ts_automata_state_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Read Automaton States\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_automata_state_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_automata_state/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/","title":"Hive.cookbook.ts cost azure raw","text":""},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw","title":"<code>TsCostAzureRaw</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_cost_azure_raw APIs</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>class TsCostAzureRaw(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_cost_azure_raw APIs\"\"\"\n\n    def ts_cost_azure_raw(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Costs\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n            'date_start', 'date_end', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_metric'), params.get('date_start'), params.get('date_end'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_azure_raw.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_cost_azure_raw/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Cost\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            tags (array object optional): additional filter - payload\n            term (string optional): additional filter - payload\n            meterid (string optional): additional filter - payload\n            location (string optional): additional filter - payload\n            provider (string optional): additional filter - payload\n            quantity (number optional): additional filter - payload\n            paygprice (number optional): additional filter - payload\n            productid (string optional): additional filter - payload\n            benefitid (string optional): additional filter - payload\n            costinusd (number optional): additional filter - payload\n            frequency (string optional): additional filter - payload\n            invoiceid (string optional): additional filter - payload\n            metername (string optional): additional filter - payload\n            unitprice (number optional): additional filter - payload\n            resourceid (string optional): additional filter - payload\n            chargetype (string optional): additional filter - payload\n            costcenter (string optional): additional filter - payload\n            productname (string optional): additional filter - payload\n            benefitname (string optional): additional filter - payload\n            meterregion (string optional): additional filter - payload\n            partnername (string optional): additional filter - payload\n            publisherid (string optional): additional filter - payload\n            customername (string optional): additional filter - payload\n            pricingmodel (string optional): additional filter - payload\n            resellername (string optional): additional filter - payload\n            serviceinfo1 (string optional): additional filter - payload\n            serviceinfo2 (string optional): additional filter - payload\n            metercategory (string optional): additional filter - payload\n            paygcostinusd (number optional): additional filter - payload\n            publishername (string optional): additional filter - payload\n            publishertype (string optional): additional filter - payload\n            resellermpnid (string optional): additional filter - payload\n            reservationid (string optional): additional filter - payload\n            servicefamily (string optional): additional filter - payload\n            unitofmeasure (string optional): additional filter - payload\n            subscriptionid (string optional): additional filter - payload\n            additionalinfo (array object optional): additional filter - payload\n            effectiveprice (number optional): additional filter - payload\n            productorderid (string optional): additional filter - payload\n            billingcurrency (string optional): additional filter - payload\n            consumedservice (string optional): additional filter - payload\n            partnertenantid (string optional): additional filter - payload\n            pricingcurrency (string optional): additional filter - payload\n            reservationname (string optional): additional filter - payload\n            billingaccountid (string optional): additional filter - payload\n            billingprofileid (string optional): additional filter - payload\n            customertenantid (string optional): additional filter - payload\n            exchangeratedate (string optional): additional filter - payload\n            invoicesectionid (string optional): additional filter - payload\n            metersubcategory (string optional): additional filter - payload\n            productordername (string optional): additional filter - payload\n            resourcelocation (string optional): additional filter - payload\n            subscriptionname (string optional): additional filter - payload\n            previousinvoiceid (string optional): additional filter - payload\n            resourcegroupname (string optional): additional filter - payload\n            billingaccountname (string optional): additional filter - payload\n            billingprofilename (string optional): additional filter - payload\n            invoicesectionname (string optional): additional filter - payload\n            billingperiodenddate (string optional): additional filter - payload\n            serviceperiodenddate (string optional): additional filter - payload\n            costinbillingcurrency (number optional): additional filter - payload\n            costinpricingcurrency (number optional): additional filter - payload\n            isazurecrediteligible (boolean optional): additional filter - payload\n            billingperiodstartdate (string optional): additional filter - payload\n            serviceperiodstartdate (string optional): additional filter - payload\n            partnerearnedcreditrate (number optional): additional filter - payload\n            paygcostinbillingcurrency (number optional): additional filter - payload\n            partnerearnedcreditapplied (boolean optional): additional filter - payload\n            exchangeratepricingtobilling (number optional): additional filter - payload\n            uuid (string required): additional filter - payload\n            uuid_metric (string required): additional filter - payload\n            date (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['tags', 'term', 'meterid', 'location',\n            'provider', 'quantity', 'paygprice', 'productid', 'benefitid',\n            'costinusd', 'frequency', 'invoiceid', 'metername', 'unitprice',\n            'resourceid', 'chargetype', 'costcenter', 'productname',\n            'benefitname', 'meterregion', 'partnername', 'publisherid',\n            'customername', 'pricingmodel', 'resellername', 'serviceinfo1',\n            'serviceinfo2', 'metercategory', 'paygcostinusd',\n            'publishername', 'publishertype', 'resellermpnid',\n            'reservationid', 'servicefamily', 'unitofmeasure',\n            'subscriptionid', 'additionalinfo', 'effectiveprice',\n            'productorderid', 'billingcurrency', 'consumedservice',\n            'partnertenantid', 'pricingcurrency', 'reservationname',\n            'billingaccountid', 'billingprofileid', 'customertenantid',\n            'exchangeratedate', 'invoicesectionid', 'metersubcategory',\n            'productordername', 'resourcelocation', 'subscriptionname',\n            'previousinvoiceid', 'resourcegroupname', 'billingaccountname',\n            'billingprofilename', 'invoicesectionname',\n            'billingperiodenddate', 'serviceperiodenddate',\n            'costinbillingcurrency', 'costinpricingcurrency',\n            'isazurecrediteligible', 'billingperiodstartdate',\n            'serviceperiodstartdate', 'partnerearnedcreditrate',\n            'paygcostinbillingcurrency', 'partnerearnedcreditapplied',\n            'exchangeratepricingtobilling', 'uuid', 'uuid_metric', 'date']\n        payload.get('tags'), payload.get('term'), payload.get('meterid'\n            ), payload.get('location'), payload.get('provider'), payload.get(\n            'quantity'), payload.get('paygprice'), payload.get('productid'\n            ), payload.get('benefitid'), payload.get('costinusd'), payload.get(\n            'frequency'), payload.get('invoiceid'), payload.get('metername'\n            ), payload.get('unitprice'), payload.get('resourceid'\n            ), payload.get('chargetype'), payload.get('costcenter'\n            ), payload.get('productname'), payload.get('benefitname'\n            ), payload.get('meterregion'), payload.get('partnername'\n            ), payload.get('publisherid'), payload.get('customername'\n            ), payload.get('pricingmodel'), payload.get('resellername'\n            ), payload.get('serviceinfo1'), payload.get('serviceinfo2'\n            ), payload.get('metercategory'), payload.get('paygcostinusd'\n            ), payload.get('publishername'), payload.get('publishertype'\n            ), payload.get('resellermpnid'), payload.get('reservationid'\n            ), payload.get('servicefamily'), payload.get('unitofmeasure'\n            ), payload.get('subscriptionid'), payload.get('additionalinfo'\n            ), payload.get('effectiveprice'), payload.get('productorderid'\n            ), payload.get('billingcurrency'), payload.get('consumedservice'\n            ), payload.get('partnertenantid'), payload.get('pricingcurrency'\n            ), payload.get('reservationname'), payload.get('billingaccountid'\n            ), payload.get('billingprofileid'), payload.get('customertenantid'\n            ), payload.get('exchangeratedate'), payload.get('invoicesectionid'\n            ), payload.get('metersubcategory'), payload.get('productordername'\n            ), payload.get('resourcelocation'), payload.get('subscriptionname'\n            ), payload.get('previousinvoiceid'), payload.get(\n            'resourcegroupname'), payload.get('billingaccountname'\n            ), payload.get('billingprofilename'), payload.get(\n            'invoicesectionname'), payload.get('billingperiodenddate'\n            ), payload.get('serviceperiodenddate'), payload.get(\n            'costinbillingcurrency'), payload.get('costinpricingcurrency'\n            ), payload.get('isazurecrediteligible'), payload.get(\n            'billingperiodstartdate'), payload.get('serviceperiodstartdate'\n            ), payload.get('partnerearnedcreditrate'), payload.get(\n            'paygcostinbillingcurrency'), payload.get(\n            'partnerearnedcreditapplied'), payload.get(\n            'exchangeratepricingtobilling'), payload.get('uuid'), payload.get(\n            'uuid_metric'), payload.get('date')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_azure_raw_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/ts_cost_azure_raw/',\n            payload=payload, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Message\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            tags (array object optional): additional filter - payload\n            term (string optional): additional filter - payload\n            meterid (string optional): additional filter - payload\n            location (string optional): additional filter - payload\n            provider (string optional): additional filter - payload\n            quantity (number optional): additional filter - payload\n            paygprice (number optional): additional filter - payload\n            productid (string optional): additional filter - payload\n            benefitid (string optional): additional filter - payload\n            costinusd (number optional): additional filter - payload\n            frequency (string optional): additional filter - payload\n            invoiceid (string optional): additional filter - payload\n            metername (string optional): additional filter - payload\n            unitprice (number optional): additional filter - payload\n            resourceid (string optional): additional filter - payload\n            chargetype (string optional): additional filter - payload\n            costcenter (string optional): additional filter - payload\n            productname (string optional): additional filter - payload\n            benefitname (string optional): additional filter - payload\n            meterregion (string optional): additional filter - payload\n            partnername (string optional): additional filter - payload\n            publisherid (string optional): additional filter - payload\n            customername (string optional): additional filter - payload\n            pricingmodel (string optional): additional filter - payload\n            resellername (string optional): additional filter - payload\n            serviceinfo1 (string optional): additional filter - payload\n            serviceinfo2 (string optional): additional filter - payload\n            metercategory (string optional): additional filter - payload\n            paygcostinusd (number optional): additional filter - payload\n            publishername (string optional): additional filter - payload\n            publishertype (string optional): additional filter - payload\n            resellermpnid (string optional): additional filter - payload\n            reservationid (string optional): additional filter - payload\n            servicefamily (string optional): additional filter - payload\n            unitofmeasure (string optional): additional filter - payload\n            subscriptionid (string optional): additional filter - payload\n            additionalinfo (array object optional): additional filter - payload\n            effectiveprice (number optional): additional filter - payload\n            productorderid (string optional): additional filter - payload\n            billingcurrency (string optional): additional filter - payload\n            consumedservice (string optional): additional filter - payload\n            partnertenantid (string optional): additional filter - payload\n            pricingcurrency (string optional): additional filter - payload\n            reservationname (string optional): additional filter - payload\n            billingaccountid (string optional): additional filter - payload\n            billingprofileid (string optional): additional filter - payload\n            customertenantid (string optional): additional filter - payload\n            exchangeratedate (string optional): additional filter - payload\n            invoicesectionid (string optional): additional filter - payload\n            metersubcategory (string optional): additional filter - payload\n            productordername (string optional): additional filter - payload\n            resourcelocation (string optional): additional filter - payload\n            subscriptionname (string optional): additional filter - payload\n            previousinvoiceid (string optional): additional filter - payload\n            resourcegroupname (string optional): additional filter - payload\n            billingaccountname (string optional): additional filter - payload\n            billingprofilename (string optional): additional filter - payload\n            invoicesectionname (string optional): additional filter - payload\n            billingperiodenddate (string optional): additional filter - payload\n            serviceperiodenddate (string optional): additional filter - payload\n            costinbillingcurrency (number optional): additional filter - payload\n            costinpricingcurrency (number optional): additional filter - payload\n            isazurecrediteligible (boolean optional): additional filter - payload\n            billingperiodstartdate (string optional): additional filter - payload\n            serviceperiodstartdate (string optional): additional filter - payload\n            partnerearnedcreditrate (number optional): additional filter - payload\n            paygcostinbillingcurrency (number optional): additional filter - payload\n            partnerearnedcreditapplied (boolean optional): additional filter - payload\n            exchangeratepricingtobilling (number optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['tags', 'term', 'meterid', 'location',\n            'provider', 'quantity', 'paygprice', 'productid', 'benefitid',\n            'costinusd', 'frequency', 'invoiceid', 'metername', 'unitprice',\n            'resourceid', 'chargetype', 'costcenter', 'productname',\n            'benefitname', 'meterregion', 'partnername', 'publisherid',\n            'customername', 'pricingmodel', 'resellername', 'serviceinfo1',\n            'serviceinfo2', 'metercategory', 'paygcostinusd',\n            'publishername', 'publishertype', 'resellermpnid',\n            'reservationid', 'servicefamily', 'unitofmeasure',\n            'subscriptionid', 'additionalinfo', 'effectiveprice',\n            'productorderid', 'billingcurrency', 'consumedservice',\n            'partnertenantid', 'pricingcurrency', 'reservationname',\n            'billingaccountid', 'billingprofileid', 'customertenantid',\n            'exchangeratedate', 'invoicesectionid', 'metersubcategory',\n            'productordername', 'resourcelocation', 'subscriptionname',\n            'previousinvoiceid', 'resourcegroupname', 'billingaccountname',\n            'billingprofilename', 'invoicesectionname',\n            'billingperiodenddate', 'serviceperiodenddate',\n            'costinbillingcurrency', 'costinpricingcurrency',\n            'isazurecrediteligible', 'billingperiodstartdate',\n            'serviceperiodstartdate', 'partnerearnedcreditrate',\n            'paygcostinbillingcurrency', 'partnerearnedcreditapplied',\n            'exchangeratepricingtobilling']\n        payload.get('tags'), payload.get('term'), payload.get('meterid'\n            ), payload.get('location'), payload.get('provider'), payload.get(\n            'quantity'), payload.get('paygprice'), payload.get('productid'\n            ), payload.get('benefitid'), payload.get('costinusd'), payload.get(\n            'frequency'), payload.get('invoiceid'), payload.get('metername'\n            ), payload.get('unitprice'), payload.get('resourceid'\n            ), payload.get('chargetype'), payload.get('costcenter'\n            ), payload.get('productname'), payload.get('benefitname'\n            ), payload.get('meterregion'), payload.get('partnername'\n            ), payload.get('publisherid'), payload.get('customername'\n            ), payload.get('pricingmodel'), payload.get('resellername'\n            ), payload.get('serviceinfo1'), payload.get('serviceinfo2'\n            ), payload.get('metercategory'), payload.get('paygcostinusd'\n            ), payload.get('publishername'), payload.get('publishertype'\n            ), payload.get('resellermpnid'), payload.get('reservationid'\n            ), payload.get('servicefamily'), payload.get('unitofmeasure'\n            ), payload.get('subscriptionid'), payload.get('additionalinfo'\n            ), payload.get('effectiveprice'), payload.get('productorderid'\n            ), payload.get('billingcurrency'), payload.get('consumedservice'\n            ), payload.get('partnertenantid'), payload.get('pricingcurrency'\n            ), payload.get('reservationname'), payload.get('billingaccountid'\n            ), payload.get('billingprofileid'), payload.get('customertenantid'\n            ), payload.get('exchangeratedate'), payload.get('invoicesectionid'\n            ), payload.get('metersubcategory'), payload.get('productordername'\n            ), payload.get('resourcelocation'), payload.get('subscriptionname'\n            ), payload.get('previousinvoiceid'), payload.get(\n            'resourcegroupname'), payload.get('billingaccountname'\n            ), payload.get('billingprofilename'), payload.get(\n            'invoicesectionname'), payload.get('billingperiodenddate'\n            ), payload.get('serviceperiodenddate'), payload.get(\n            'costinbillingcurrency'), payload.get('costinpricingcurrency'\n            ), payload.get('isazurecrediteligible'), payload.get(\n            'billingperiodstartdate'), payload.get('serviceperiodstartdate'\n            ), payload.get('partnerearnedcreditrate'), payload.get(\n            'paygcostinbillingcurrency'), payload.get(\n            'partnerearnedcreditapplied'), payload.get(\n            'exchangeratepricingtobilling')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_azure_raw_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/ts_cost_azure_raw/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Cost\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/ts_cost_azure_raw/{uuid}',\n            **kwargs)\n        return response\n\n    def ts_cost_azure_raw_metric_delete(self, uuid_metric: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Delete For Uuid Metric\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_azure_raw_metric_delete.\n                __name__, params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_cost_azure_raw/metric/{uuid_metric}/', params=params, **\n            kwargs)\n        return response\n\n    def ts_cost_azure_raw_probe_delete(self, uuid_probe: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Delete For Uuid Probe And Date Range\n\n        Args:\n            uuid_probe (str, required): uuid_probe\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            tenant_id (string optional): additional filter - parameter\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['tenant_id', 'date_start', 'date_end']\n        params.get('tenant_id'), params.get('date_start'), params.get(\n            'date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_azure_raw_probe_delete.\n                __name__, params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_cost_azure_raw/probe/{uuid_probe}/', params=params, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Create Ts Service Value\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"tags\": \"array object\", optional\n            \"term\": \"string\", optional\n            \"meterid\": \"string\", optional\n            \"location\": \"string\", optional\n            \"provider\": \"string\", optional\n            \"quantity\": \"number\", optional\n            \"paygprice\": \"number\", optional\n            \"productid\": \"string\", optional\n            \"benefitid\": \"string\", optional\n            \"costinusd\": \"number\", optional\n            \"frequency\": \"string\", optional\n            \"invoiceid\": \"string\", optional\n            \"metername\": \"string\", optional\n            \"unitprice\": \"number\", optional\n            \"resourceid\": \"string\", optional\n            \"chargetype\": \"string\", optional\n            \"costcenter\": \"string\", optional\n            \"productname\": \"string\", optional\n            \"benefitname\": \"string\", optional\n            \"meterregion\": \"string\", optional\n            \"partnername\": \"string\", optional\n            \"publisherid\": \"string\", optional\n            \"customername\": \"string\", optional\n            \"pricingmodel\": \"string\", optional\n            \"resellername\": \"string\", optional\n            \"serviceinfo1\": \"string\", optional\n            \"serviceinfo2\": \"string\", optional\n            \"metercategory\": \"string\", optional\n            \"paygcostinusd\": \"number\", optional\n            \"publishername\": \"string\", optional\n            \"publishertype\": \"string\", optional\n            \"resellermpnid\": \"string\", optional\n            \"reservationid\": \"string\", optional\n            \"servicefamily\": \"string\", optional\n            \"unitofmeasure\": \"string\", optional\n            \"subscriptionid\": \"string\", optional\n            \"additionalinfo\": \"array object\", optional\n            \"effectiveprice\": \"number\", optional\n            \"productorderid\": \"string\", optional\n            \"billingcurrency\": \"string\", optional\n            \"consumedservice\": \"string\", optional\n            \"partnertenantid\": \"string\", optional\n            \"pricingcurrency\": \"string\", optional\n            \"reservationname\": \"string\", optional\n            \"billingaccountid\": \"string\", optional\n            \"billingprofileid\": \"string\", optional\n            \"customertenantid\": \"string\", optional\n            \"exchangeratedate\": \"string\", optional\n            \"invoicesectionid\": \"string\", optional\n            \"metersubcategory\": \"string\", optional\n            \"productordername\": \"string\", optional\n            \"resourcelocation\": \"string\", optional\n            \"subscriptionname\": \"string\", optional\n            \"previousinvoiceid\": \"string\", optional\n            \"resourcegroupname\": \"string\", optional\n            \"billingaccountname\": \"string\", optional\n            \"billingprofilename\": \"string\", optional\n            \"invoicesectionname\": \"string\", optional\n            \"billingperiodenddate\": \"string\", optional\n            \"serviceperiodenddate\": \"string\", optional\n            \"costinbillingcurrency\": \"number\", optional\n            \"costinpricingcurrency\": \"number\", optional\n            \"isazurecrediteligible\": \"boolean\", optional\n            \"billingperiodstartdate\": \"string\", optional\n            \"serviceperiodstartdate\": \"string\", optional\n            \"partnerearnedcreditrate\": \"number\", optional\n            \"paygcostinbillingcurrency\": \"number\", optional\n            \"partnerearnedcreditapplied\": \"boolean\", optional\n            \"exchangeratepricingtobilling\": \"number\", optional\n            \"uuid\": \"string\", required\n            \"uuid_metric\": \"string\", required\n            \"date\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/ts_cost_azure_raw/bulk/create/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Anomalies\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/ts_cost_azure_raw/bulk/delete/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_compute_probe_create(self, uuid_probe: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Transform Cost\n\n        Args:\n            uuid_probe (str, required): uuid_probe\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            tenant_id (string optional): additional filter - parameter\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['tenant_id', 'date_start', 'date_end']\n        params.get('tenant_id'), params.get('date_start'), params.get(\n            'date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_azure_raw_compute_probe_create.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_cost_azure_raw/compute/probe/{uuid_probe}/', params=\n            params, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_compute_tenant_create(self, uuid_tenant: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Transform Cost Tenant\n\n        Args:\n            uuid_tenant (str, required): uuid_tenant\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_azure_raw_compute_tenant_create.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_cost_azure_raw/compute/tenant/{uuid_tenant}/', params=\n            params, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_compute_import_tags_tenant_create(self,\n        uuid_tenant: str, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Import Tags Tenant\n\n        Args:\n            uuid_tenant (str, required): uuid_tenant\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_azure_raw_compute_import_tags_tenant_create.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_cost_azure_raw/compute/import_tags/tenant/{uuid_tenant}',\n            params=params, **kwargs)\n        return response\n\n    def ts_cost_azure_raw_compute_import_tags_customer_create(self,\n        uuid_customer: str, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Import Tags Customer\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end']\n        params.get('date_start'), params.get('date_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_azure_raw_compute_import_tags_customer_create.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_cost_azure_raw/compute/import_tags/customer/{uuid_customer}',\n            params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw","title":"<code>ts_cost_azure_raw(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Costs</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Costs\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n        'date_start', 'date_end', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_metric'), params.get('date_start'), params.get('date_end'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_azure_raw.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_cost_azure_raw/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_compute_import_tags_customer_create","title":"<code>ts_cost_azure_raw_compute_import_tags_customer_create(uuid_customer, kwargs=None, **params)</code>","text":"<p>Bulk Import Tags Customer</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_compute_import_tags_customer_create(self,\n    uuid_customer: str, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Import Tags Customer\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_azure_raw_compute_import_tags_customer_create.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_cost_azure_raw/compute/import_tags/customer/{uuid_customer}',\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_compute_import_tags_tenant_create","title":"<code>ts_cost_azure_raw_compute_import_tags_tenant_create(uuid_tenant, kwargs=None, **params)</code>","text":"<p>Bulk Import Tags Tenant</p> <p>Parameters:</p> Name Type Description Default <code>uuid_tenant</code> <code>(str, required)</code> <p>uuid_tenant</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_compute_import_tags_tenant_create(self,\n    uuid_tenant: str, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Import Tags Tenant\n\n    Args:\n        uuid_tenant (str, required): uuid_tenant\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_azure_raw_compute_import_tags_tenant_create.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_cost_azure_raw/compute/import_tags/tenant/{uuid_tenant}',\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_compute_probe_create","title":"<code>ts_cost_azure_raw_compute_probe_create(uuid_probe, kwargs=None, **params)</code>","text":"<p>Bulk Transform Cost</p> <p>Parameters:</p> Name Type Description Default <code>uuid_probe</code> <code>(str, required)</code> <p>uuid_probe</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tenant_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_compute_probe_create(self, uuid_probe: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Transform Cost\n\n    Args:\n        uuid_probe (str, required): uuid_probe\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        tenant_id (string optional): additional filter - parameter\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['tenant_id', 'date_start', 'date_end']\n    params.get('tenant_id'), params.get('date_start'), params.get(\n        'date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_azure_raw_compute_probe_create.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_cost_azure_raw/compute/probe/{uuid_probe}/', params=\n        params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_compute_tenant_create","title":"<code>ts_cost_azure_raw_compute_tenant_create(uuid_tenant, kwargs=None, **params)</code>","text":"<p>Bulk Transform Cost Tenant</p> <p>Parameters:</p> Name Type Description Default <code>uuid_tenant</code> <code>(str, required)</code> <p>uuid_tenant</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_compute_tenant_create(self, uuid_tenant: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Transform Cost Tenant\n\n    Args:\n        uuid_tenant (str, required): uuid_tenant\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_azure_raw_compute_tenant_create.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_cost_azure_raw/compute/tenant/{uuid_tenant}/', params=\n        params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_create","title":"<code>ts_cost_azure_raw_create(kwargs=None, **payload)</code>","text":"<p>Create Cost</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tags</code> <code>array object optional</code> <p>additional filter - payload</p> <code>term</code> <code>string optional</code> <p>additional filter - payload</p> <code>meterid</code> <code>string optional</code> <p>additional filter - payload</p> <code>location</code> <code>string optional</code> <p>additional filter - payload</p> <code>provider</code> <code>string optional</code> <p>additional filter - payload</p> <code>quantity</code> <code>number optional</code> <p>additional filter - payload</p> <code>paygprice</code> <code>number optional</code> <p>additional filter - payload</p> <code>productid</code> <code>string optional</code> <p>additional filter - payload</p> <code>benefitid</code> <code>string optional</code> <p>additional filter - payload</p> <code>costinusd</code> <code>number optional</code> <p>additional filter - payload</p> <code>frequency</code> <code>string optional</code> <p>additional filter - payload</p> <code>invoiceid</code> <code>string optional</code> <p>additional filter - payload</p> <code>metername</code> <code>string optional</code> <p>additional filter - payload</p> <code>unitprice</code> <code>number optional</code> <p>additional filter - payload</p> <code>resourceid</code> <code>string optional</code> <p>additional filter - payload</p> <code>chargetype</code> <code>string optional</code> <p>additional filter - payload</p> <code>costcenter</code> <code>string optional</code> <p>additional filter - payload</p> <code>productname</code> <code>string optional</code> <p>additional filter - payload</p> <code>benefitname</code> <code>string optional</code> <p>additional filter - payload</p> <code>meterregion</code> <code>string optional</code> <p>additional filter - payload</p> <code>partnername</code> <code>string optional</code> <p>additional filter - payload</p> <code>publisherid</code> <code>string optional</code> <p>additional filter - payload</p> <code>customername</code> <code>string optional</code> <p>additional filter - payload</p> <code>pricingmodel</code> <code>string optional</code> <p>additional filter - payload</p> <code>resellername</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceinfo1</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceinfo2</code> <code>string optional</code> <p>additional filter - payload</p> <code>metercategory</code> <code>string optional</code> <p>additional filter - payload</p> <code>paygcostinusd</code> <code>number optional</code> <p>additional filter - payload</p> <code>publishername</code> <code>string optional</code> <p>additional filter - payload</p> <code>publishertype</code> <code>string optional</code> <p>additional filter - payload</p> <code>resellermpnid</code> <code>string optional</code> <p>additional filter - payload</p> <code>reservationid</code> <code>string optional</code> <p>additional filter - payload</p> <code>servicefamily</code> <code>string optional</code> <p>additional filter - payload</p> <code>unitofmeasure</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptionid</code> <code>string optional</code> <p>additional filter - payload</p> <code>additionalinfo</code> <code>array object optional</code> <p>additional filter - payload</p> <code>effectiveprice</code> <code>number optional</code> <p>additional filter - payload</p> <code>productorderid</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingcurrency</code> <code>string optional</code> <p>additional filter - payload</p> <code>consumedservice</code> <code>string optional</code> <p>additional filter - payload</p> <code>partnertenantid</code> <code>string optional</code> <p>additional filter - payload</p> <code>pricingcurrency</code> <code>string optional</code> <p>additional filter - payload</p> <code>reservationname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingaccountid</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingprofileid</code> <code>string optional</code> <p>additional filter - payload</p> <code>customertenantid</code> <code>string optional</code> <p>additional filter - payload</p> <code>exchangeratedate</code> <code>string optional</code> <p>additional filter - payload</p> <code>invoicesectionid</code> <code>string optional</code> <p>additional filter - payload</p> <code>metersubcategory</code> <code>string optional</code> <p>additional filter - payload</p> <code>productordername</code> <code>string optional</code> <p>additional filter - payload</p> <code>resourcelocation</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptionname</code> <code>string optional</code> <p>additional filter - payload</p> <code>previousinvoiceid</code> <code>string optional</code> <p>additional filter - payload</p> <code>resourcegroupname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingaccountname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingprofilename</code> <code>string optional</code> <p>additional filter - payload</p> <code>invoicesectionname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingperiodenddate</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceperiodenddate</code> <code>string optional</code> <p>additional filter - payload</p> <code>costinbillingcurrency</code> <code>number optional</code> <p>additional filter - payload</p> <code>costinpricingcurrency</code> <code>number optional</code> <p>additional filter - payload</p> <code>isazurecrediteligible</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>billingperiodstartdate</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceperiodstartdate</code> <code>string optional</code> <p>additional filter - payload</p> <code>partnerearnedcreditrate</code> <code>number optional</code> <p>additional filter - payload</p> <code>paygcostinbillingcurrency</code> <code>number optional</code> <p>additional filter - payload</p> <code>partnerearnedcreditapplied</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>exchangeratepricingtobilling</code> <code>number optional</code> <p>additional filter - payload</p> <code>uuid</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_metric</code> <code>string required</code> <p>additional filter - payload</p> <code>date</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Cost\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        tags (array object optional): additional filter - payload\n        term (string optional): additional filter - payload\n        meterid (string optional): additional filter - payload\n        location (string optional): additional filter - payload\n        provider (string optional): additional filter - payload\n        quantity (number optional): additional filter - payload\n        paygprice (number optional): additional filter - payload\n        productid (string optional): additional filter - payload\n        benefitid (string optional): additional filter - payload\n        costinusd (number optional): additional filter - payload\n        frequency (string optional): additional filter - payload\n        invoiceid (string optional): additional filter - payload\n        metername (string optional): additional filter - payload\n        unitprice (number optional): additional filter - payload\n        resourceid (string optional): additional filter - payload\n        chargetype (string optional): additional filter - payload\n        costcenter (string optional): additional filter - payload\n        productname (string optional): additional filter - payload\n        benefitname (string optional): additional filter - payload\n        meterregion (string optional): additional filter - payload\n        partnername (string optional): additional filter - payload\n        publisherid (string optional): additional filter - payload\n        customername (string optional): additional filter - payload\n        pricingmodel (string optional): additional filter - payload\n        resellername (string optional): additional filter - payload\n        serviceinfo1 (string optional): additional filter - payload\n        serviceinfo2 (string optional): additional filter - payload\n        metercategory (string optional): additional filter - payload\n        paygcostinusd (number optional): additional filter - payload\n        publishername (string optional): additional filter - payload\n        publishertype (string optional): additional filter - payload\n        resellermpnid (string optional): additional filter - payload\n        reservationid (string optional): additional filter - payload\n        servicefamily (string optional): additional filter - payload\n        unitofmeasure (string optional): additional filter - payload\n        subscriptionid (string optional): additional filter - payload\n        additionalinfo (array object optional): additional filter - payload\n        effectiveprice (number optional): additional filter - payload\n        productorderid (string optional): additional filter - payload\n        billingcurrency (string optional): additional filter - payload\n        consumedservice (string optional): additional filter - payload\n        partnertenantid (string optional): additional filter - payload\n        pricingcurrency (string optional): additional filter - payload\n        reservationname (string optional): additional filter - payload\n        billingaccountid (string optional): additional filter - payload\n        billingprofileid (string optional): additional filter - payload\n        customertenantid (string optional): additional filter - payload\n        exchangeratedate (string optional): additional filter - payload\n        invoicesectionid (string optional): additional filter - payload\n        metersubcategory (string optional): additional filter - payload\n        productordername (string optional): additional filter - payload\n        resourcelocation (string optional): additional filter - payload\n        subscriptionname (string optional): additional filter - payload\n        previousinvoiceid (string optional): additional filter - payload\n        resourcegroupname (string optional): additional filter - payload\n        billingaccountname (string optional): additional filter - payload\n        billingprofilename (string optional): additional filter - payload\n        invoicesectionname (string optional): additional filter - payload\n        billingperiodenddate (string optional): additional filter - payload\n        serviceperiodenddate (string optional): additional filter - payload\n        costinbillingcurrency (number optional): additional filter - payload\n        costinpricingcurrency (number optional): additional filter - payload\n        isazurecrediteligible (boolean optional): additional filter - payload\n        billingperiodstartdate (string optional): additional filter - payload\n        serviceperiodstartdate (string optional): additional filter - payload\n        partnerearnedcreditrate (number optional): additional filter - payload\n        paygcostinbillingcurrency (number optional): additional filter - payload\n        partnerearnedcreditapplied (boolean optional): additional filter - payload\n        exchangeratepricingtobilling (number optional): additional filter - payload\n        uuid (string required): additional filter - payload\n        uuid_metric (string required): additional filter - payload\n        date (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['tags', 'term', 'meterid', 'location',\n        'provider', 'quantity', 'paygprice', 'productid', 'benefitid',\n        'costinusd', 'frequency', 'invoiceid', 'metername', 'unitprice',\n        'resourceid', 'chargetype', 'costcenter', 'productname',\n        'benefitname', 'meterregion', 'partnername', 'publisherid',\n        'customername', 'pricingmodel', 'resellername', 'serviceinfo1',\n        'serviceinfo2', 'metercategory', 'paygcostinusd',\n        'publishername', 'publishertype', 'resellermpnid',\n        'reservationid', 'servicefamily', 'unitofmeasure',\n        'subscriptionid', 'additionalinfo', 'effectiveprice',\n        'productorderid', 'billingcurrency', 'consumedservice',\n        'partnertenantid', 'pricingcurrency', 'reservationname',\n        'billingaccountid', 'billingprofileid', 'customertenantid',\n        'exchangeratedate', 'invoicesectionid', 'metersubcategory',\n        'productordername', 'resourcelocation', 'subscriptionname',\n        'previousinvoiceid', 'resourcegroupname', 'billingaccountname',\n        'billingprofilename', 'invoicesectionname',\n        'billingperiodenddate', 'serviceperiodenddate',\n        'costinbillingcurrency', 'costinpricingcurrency',\n        'isazurecrediteligible', 'billingperiodstartdate',\n        'serviceperiodstartdate', 'partnerearnedcreditrate',\n        'paygcostinbillingcurrency', 'partnerearnedcreditapplied',\n        'exchangeratepricingtobilling', 'uuid', 'uuid_metric', 'date']\n    payload.get('tags'), payload.get('term'), payload.get('meterid'\n        ), payload.get('location'), payload.get('provider'), payload.get(\n        'quantity'), payload.get('paygprice'), payload.get('productid'\n        ), payload.get('benefitid'), payload.get('costinusd'), payload.get(\n        'frequency'), payload.get('invoiceid'), payload.get('metername'\n        ), payload.get('unitprice'), payload.get('resourceid'\n        ), payload.get('chargetype'), payload.get('costcenter'\n        ), payload.get('productname'), payload.get('benefitname'\n        ), payload.get('meterregion'), payload.get('partnername'\n        ), payload.get('publisherid'), payload.get('customername'\n        ), payload.get('pricingmodel'), payload.get('resellername'\n        ), payload.get('serviceinfo1'), payload.get('serviceinfo2'\n        ), payload.get('metercategory'), payload.get('paygcostinusd'\n        ), payload.get('publishername'), payload.get('publishertype'\n        ), payload.get('resellermpnid'), payload.get('reservationid'\n        ), payload.get('servicefamily'), payload.get('unitofmeasure'\n        ), payload.get('subscriptionid'), payload.get('additionalinfo'\n        ), payload.get('effectiveprice'), payload.get('productorderid'\n        ), payload.get('billingcurrency'), payload.get('consumedservice'\n        ), payload.get('partnertenantid'), payload.get('pricingcurrency'\n        ), payload.get('reservationname'), payload.get('billingaccountid'\n        ), payload.get('billingprofileid'), payload.get('customertenantid'\n        ), payload.get('exchangeratedate'), payload.get('invoicesectionid'\n        ), payload.get('metersubcategory'), payload.get('productordername'\n        ), payload.get('resourcelocation'), payload.get('subscriptionname'\n        ), payload.get('previousinvoiceid'), payload.get(\n        'resourcegroupname'), payload.get('billingaccountname'\n        ), payload.get('billingprofilename'), payload.get(\n        'invoicesectionname'), payload.get('billingperiodenddate'\n        ), payload.get('serviceperiodenddate'), payload.get(\n        'costinbillingcurrency'), payload.get('costinpricingcurrency'\n        ), payload.get('isazurecrediteligible'), payload.get(\n        'billingperiodstartdate'), payload.get('serviceperiodstartdate'\n        ), payload.get('partnerearnedcreditrate'), payload.get(\n        'paygcostinbillingcurrency'), payload.get(\n        'partnerearnedcreditapplied'), payload.get(\n        'exchangeratepricingtobilling'), payload.get('uuid'), payload.get(\n        'uuid_metric'), payload.get('date')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_azure_raw_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/ts_cost_azure_raw/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_create_bulk","title":"<code>ts_cost_azure_raw_create_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Create Ts Service Value</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"tags\": \"array object\", optional     \"term\": \"string\", optional     \"meterid\": \"string\", optional     \"location\": \"string\", optional     \"provider\": \"string\", optional     \"quantity\": \"number\", optional     \"paygprice\": \"number\", optional     \"productid\": \"string\", optional     \"benefitid\": \"string\", optional     \"costinusd\": \"number\", optional     \"frequency\": \"string\", optional     \"invoiceid\": \"string\", optional     \"metername\": \"string\", optional     \"unitprice\": \"number\", optional     \"resourceid\": \"string\", optional     \"chargetype\": \"string\", optional     \"costcenter\": \"string\", optional     \"productname\": \"string\", optional     \"benefitname\": \"string\", optional     \"meterregion\": \"string\", optional     \"partnername\": \"string\", optional     \"publisherid\": \"string\", optional     \"customername\": \"string\", optional     \"pricingmodel\": \"string\", optional     \"resellername\": \"string\", optional     \"serviceinfo1\": \"string\", optional     \"serviceinfo2\": \"string\", optional     \"metercategory\": \"string\", optional     \"paygcostinusd\": \"number\", optional     \"publishername\": \"string\", optional     \"publishertype\": \"string\", optional     \"resellermpnid\": \"string\", optional     \"reservationid\": \"string\", optional     \"servicefamily\": \"string\", optional     \"unitofmeasure\": \"string\", optional     \"subscriptionid\": \"string\", optional     \"additionalinfo\": \"array object\", optional     \"effectiveprice\": \"number\", optional     \"productorderid\": \"string\", optional     \"billingcurrency\": \"string\", optional     \"consumedservice\": \"string\", optional     \"partnertenantid\": \"string\", optional     \"pricingcurrency\": \"string\", optional     \"reservationname\": \"string\", optional     \"billingaccountid\": \"string\", optional     \"billingprofileid\": \"string\", optional     \"customertenantid\": \"string\", optional     \"exchangeratedate\": \"string\", optional     \"invoicesectionid\": \"string\", optional     \"metersubcategory\": \"string\", optional     \"productordername\": \"string\", optional     \"resourcelocation\": \"string\", optional     \"subscriptionname\": \"string\", optional     \"previousinvoiceid\": \"string\", optional     \"resourcegroupname\": \"string\", optional     \"billingaccountname\": \"string\", optional     \"billingprofilename\": \"string\", optional     \"invoicesectionname\": \"string\", optional     \"billingperiodenddate\": \"string\", optional     \"serviceperiodenddate\": \"string\", optional     \"costinbillingcurrency\": \"number\", optional     \"costinpricingcurrency\": \"number\", optional     \"isazurecrediteligible\": \"boolean\", optional     \"billingperiodstartdate\": \"string\", optional     \"serviceperiodstartdate\": \"string\", optional     \"partnerearnedcreditrate\": \"number\", optional     \"paygcostinbillingcurrency\": \"number\", optional     \"partnerearnedcreditapplied\": \"boolean\", optional     \"exchangeratepricingtobilling\": \"number\", optional     \"uuid\": \"string\", required     \"uuid_metric\": \"string\", required     \"date\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Create Ts Service Value\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"tags\": \"array object\", optional\n        \"term\": \"string\", optional\n        \"meterid\": \"string\", optional\n        \"location\": \"string\", optional\n        \"provider\": \"string\", optional\n        \"quantity\": \"number\", optional\n        \"paygprice\": \"number\", optional\n        \"productid\": \"string\", optional\n        \"benefitid\": \"string\", optional\n        \"costinusd\": \"number\", optional\n        \"frequency\": \"string\", optional\n        \"invoiceid\": \"string\", optional\n        \"metername\": \"string\", optional\n        \"unitprice\": \"number\", optional\n        \"resourceid\": \"string\", optional\n        \"chargetype\": \"string\", optional\n        \"costcenter\": \"string\", optional\n        \"productname\": \"string\", optional\n        \"benefitname\": \"string\", optional\n        \"meterregion\": \"string\", optional\n        \"partnername\": \"string\", optional\n        \"publisherid\": \"string\", optional\n        \"customername\": \"string\", optional\n        \"pricingmodel\": \"string\", optional\n        \"resellername\": \"string\", optional\n        \"serviceinfo1\": \"string\", optional\n        \"serviceinfo2\": \"string\", optional\n        \"metercategory\": \"string\", optional\n        \"paygcostinusd\": \"number\", optional\n        \"publishername\": \"string\", optional\n        \"publishertype\": \"string\", optional\n        \"resellermpnid\": \"string\", optional\n        \"reservationid\": \"string\", optional\n        \"servicefamily\": \"string\", optional\n        \"unitofmeasure\": \"string\", optional\n        \"subscriptionid\": \"string\", optional\n        \"additionalinfo\": \"array object\", optional\n        \"effectiveprice\": \"number\", optional\n        \"productorderid\": \"string\", optional\n        \"billingcurrency\": \"string\", optional\n        \"consumedservice\": \"string\", optional\n        \"partnertenantid\": \"string\", optional\n        \"pricingcurrency\": \"string\", optional\n        \"reservationname\": \"string\", optional\n        \"billingaccountid\": \"string\", optional\n        \"billingprofileid\": \"string\", optional\n        \"customertenantid\": \"string\", optional\n        \"exchangeratedate\": \"string\", optional\n        \"invoicesectionid\": \"string\", optional\n        \"metersubcategory\": \"string\", optional\n        \"productordername\": \"string\", optional\n        \"resourcelocation\": \"string\", optional\n        \"subscriptionname\": \"string\", optional\n        \"previousinvoiceid\": \"string\", optional\n        \"resourcegroupname\": \"string\", optional\n        \"billingaccountname\": \"string\", optional\n        \"billingprofilename\": \"string\", optional\n        \"invoicesectionname\": \"string\", optional\n        \"billingperiodenddate\": \"string\", optional\n        \"serviceperiodenddate\": \"string\", optional\n        \"costinbillingcurrency\": \"number\", optional\n        \"costinpricingcurrency\": \"number\", optional\n        \"isazurecrediteligible\": \"boolean\", optional\n        \"billingperiodstartdate\": \"string\", optional\n        \"serviceperiodstartdate\": \"string\", optional\n        \"partnerearnedcreditrate\": \"number\", optional\n        \"paygcostinbillingcurrency\": \"number\", optional\n        \"partnerearnedcreditapplied\": \"boolean\", optional\n        \"exchangeratepricingtobilling\": \"number\", optional\n        \"uuid\": \"string\", required\n        \"uuid_metric\": \"string\", required\n        \"date\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/ts_cost_azure_raw/bulk/create/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_delete","title":"<code>ts_cost_azure_raw_delete(uuid, kwargs=None)</code>","text":"<p>Delete Cost</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Cost\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/ts_cost_azure_raw/{uuid}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_delete_bulk","title":"<code>ts_cost_azure_raw_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Anomalies</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Anomalies\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/ts_cost_azure_raw/bulk/delete/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_metric_delete","title":"<code>ts_cost_azure_raw_metric_delete(uuid_metric, kwargs=None, **params)</code>","text":"<p>Delete For Uuid Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_metric_delete(self, uuid_metric: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Delete For Uuid Metric\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end']\n    params.get('date_start'), params.get('date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_azure_raw_metric_delete.\n            __name__, params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_cost_azure_raw/metric/{uuid_metric}/', params=params, **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_probe_delete","title":"<code>ts_cost_azure_raw_probe_delete(uuid_probe, kwargs=None, **params)</code>","text":"<p>Delete For Uuid Probe And Date Range</p> <p>Parameters:</p> Name Type Description Default <code>uuid_probe</code> <code>(str, required)</code> <p>uuid_probe</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tenant_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_probe_delete(self, uuid_probe: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Delete For Uuid Probe And Date Range\n\n    Args:\n        uuid_probe (str, required): uuid_probe\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        tenant_id (string optional): additional filter - parameter\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['tenant_id', 'date_start', 'date_end']\n    params.get('tenant_id'), params.get('date_start'), params.get(\n        'date_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_azure_raw_probe_delete.\n            __name__, params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_cost_azure_raw/probe/{uuid_probe}/', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_azure_raw/#hive.cookbook.ts_cost_azure_raw.TsCostAzureRaw.ts_cost_azure_raw_put","title":"<code>ts_cost_azure_raw_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Message</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tags</code> <code>array object optional</code> <p>additional filter - payload</p> <code>term</code> <code>string optional</code> <p>additional filter - payload</p> <code>meterid</code> <code>string optional</code> <p>additional filter - payload</p> <code>location</code> <code>string optional</code> <p>additional filter - payload</p> <code>provider</code> <code>string optional</code> <p>additional filter - payload</p> <code>quantity</code> <code>number optional</code> <p>additional filter - payload</p> <code>paygprice</code> <code>number optional</code> <p>additional filter - payload</p> <code>productid</code> <code>string optional</code> <p>additional filter - payload</p> <code>benefitid</code> <code>string optional</code> <p>additional filter - payload</p> <code>costinusd</code> <code>number optional</code> <p>additional filter - payload</p> <code>frequency</code> <code>string optional</code> <p>additional filter - payload</p> <code>invoiceid</code> <code>string optional</code> <p>additional filter - payload</p> <code>metername</code> <code>string optional</code> <p>additional filter - payload</p> <code>unitprice</code> <code>number optional</code> <p>additional filter - payload</p> <code>resourceid</code> <code>string optional</code> <p>additional filter - payload</p> <code>chargetype</code> <code>string optional</code> <p>additional filter - payload</p> <code>costcenter</code> <code>string optional</code> <p>additional filter - payload</p> <code>productname</code> <code>string optional</code> <p>additional filter - payload</p> <code>benefitname</code> <code>string optional</code> <p>additional filter - payload</p> <code>meterregion</code> <code>string optional</code> <p>additional filter - payload</p> <code>partnername</code> <code>string optional</code> <p>additional filter - payload</p> <code>publisherid</code> <code>string optional</code> <p>additional filter - payload</p> <code>customername</code> <code>string optional</code> <p>additional filter - payload</p> <code>pricingmodel</code> <code>string optional</code> <p>additional filter - payload</p> <code>resellername</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceinfo1</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceinfo2</code> <code>string optional</code> <p>additional filter - payload</p> <code>metercategory</code> <code>string optional</code> <p>additional filter - payload</p> <code>paygcostinusd</code> <code>number optional</code> <p>additional filter - payload</p> <code>publishername</code> <code>string optional</code> <p>additional filter - payload</p> <code>publishertype</code> <code>string optional</code> <p>additional filter - payload</p> <code>resellermpnid</code> <code>string optional</code> <p>additional filter - payload</p> <code>reservationid</code> <code>string optional</code> <p>additional filter - payload</p> <code>servicefamily</code> <code>string optional</code> <p>additional filter - payload</p> <code>unitofmeasure</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptionid</code> <code>string optional</code> <p>additional filter - payload</p> <code>additionalinfo</code> <code>array object optional</code> <p>additional filter - payload</p> <code>effectiveprice</code> <code>number optional</code> <p>additional filter - payload</p> <code>productorderid</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingcurrency</code> <code>string optional</code> <p>additional filter - payload</p> <code>consumedservice</code> <code>string optional</code> <p>additional filter - payload</p> <code>partnertenantid</code> <code>string optional</code> <p>additional filter - payload</p> <code>pricingcurrency</code> <code>string optional</code> <p>additional filter - payload</p> <code>reservationname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingaccountid</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingprofileid</code> <code>string optional</code> <p>additional filter - payload</p> <code>customertenantid</code> <code>string optional</code> <p>additional filter - payload</p> <code>exchangeratedate</code> <code>string optional</code> <p>additional filter - payload</p> <code>invoicesectionid</code> <code>string optional</code> <p>additional filter - payload</p> <code>metersubcategory</code> <code>string optional</code> <p>additional filter - payload</p> <code>productordername</code> <code>string optional</code> <p>additional filter - payload</p> <code>resourcelocation</code> <code>string optional</code> <p>additional filter - payload</p> <code>subscriptionname</code> <code>string optional</code> <p>additional filter - payload</p> <code>previousinvoiceid</code> <code>string optional</code> <p>additional filter - payload</p> <code>resourcegroupname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingaccountname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingprofilename</code> <code>string optional</code> <p>additional filter - payload</p> <code>invoicesectionname</code> <code>string optional</code> <p>additional filter - payload</p> <code>billingperiodenddate</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceperiodenddate</code> <code>string optional</code> <p>additional filter - payload</p> <code>costinbillingcurrency</code> <code>number optional</code> <p>additional filter - payload</p> <code>costinpricingcurrency</code> <code>number optional</code> <p>additional filter - payload</p> <code>isazurecrediteligible</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>billingperiodstartdate</code> <code>string optional</code> <p>additional filter - payload</p> <code>serviceperiodstartdate</code> <code>string optional</code> <p>additional filter - payload</p> <code>partnerearnedcreditrate</code> <code>number optional</code> <p>additional filter - payload</p> <code>paygcostinbillingcurrency</code> <code>number optional</code> <p>additional filter - payload</p> <code>partnerearnedcreditapplied</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>exchangeratepricingtobilling</code> <code>number optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_azure_raw.py</code> <pre><code>def ts_cost_azure_raw_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Message\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        tags (array object optional): additional filter - payload\n        term (string optional): additional filter - payload\n        meterid (string optional): additional filter - payload\n        location (string optional): additional filter - payload\n        provider (string optional): additional filter - payload\n        quantity (number optional): additional filter - payload\n        paygprice (number optional): additional filter - payload\n        productid (string optional): additional filter - payload\n        benefitid (string optional): additional filter - payload\n        costinusd (number optional): additional filter - payload\n        frequency (string optional): additional filter - payload\n        invoiceid (string optional): additional filter - payload\n        metername (string optional): additional filter - payload\n        unitprice (number optional): additional filter - payload\n        resourceid (string optional): additional filter - payload\n        chargetype (string optional): additional filter - payload\n        costcenter (string optional): additional filter - payload\n        productname (string optional): additional filter - payload\n        benefitname (string optional): additional filter - payload\n        meterregion (string optional): additional filter - payload\n        partnername (string optional): additional filter - payload\n        publisherid (string optional): additional filter - payload\n        customername (string optional): additional filter - payload\n        pricingmodel (string optional): additional filter - payload\n        resellername (string optional): additional filter - payload\n        serviceinfo1 (string optional): additional filter - payload\n        serviceinfo2 (string optional): additional filter - payload\n        metercategory (string optional): additional filter - payload\n        paygcostinusd (number optional): additional filter - payload\n        publishername (string optional): additional filter - payload\n        publishertype (string optional): additional filter - payload\n        resellermpnid (string optional): additional filter - payload\n        reservationid (string optional): additional filter - payload\n        servicefamily (string optional): additional filter - payload\n        unitofmeasure (string optional): additional filter - payload\n        subscriptionid (string optional): additional filter - payload\n        additionalinfo (array object optional): additional filter - payload\n        effectiveprice (number optional): additional filter - payload\n        productorderid (string optional): additional filter - payload\n        billingcurrency (string optional): additional filter - payload\n        consumedservice (string optional): additional filter - payload\n        partnertenantid (string optional): additional filter - payload\n        pricingcurrency (string optional): additional filter - payload\n        reservationname (string optional): additional filter - payload\n        billingaccountid (string optional): additional filter - payload\n        billingprofileid (string optional): additional filter - payload\n        customertenantid (string optional): additional filter - payload\n        exchangeratedate (string optional): additional filter - payload\n        invoicesectionid (string optional): additional filter - payload\n        metersubcategory (string optional): additional filter - payload\n        productordername (string optional): additional filter - payload\n        resourcelocation (string optional): additional filter - payload\n        subscriptionname (string optional): additional filter - payload\n        previousinvoiceid (string optional): additional filter - payload\n        resourcegroupname (string optional): additional filter - payload\n        billingaccountname (string optional): additional filter - payload\n        billingprofilename (string optional): additional filter - payload\n        invoicesectionname (string optional): additional filter - payload\n        billingperiodenddate (string optional): additional filter - payload\n        serviceperiodenddate (string optional): additional filter - payload\n        costinbillingcurrency (number optional): additional filter - payload\n        costinpricingcurrency (number optional): additional filter - payload\n        isazurecrediteligible (boolean optional): additional filter - payload\n        billingperiodstartdate (string optional): additional filter - payload\n        serviceperiodstartdate (string optional): additional filter - payload\n        partnerearnedcreditrate (number optional): additional filter - payload\n        paygcostinbillingcurrency (number optional): additional filter - payload\n        partnerearnedcreditapplied (boolean optional): additional filter - payload\n        exchangeratepricingtobilling (number optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['tags', 'term', 'meterid', 'location',\n        'provider', 'quantity', 'paygprice', 'productid', 'benefitid',\n        'costinusd', 'frequency', 'invoiceid', 'metername', 'unitprice',\n        'resourceid', 'chargetype', 'costcenter', 'productname',\n        'benefitname', 'meterregion', 'partnername', 'publisherid',\n        'customername', 'pricingmodel', 'resellername', 'serviceinfo1',\n        'serviceinfo2', 'metercategory', 'paygcostinusd',\n        'publishername', 'publishertype', 'resellermpnid',\n        'reservationid', 'servicefamily', 'unitofmeasure',\n        'subscriptionid', 'additionalinfo', 'effectiveprice',\n        'productorderid', 'billingcurrency', 'consumedservice',\n        'partnertenantid', 'pricingcurrency', 'reservationname',\n        'billingaccountid', 'billingprofileid', 'customertenantid',\n        'exchangeratedate', 'invoicesectionid', 'metersubcategory',\n        'productordername', 'resourcelocation', 'subscriptionname',\n        'previousinvoiceid', 'resourcegroupname', 'billingaccountname',\n        'billingprofilename', 'invoicesectionname',\n        'billingperiodenddate', 'serviceperiodenddate',\n        'costinbillingcurrency', 'costinpricingcurrency',\n        'isazurecrediteligible', 'billingperiodstartdate',\n        'serviceperiodstartdate', 'partnerearnedcreditrate',\n        'paygcostinbillingcurrency', 'partnerearnedcreditapplied',\n        'exchangeratepricingtobilling']\n    payload.get('tags'), payload.get('term'), payload.get('meterid'\n        ), payload.get('location'), payload.get('provider'), payload.get(\n        'quantity'), payload.get('paygprice'), payload.get('productid'\n        ), payload.get('benefitid'), payload.get('costinusd'), payload.get(\n        'frequency'), payload.get('invoiceid'), payload.get('metername'\n        ), payload.get('unitprice'), payload.get('resourceid'\n        ), payload.get('chargetype'), payload.get('costcenter'\n        ), payload.get('productname'), payload.get('benefitname'\n        ), payload.get('meterregion'), payload.get('partnername'\n        ), payload.get('publisherid'), payload.get('customername'\n        ), payload.get('pricingmodel'), payload.get('resellername'\n        ), payload.get('serviceinfo1'), payload.get('serviceinfo2'\n        ), payload.get('metercategory'), payload.get('paygcostinusd'\n        ), payload.get('publishername'), payload.get('publishertype'\n        ), payload.get('resellermpnid'), payload.get('reservationid'\n        ), payload.get('servicefamily'), payload.get('unitofmeasure'\n        ), payload.get('subscriptionid'), payload.get('additionalinfo'\n        ), payload.get('effectiveprice'), payload.get('productorderid'\n        ), payload.get('billingcurrency'), payload.get('consumedservice'\n        ), payload.get('partnertenantid'), payload.get('pricingcurrency'\n        ), payload.get('reservationname'), payload.get('billingaccountid'\n        ), payload.get('billingprofileid'), payload.get('customertenantid'\n        ), payload.get('exchangeratedate'), payload.get('invoicesectionid'\n        ), payload.get('metersubcategory'), payload.get('productordername'\n        ), payload.get('resourcelocation'), payload.get('subscriptionname'\n        ), payload.get('previousinvoiceid'), payload.get(\n        'resourcegroupname'), payload.get('billingaccountname'\n        ), payload.get('billingprofilename'), payload.get(\n        'invoicesectionname'), payload.get('billingperiodenddate'\n        ), payload.get('serviceperiodenddate'), payload.get(\n        'costinbillingcurrency'), payload.get('costinpricingcurrency'\n        ), payload.get('isazurecrediteligible'), payload.get(\n        'billingperiodstartdate'), payload.get('serviceperiodstartdate'\n        ), payload.get('partnerearnedcreditrate'), payload.get(\n        'paygcostinbillingcurrency'), payload.get(\n        'partnerearnedcreditapplied'), payload.get(\n        'exchangeratepricingtobilling')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_azure_raw_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/ts_cost_azure_raw/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/","title":"Hive.cookbook.ts cost management","text":""},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement","title":"<code>TsCostManagement</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_cost_management APIs</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>class TsCostManagement(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_cost_management APIs\"\"\"\n\n    def ts_cost_management(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Costs\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            cloud_provider (string optional): additional filter - parameter\n            resource_location (string optional): additional filter - parameter\n            subscription_type (string optional): additional filter - parameter\n            subscription_id (string optional): additional filter - parameter\n            subscription_name (string optional): additional filter - parameter\n            family (string optional): additional filter - parameter\n            category (string optional): additional filter - parameter\n            subcategory (string optional): additional filter - parameter\n            object (string optional): additional filter - parameter\n            metric (string optional): additional filter - parameter\n            unit (string optional): additional filter - parameter\n            resource_group (string optional): additional filter - parameter\n            reservation_name (string optional): additional filter - parameter\n            publisher_name (string optional): additional filter - parameter\n            local_currency (string optional): additional filter - parameter\n            provider_currency (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            resource_id (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n            'date_start', 'date_end', 'cloud_provider', 'resource_location',\n            'subscription_type', 'subscription_id', 'subscription_name',\n            'family', 'category', 'subcategory', 'object', 'metric', 'unit',\n            'resource_group', 'reservation_name', 'publisher_name',\n            'local_currency', 'provider_currency', 'uuid_customer',\n            'resource_id', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_metric'), params.get('date_start'), params.get('date_end'\n            ), params.get('cloud_provider'), params.get('resource_location'\n            ), params.get('subscription_type'), params.get('subscription_id'\n            ), params.get('subscription_name'), params.get('family'\n            ), params.get('category'), params.get('subcategory'), params.get(\n            'object'), params.get('metric'), params.get('unit'), params.get(\n            'resource_group'), params.get('reservation_name'), params.get(\n            'publisher_name'), params.get('local_currency'), params.get(\n            'provider_currency'), params.get('uuid_customer'), params.get(\n            'resource_id'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_cost_management/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_create(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Create Cost Multi\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric\": \"string\", required\n            \"date\": \"string integer\", required\n            \"cloud_provider\": \"string\", required\n            \"resource_location\": \"string\", required\n            \"subscription_type\": \"string\", optional\n            \"subscription_id\": \"string\", required\n            \"subscription_name\": \"string\", optional\n            \"family\": \"string\", required\n            \"category\": \"string\", required\n            \"subcategory\": \"string\", required\n            \"object\": \"string\", required\n            \"metric\": \"string\", required\n            \"unit\": \"string\", required\n            \"qnt\": \"number\", optional\n            \"local_currency\": \"string\", required\n            \"unit_cost\": \"number\", required\n            \"total_cost\": \"number\", required\n            \"unit_revenue\": \"number\", required\n            \"total_revenue\": \"number\", required\n            \"provider_currency\": \"string\", required\n            \"unit_cost_pc\": \"number\", required\n            \"total_cost_pc\": \"number\", required\n            \"unit_revenue_pc\": \"number\", required\n            \"total_revenue_pc\": \"number\", required\n            \"cumulative_qnt\": \"number\", required\n            \"cumulative_unit_cost\": \"number\", required\n            \"cumulative_total_cost\": \"number\", required\n            \"cumulative_unit_revenue\": \"number\", required\n            \"cumulative_total_revenue\": \"number\", required\n            \"resource_group\": \"string\", required\n            \"reservation_name\": \"string\", required\n            \"publisher_name\": \"string\", required\n            \"resource_id\": \"string integer\", required\n            \"tenant_id\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/ts_cost_management/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def ts_cost_management_grouped(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Date\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            cloud_provider (string optional): additional filter - parameter\n            resource_group (string optional): additional filter - parameter\n            resource_location (string optional): additional filter - parameter\n            category (string optional): additional filter - parameter\n            subscription (string optional): additional filter - parameter\n            subscription_type (string optional): additional filter - parameter\n            interval (string optional): additional filter - parameter\n            detailed (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'date_start',\n            'date_end', 'cloud_provider', 'resource_group',\n            'resource_location', 'category', 'subscription',\n            'subscription_type', 'interval', 'detailed', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'date_start'), params.get('date_end'), params.get('cloud_provider'\n            ), params.get('resource_group'), params.get('resource_location'\n            ), params.get('category'), params.get('subscription'), params.get(\n            'subscription_type'), params.get('interval'), params.get('detailed'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_grouped.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/grouped/{uuid_customer}', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def ts_cost_management_uuid_metric(self, uuid_metric: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['date']\n        params.get('date')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/{uuid_metric}', warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def ts_cost_management_ccm_by_date(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Cloud Provider Subscription Type Resource Group\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            interval (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'interval',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('interval'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_ccm_by_date.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/ccm_by_date/{uuid_customer}', single_page\n            =single_page, page_size=page_size, warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def ts_cost_management_ccm_by_subscription_type(self,\n        uuid_customer: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Cloud Provider Subscription Type\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_ccm_by_subscription_type.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/ccm_by_subscription_type/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_ccm_by_category(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Category\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_ccm_by_category.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/ccm_by_category/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_ccm_by_resource_location(self,\n        uuid_customer: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Resource Location\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_ccm_by_resource_location.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/ccm_by_resource_location/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_ccm_by_resource_group(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Resource Group\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_ccm_by_resource_group.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/ccm_by_resource_group/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_ccm_by_subscription(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Subscription\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_ccm_by_subscription.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management/ccm_by_subscription/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_probe_delete(self, uuid_probe: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Delete By Uuid Probe And Date Range\n\n        Args:\n            uuid_probe (str, required): uuid_probe\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            tenant_id (string optional): additional filter - parameter\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            profile (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['tenant_id', 'date_start', 'date_end',\n            'profile']\n        params.get('tenant_id'), params.get('date_start'), params.get(\n            'date_end'), params.get('profile')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_probe_delete.\n                __name__, params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_cost_management/probe/{uuid_probe}/', params=params, **kwargs\n            )\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management","title":"<code>ts_cost_management(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Costs</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>cloud_provider</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_location</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>family</code> <code>string optional</code> <p>additional filter - parameter</p> <code>category</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subcategory</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>reservation_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>publisher_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>local_currency</code> <code>string optional</code> <p>additional filter - parameter</p> <code>provider_currency</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Costs\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        cloud_provider (string optional): additional filter - parameter\n        resource_location (string optional): additional filter - parameter\n        subscription_type (string optional): additional filter - parameter\n        subscription_id (string optional): additional filter - parameter\n        subscription_name (string optional): additional filter - parameter\n        family (string optional): additional filter - parameter\n        category (string optional): additional filter - parameter\n        subcategory (string optional): additional filter - parameter\n        object (string optional): additional filter - parameter\n        metric (string optional): additional filter - parameter\n        unit (string optional): additional filter - parameter\n        resource_group (string optional): additional filter - parameter\n        reservation_name (string optional): additional filter - parameter\n        publisher_name (string optional): additional filter - parameter\n        local_currency (string optional): additional filter - parameter\n        provider_currency (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        resource_id (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n        'date_start', 'date_end', 'cloud_provider', 'resource_location',\n        'subscription_type', 'subscription_id', 'subscription_name',\n        'family', 'category', 'subcategory', 'object', 'metric', 'unit',\n        'resource_group', 'reservation_name', 'publisher_name',\n        'local_currency', 'provider_currency', 'uuid_customer',\n        'resource_id', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_metric'), params.get('date_start'), params.get('date_end'\n        ), params.get('cloud_provider'), params.get('resource_location'\n        ), params.get('subscription_type'), params.get('subscription_id'\n        ), params.get('subscription_name'), params.get('family'\n        ), params.get('category'), params.get('subcategory'), params.get(\n        'object'), params.get('metric'), params.get('unit'), params.get(\n        'resource_group'), params.get('reservation_name'), params.get(\n        'publisher_name'), params.get('local_currency'), params.get(\n        'provider_currency'), params.get('uuid_customer'), params.get(\n        'resource_id'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_cost_management/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_ccm_by_category","title":"<code>ts_cost_management_ccm_by_category(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Category</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_ccm_by_category(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Category\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_ccm_by_category.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/ccm_by_category/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_ccm_by_date","title":"<code>ts_cost_management_ccm_by_date(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Cloud Provider Subscription Type Resource Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>interval</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_ccm_by_date(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Cloud Provider Subscription Type Resource Group\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        interval (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'interval',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('interval'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_ccm_by_date.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/ccm_by_date/{uuid_customer}', single_page\n        =single_page, page_size=page_size, warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_ccm_by_resource_group","title":"<code>ts_cost_management_ccm_by_resource_group(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Resource Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_ccm_by_resource_group(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Resource Group\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_ccm_by_resource_group.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/ccm_by_resource_group/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_ccm_by_resource_location","title":"<code>ts_cost_management_ccm_by_resource_location(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Resource Location</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_ccm_by_resource_location(self,\n    uuid_customer: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Resource Location\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_ccm_by_resource_location.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/ccm_by_resource_location/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_ccm_by_subscription","title":"<code>ts_cost_management_ccm_by_subscription(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Subscription</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_ccm_by_subscription(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Subscription\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_ccm_by_subscription.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/ccm_by_subscription/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_ccm_by_subscription_type","title":"<code>ts_cost_management_ccm_by_subscription_type(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Cloud Provider Subscription Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_ccm_by_subscription_type(self,\n    uuid_customer: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Cloud Provider Subscription Type\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_ccm_by_subscription_type.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/ccm_by_subscription_type/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_create","title":"<code>ts_cost_management_create(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Create Cost Multi</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric\": \"string\", required     \"date\": \"string integer\", required     \"cloud_provider\": \"string\", required     \"resource_location\": \"string\", required     \"subscription_type\": \"string\", optional     \"subscription_id\": \"string\", required     \"subscription_name\": \"string\", optional     \"family\": \"string\", required     \"category\": \"string\", required     \"subcategory\": \"string\", required     \"object\": \"string\", required     \"metric\": \"string\", required     \"unit\": \"string\", required     \"qnt\": \"number\", optional     \"local_currency\": \"string\", required     \"unit_cost\": \"number\", required     \"total_cost\": \"number\", required     \"unit_revenue\": \"number\", required     \"total_revenue\": \"number\", required     \"provider_currency\": \"string\", required     \"unit_cost_pc\": \"number\", required     \"total_cost_pc\": \"number\", required     \"unit_revenue_pc\": \"number\", required     \"total_revenue_pc\": \"number\", required     \"cumulative_qnt\": \"number\", required     \"cumulative_unit_cost\": \"number\", required     \"cumulative_total_cost\": \"number\", required     \"cumulative_unit_revenue\": \"number\", required     \"cumulative_total_revenue\": \"number\", required     \"resource_group\": \"string\", required     \"reservation_name\": \"string\", required     \"publisher_name\": \"string\", required     \"resource_id\": \"string integer\", required     \"tenant_id\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_create(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Create Cost Multi\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric\": \"string\", required\n        \"date\": \"string integer\", required\n        \"cloud_provider\": \"string\", required\n        \"resource_location\": \"string\", required\n        \"subscription_type\": \"string\", optional\n        \"subscription_id\": \"string\", required\n        \"subscription_name\": \"string\", optional\n        \"family\": \"string\", required\n        \"category\": \"string\", required\n        \"subcategory\": \"string\", required\n        \"object\": \"string\", required\n        \"metric\": \"string\", required\n        \"unit\": \"string\", required\n        \"qnt\": \"number\", optional\n        \"local_currency\": \"string\", required\n        \"unit_cost\": \"number\", required\n        \"total_cost\": \"number\", required\n        \"unit_revenue\": \"number\", required\n        \"total_revenue\": \"number\", required\n        \"provider_currency\": \"string\", required\n        \"unit_cost_pc\": \"number\", required\n        \"total_cost_pc\": \"number\", required\n        \"unit_revenue_pc\": \"number\", required\n        \"total_revenue_pc\": \"number\", required\n        \"cumulative_qnt\": \"number\", required\n        \"cumulative_unit_cost\": \"number\", required\n        \"cumulative_total_cost\": \"number\", required\n        \"cumulative_unit_revenue\": \"number\", required\n        \"cumulative_total_revenue\": \"number\", required\n        \"resource_group\": \"string\", required\n        \"reservation_name\": \"string\", required\n        \"publisher_name\": \"string\", required\n        \"resource_id\": \"string integer\", required\n        \"tenant_id\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/ts_cost_management/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_grouped","title":"<code>ts_cost_management_grouped(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Date</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>cloud_provider</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_location</code> <code>string optional</code> <p>additional filter - parameter</p> <code>category</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>interval</code> <code>string optional</code> <p>additional filter - parameter</p> <code>detailed</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_grouped(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Date\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        cloud_provider (string optional): additional filter - parameter\n        resource_group (string optional): additional filter - parameter\n        resource_location (string optional): additional filter - parameter\n        category (string optional): additional filter - parameter\n        subscription (string optional): additional filter - parameter\n        subscription_type (string optional): additional filter - parameter\n        interval (string optional): additional filter - parameter\n        detailed (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'date_start',\n        'date_end', 'cloud_provider', 'resource_group',\n        'resource_location', 'category', 'subscription',\n        'subscription_type', 'interval', 'detailed', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'date_start'), params.get('date_end'), params.get('cloud_provider'\n        ), params.get('resource_group'), params.get('resource_location'\n        ), params.get('category'), params.get('subscription'), params.get(\n        'subscription_type'), params.get('interval'), params.get('detailed'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_grouped.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/grouped/{uuid_customer}', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_probe_delete","title":"<code>ts_cost_management_probe_delete(uuid_probe, kwargs=None, **params)</code>","text":"<p>Delete By Uuid Probe And Date Range</p> <p>Parameters:</p> Name Type Description Default <code>uuid_probe</code> <code>(str, required)</code> <p>uuid_probe</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tenant_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_probe_delete(self, uuid_probe: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Delete By Uuid Probe And Date Range\n\n    Args:\n        uuid_probe (str, required): uuid_probe\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        tenant_id (string optional): additional filter - parameter\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        profile (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['tenant_id', 'date_start', 'date_end',\n        'profile']\n    params.get('tenant_id'), params.get('date_start'), params.get(\n        'date_end'), params.get('profile')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_probe_delete.\n            __name__, params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_cost_management/probe/{uuid_probe}/', params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management/#hive.cookbook.ts_cost_management.TsCostManagement.ts_cost_management_uuid_metric","title":"<code>ts_cost_management_uuid_metric(uuid_metric, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Cost</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management.py</code> <pre><code>def ts_cost_management_uuid_metric(self, uuid_metric: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['date']\n    params.get('date')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management/{uuid_metric}', warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/","title":"Hive.cookbook.ts cost management v2","text":""},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2","title":"<code>TsCostManagementV2</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_cost_management_v2 APIs</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>class TsCostManagementV2(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_cost_management_v2 APIs\"\"\"\n\n    def ts_cost_management_v2(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Costs\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            cloud_provider (string optional): additional filter - parameter\n            resource_location (string optional): additional filter - parameter\n            subscription_type (string optional): additional filter - parameter\n            subscription_id (string optional): additional filter - parameter\n            subscription_name (string optional): additional filter - parameter\n            family (string optional): additional filter - parameter\n            category (string optional): additional filter - parameter\n            subcategory (string optional): additional filter - parameter\n            object (string optional): additional filter - parameter\n            metric (string optional): additional filter - parameter\n            unit (string optional): additional filter - parameter\n            resource_group (string optional): additional filter - parameter\n            reservation_name (string optional): additional filter - parameter\n            publisher_name (string optional): additional filter - parameter\n            local_currency (string optional): additional filter - parameter\n            provider_currency (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            resource_id (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n            'date_start', 'date_end', 'cloud_provider', 'resource_location',\n            'subscription_type', 'subscription_id', 'subscription_name',\n            'family', 'category', 'subcategory', 'object', 'metric', 'unit',\n            'resource_group', 'reservation_name', 'publisher_name',\n            'local_currency', 'provider_currency', 'uuid_customer',\n            'resource_id', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_metric'), params.get('date_start'), params.get('date_end'\n            ), params.get('cloud_provider'), params.get('resource_location'\n            ), params.get('subscription_type'), params.get('subscription_id'\n            ), params.get('subscription_name'), params.get('family'\n            ), params.get('category'), params.get('subcategory'), params.get(\n            'object'), params.get('metric'), params.get('unit'), params.get(\n            'resource_group'), params.get('reservation_name'), params.get(\n            'publisher_name'), params.get('local_currency'), params.get(\n            'provider_currency'), params.get('uuid_customer'), params.get(\n            'resource_id'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_v2.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_cost_management_v2/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_create(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Create Cost Multi\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_metric\": \"string\", required\n            \"date\": \"string\", required\n            \"cloud_provider\": \"string\", required\n            \"resource_location\": \"string\", required\n            \"subscription_type\": \"string\", optional\n            \"subscription_id\": \"string\", required\n            \"subscription_name\": \"string\", optional\n            \"family\": \"string\", required\n            \"category\": \"string\", required\n            \"subcategory\": \"string\", required\n            \"object\": \"string\", required\n            \"metric\": \"string\", required\n            \"unit\": \"string\", required\n            \"qnt\": \"number\", optional\n            \"local_currency\": \"string\", required\n            \"unit_cost\": \"number\", required\n            \"total_cost\": \"number\", required\n            \"unit_revenue\": \"number\", required\n            \"total_revenue\": \"number\", required\n            \"provider_currency\": \"string\", required\n            \"unit_cost_pc\": \"number\", required\n            \"total_cost_pc\": \"number\", required\n            \"unit_revenue_pc\": \"number\", required\n            \"total_revenue_pc\": \"number\", required\n            \"cumulative_qnt\": \"number\", required\n            \"cumulative_unit_cost\": \"number\", required\n            \"cumulative_total_cost\": \"number\", required\n            \"cumulative_unit_revenue\": \"number\", required\n            \"cumulative_total_revenue\": \"number\", required\n            \"resource_group\": \"string\", required\n            \"reservation_name\": \"string\", required\n            \"publisher_name\": \"string\", required\n            \"resource_id\": \"string\", required\n            \"tenant_id\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/ts_cost_management_v2/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def ts_cost_management_v2_grouped(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Date\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            cloud_provider (string optional): additional filter - parameter\n            resource_group (string optional): additional filter - parameter\n            resource_location (string optional): additional filter - parameter\n            category (string optional): additional filter - parameter\n            subscription (string optional): additional filter - parameter\n            subscription_type (string optional): additional filter - parameter\n            interval (None optional): additional filter - parameter\n            detailed (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'date_start',\n            'date_end', 'cloud_provider', 'resource_group',\n            'resource_location', 'category', 'subscription',\n            'subscription_type', 'interval', 'detailed', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'date_start'), params.get('date_end'), params.get('cloud_provider'\n            ), params.get('resource_group'), params.get('resource_location'\n            ), params.get('category'), params.get('subscription'), params.get(\n            'subscription_type'), params.get('interval'), params.get('detailed'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_v2_grouped.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/grouped/{uuid_customer}', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_uuid_metric(self, uuid_metric: str,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Cost\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs, params\n            =params)\n        official_params_list = ['date']\n        params.get('date')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_v2.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/{uuid_metric}', warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_ccm_by_date(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Cloud Provider Subscription Type Resource Group\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            interval (None optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'interval',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('interval'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_v2_ccm_by_date\n                .__name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/ccm_by_date/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_ccm_by_subscription_type(self,\n        uuid_customer: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Cloud Provider Subscription Type\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_ccm_by_subscription_type.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/ccm_by_subscription_type/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_ccm_by_category(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Category\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_ccm_by_category.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/ccm_by_category/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_ccm_by_resource_location(self,\n        uuid_customer: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Resource Location\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_ccm_by_resource_location.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/ccm_by_resource_location/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_ccm_by_resource_group(self,\n        uuid_customer: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Resource Group\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_ccm_by_resource_group.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/ccm_by_resource_group/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_ccm_by_subscription(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Group By Subscription\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_ccm_by_subscription.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/ccm_by_subscription/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_anomalies(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Anomalies\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_cost_management_v2_anomalies.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/anomalies/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def ts_cost_management_v2_anomaly_selector(self,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Anomaly Selector\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            sampling (None optional): additional filter - parameter\n            uuid_customer (string required): additional filter - parameter\n            cloud_provider (string required): additional filter - parameter\n            description (string required): additional filter - parameter\n            family (string required): additional filter - parameter\n            category (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs, params\n            =params)\n        official_params_list = ['count', 'date_start', 'date_end',\n            'sampling', 'uuid_customer', 'cloud_provider', 'description',\n            'family', 'category']\n        params.get('count'), params.get('date_start'), params.get('date_end'\n            ), params.get('sampling'), params.get('uuid_customer'), params.get(\n            'cloud_provider'), params.get('description'), params.get('family'\n            ), params.get('category')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_anomaly_selector.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/anomaly_selector/', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_anomaly_selector_geo(self,\n        warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Anomaly Selector Geo\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            sampling (None optional): additional filter - parameter\n            uuid_customer (string required): additional filter - parameter\n            cloud_provider (string required): additional filter - parameter\n            description (string required): additional filter - parameter\n            resource_location (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs, params\n            =params)\n        official_params_list = ['count', 'date_start', 'date_end',\n            'sampling', 'uuid_customer', 'cloud_provider', 'description',\n            'resource_location']\n        params.get('count'), params.get('date_start'), params.get('date_end'\n            ), params.get('sampling'), params.get('uuid_customer'), params.get(\n            'cloud_provider'), params.get('description'), params.get(\n            'resource_location')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_anomaly_selector_geo.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/anomaly_selector_geo/', warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_anomalies_geo(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Query Anomalies Geo\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            date_start (string optional): additional filter - parameter\n            date_end (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('date_start'), params.get('date_end'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_anomalies_geo.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_cost_management_v2/anomalies_geo/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def ts_cost_management_v2_probe_delete(self, uuid_probe: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Delete By Uuid Probe And Date Range\n\n        Args:\n            uuid_probe (str, required): uuid_probe\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            tenant_id (string optional): additional filter - parameter\n            date_start (string required): additional filter - parameter\n            date_end (string required): additional filter - parameter\n            profile (string optional): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['tenant_id', 'date_start', 'date_end',\n            'profile']\n        params.get('tenant_id'), params.get('date_start'), params.get(\n            'date_end'), params.get('profile')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_cost_management_v2_probe_delete.__name__, params,\n                official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_cost_management_v2/probe/{uuid_probe}/', params=params,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2","title":"<code>ts_cost_management_v2(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Costs</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>cloud_provider</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_location</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>family</code> <code>string optional</code> <p>additional filter - parameter</p> <code>category</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subcategory</code> <code>string optional</code> <p>additional filter - parameter</p> <code>object</code> <code>string optional</code> <p>additional filter - parameter</p> <code>metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>reservation_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>publisher_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>local_currency</code> <code>string optional</code> <p>additional filter - parameter</p> <code>provider_currency</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Costs\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        cloud_provider (string optional): additional filter - parameter\n        resource_location (string optional): additional filter - parameter\n        subscription_type (string optional): additional filter - parameter\n        subscription_id (string optional): additional filter - parameter\n        subscription_name (string optional): additional filter - parameter\n        family (string optional): additional filter - parameter\n        category (string optional): additional filter - parameter\n        subcategory (string optional): additional filter - parameter\n        object (string optional): additional filter - parameter\n        metric (string optional): additional filter - parameter\n        unit (string optional): additional filter - parameter\n        resource_group (string optional): additional filter - parameter\n        reservation_name (string optional): additional filter - parameter\n        publisher_name (string optional): additional filter - parameter\n        local_currency (string optional): additional filter - parameter\n        provider_currency (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        resource_id (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n        'date_start', 'date_end', 'cloud_provider', 'resource_location',\n        'subscription_type', 'subscription_id', 'subscription_name',\n        'family', 'category', 'subcategory', 'object', 'metric', 'unit',\n        'resource_group', 'reservation_name', 'publisher_name',\n        'local_currency', 'provider_currency', 'uuid_customer',\n        'resource_id', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_metric'), params.get('date_start'), params.get('date_end'\n        ), params.get('cloud_provider'), params.get('resource_location'\n        ), params.get('subscription_type'), params.get('subscription_id'\n        ), params.get('subscription_name'), params.get('family'\n        ), params.get('category'), params.get('subcategory'), params.get(\n        'object'), params.get('metric'), params.get('unit'), params.get(\n        'resource_group'), params.get('reservation_name'), params.get(\n        'publisher_name'), params.get('local_currency'), params.get(\n        'provider_currency'), params.get('uuid_customer'), params.get(\n        'resource_id'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_v2.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_cost_management_v2/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_anomalies","title":"<code>ts_cost_management_v2_anomalies(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Anomalies</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_anomalies(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Anomalies\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_v2_anomalies.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/anomalies/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_anomalies_geo","title":"<code>ts_cost_management_v2_anomalies_geo(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Anomalies Geo</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_anomalies_geo(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Anomalies Geo\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_anomalies_geo.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/anomalies_geo/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_anomaly_selector","title":"<code>ts_cost_management_v2_anomaly_selector(warm_start=False, kwargs=None, **params)</code>","text":"<p>Query Anomaly Selector</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sampling</code> <code>None optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string required</code> <p>additional filter - parameter</p> <code>cloud_provider</code> <code>string required</code> <p>additional filter - parameter</p> <code>description</code> <code>string required</code> <p>additional filter - parameter</p> <code>family</code> <code>string required</code> <p>additional filter - parameter</p> <code>category</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_anomaly_selector(self,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Anomaly Selector\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        sampling (None optional): additional filter - parameter\n        uuid_customer (string required): additional filter - parameter\n        cloud_provider (string required): additional filter - parameter\n        description (string required): additional filter - parameter\n        family (string required): additional filter - parameter\n        category (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs, params\n        =params)\n    official_params_list = ['count', 'date_start', 'date_end',\n        'sampling', 'uuid_customer', 'cloud_provider', 'description',\n        'family', 'category']\n    params.get('count'), params.get('date_start'), params.get('date_end'\n        ), params.get('sampling'), params.get('uuid_customer'), params.get(\n        'cloud_provider'), params.get('description'), params.get('family'\n        ), params.get('category')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_anomaly_selector.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/anomaly_selector/', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_anomaly_selector_geo","title":"<code>ts_cost_management_v2_anomaly_selector_geo(warm_start=False, kwargs=None, **params)</code>","text":"<p>Query Anomaly Selector Geo</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>sampling</code> <code>None optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string required</code> <p>additional filter - parameter</p> <code>cloud_provider</code> <code>string required</code> <p>additional filter - parameter</p> <code>description</code> <code>string required</code> <p>additional filter - parameter</p> <code>resource_location</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_anomaly_selector_geo(self,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Anomaly Selector Geo\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        sampling (None optional): additional filter - parameter\n        uuid_customer (string required): additional filter - parameter\n        cloud_provider (string required): additional filter - parameter\n        description (string required): additional filter - parameter\n        resource_location (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs, params\n        =params)\n    official_params_list = ['count', 'date_start', 'date_end',\n        'sampling', 'uuid_customer', 'cloud_provider', 'description',\n        'resource_location']\n    params.get('count'), params.get('date_start'), params.get('date_end'\n        ), params.get('sampling'), params.get('uuid_customer'), params.get(\n        'cloud_provider'), params.get('description'), params.get(\n        'resource_location')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_anomaly_selector_geo.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/anomaly_selector_geo/', warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_ccm_by_category","title":"<code>ts_cost_management_v2_ccm_by_category(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Category</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_ccm_by_category(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Category\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_ccm_by_category.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/ccm_by_category/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_ccm_by_date","title":"<code>ts_cost_management_v2_ccm_by_date(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Cloud Provider Subscription Type Resource Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>interval</code> <code>None optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_ccm_by_date(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Cloud Provider Subscription Type Resource Group\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        interval (None optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'interval',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('interval'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_v2_ccm_by_date\n            .__name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/ccm_by_date/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_ccm_by_resource_group","title":"<code>ts_cost_management_v2_ccm_by_resource_group(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Resource Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_ccm_by_resource_group(self,\n    uuid_customer: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Resource Group\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_ccm_by_resource_group.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/ccm_by_resource_group/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_ccm_by_resource_location","title":"<code>ts_cost_management_v2_ccm_by_resource_location(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Resource Location</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_ccm_by_resource_location(self,\n    uuid_customer: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Resource Location\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_ccm_by_resource_location.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/ccm_by_resource_location/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_ccm_by_subscription","title":"<code>ts_cost_management_v2_ccm_by_subscription(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Subscription</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_ccm_by_subscription(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Subscription\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_ccm_by_subscription.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/ccm_by_subscription/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_ccm_by_subscription_type","title":"<code>ts_cost_management_v2_ccm_by_subscription_type(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Cloud Provider Subscription Type</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_ccm_by_subscription_type(self,\n    uuid_customer: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Cloud Provider Subscription Type\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date_start (string optional): additional filter - parameter\n        date_end (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['date_start', 'date_end', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('date_start'), params.get('date_end'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_ccm_by_subscription_type.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/ccm_by_subscription_type/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_create","title":"<code>ts_cost_management_v2_create(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Create Cost Multi</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_metric\": \"string\", required     \"date\": \"string\", required     \"cloud_provider\": \"string\", required     \"resource_location\": \"string\", required     \"subscription_type\": \"string\", optional     \"subscription_id\": \"string\", required     \"subscription_name\": \"string\", optional     \"family\": \"string\", required     \"category\": \"string\", required     \"subcategory\": \"string\", required     \"object\": \"string\", required     \"metric\": \"string\", required     \"unit\": \"string\", required     \"qnt\": \"number\", optional     \"local_currency\": \"string\", required     \"unit_cost\": \"number\", required     \"total_cost\": \"number\", required     \"unit_revenue\": \"number\", required     \"total_revenue\": \"number\", required     \"provider_currency\": \"string\", required     \"unit_cost_pc\": \"number\", required     \"total_cost_pc\": \"number\", required     \"unit_revenue_pc\": \"number\", required     \"total_revenue_pc\": \"number\", required     \"cumulative_qnt\": \"number\", required     \"cumulative_unit_cost\": \"number\", required     \"cumulative_total_cost\": \"number\", required     \"cumulative_unit_revenue\": \"number\", required     \"cumulative_total_revenue\": \"number\", required     \"resource_group\": \"string\", required     \"reservation_name\": \"string\", required     \"publisher_name\": \"string\", required     \"resource_id\": \"string\", required     \"tenant_id\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_create(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Create Cost Multi\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_metric\": \"string\", required\n        \"date\": \"string\", required\n        \"cloud_provider\": \"string\", required\n        \"resource_location\": \"string\", required\n        \"subscription_type\": \"string\", optional\n        \"subscription_id\": \"string\", required\n        \"subscription_name\": \"string\", optional\n        \"family\": \"string\", required\n        \"category\": \"string\", required\n        \"subcategory\": \"string\", required\n        \"object\": \"string\", required\n        \"metric\": \"string\", required\n        \"unit\": \"string\", required\n        \"qnt\": \"number\", optional\n        \"local_currency\": \"string\", required\n        \"unit_cost\": \"number\", required\n        \"total_cost\": \"number\", required\n        \"unit_revenue\": \"number\", required\n        \"total_revenue\": \"number\", required\n        \"provider_currency\": \"string\", required\n        \"unit_cost_pc\": \"number\", required\n        \"total_cost_pc\": \"number\", required\n        \"unit_revenue_pc\": \"number\", required\n        \"total_revenue_pc\": \"number\", required\n        \"cumulative_qnt\": \"number\", required\n        \"cumulative_unit_cost\": \"number\", required\n        \"cumulative_total_cost\": \"number\", required\n        \"cumulative_unit_revenue\": \"number\", required\n        \"cumulative_total_revenue\": \"number\", required\n        \"resource_group\": \"string\", required\n        \"reservation_name\": \"string\", required\n        \"publisher_name\": \"string\", required\n        \"resource_id\": \"string\", required\n        \"tenant_id\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/ts_cost_management_v2/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_grouped","title":"<code>ts_cost_management_v2_grouped(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Query Group By Date</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>cloud_provider</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_group</code> <code>string optional</code> <p>additional filter - parameter</p> <code>resource_location</code> <code>string optional</code> <p>additional filter - parameter</p> <code>category</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription</code> <code>string optional</code> <p>additional filter - parameter</p> <code>subscription_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>interval</code> <code>None optional</code> <p>additional filter - parameter</p> <code>detailed</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_grouped(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Query Group By Date\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        cloud_provider (string optional): additional filter - parameter\n        resource_group (string optional): additional filter - parameter\n        resource_location (string optional): additional filter - parameter\n        category (string optional): additional filter - parameter\n        subscription (string optional): additional filter - parameter\n        subscription_type (string optional): additional filter - parameter\n        interval (None optional): additional filter - parameter\n        detailed (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'date_start',\n        'date_end', 'cloud_provider', 'resource_group',\n        'resource_location', 'category', 'subscription',\n        'subscription_type', 'interval', 'detailed', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'date_start'), params.get('date_end'), params.get('cloud_provider'\n        ), params.get('resource_group'), params.get('resource_location'\n        ), params.get('category'), params.get('subscription'), params.get(\n        'subscription_type'), params.get('interval'), params.get('detailed'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_v2_grouped.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/grouped/{uuid_customer}', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_probe_delete","title":"<code>ts_cost_management_v2_probe_delete(uuid_probe, kwargs=None, **params)</code>","text":"<p>Delete By Uuid Probe And Date Range</p> <p>Parameters:</p> Name Type Description Default <code>uuid_probe</code> <code>(str, required)</code> <p>uuid_probe</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>tenant_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>date_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>date_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_probe_delete(self, uuid_probe: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Delete By Uuid Probe And Date Range\n\n    Args:\n        uuid_probe (str, required): uuid_probe\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        tenant_id (string optional): additional filter - parameter\n        date_start (string required): additional filter - parameter\n        date_end (string required): additional filter - parameter\n        profile (string optional): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['tenant_id', 'date_start', 'date_end',\n        'profile']\n    params.get('tenant_id'), params.get('date_start'), params.get(\n        'date_end'), params.get('profile')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_cost_management_v2_probe_delete.__name__, params,\n            official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_cost_management_v2/probe/{uuid_probe}/', params=params,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_cost_management_v2/#hive.cookbook.ts_cost_management_v2.TsCostManagementV2.ts_cost_management_v2_uuid_metric","title":"<code>ts_cost_management_v2_uuid_metric(uuid_metric, warm_start=False, kwargs=None, **params)</code>","text":"<p>Read Cost</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>date</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_cost_management_v2.py</code> <pre><code>def ts_cost_management_v2_uuid_metric(self, uuid_metric: str,\n    warm_start: bool = False, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Cost\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        date (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs, params\n        =params)\n    official_params_list = ['date']\n    params.get('date')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_cost_management_v2.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_cost_management_v2/{uuid_metric}', warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_status/","title":"Hive.cookbook.ts metric status","text":""},{"location":"hive.cookbook.ts_metric_status/#hive.cookbook.ts_metric_status.TsMetricStatus","title":"<code>TsMetricStatus</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_metric_status APIs</p> Source code in <code>hive/cookbook/ts_metric_status.py</code> <pre><code>class TsMetricStatus(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_metric_status APIs\"\"\"\n\n    def ts_metric_status(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Status Metrics\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_metric (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            ingest_timestamp_start (string optional): additional filter - parameter\n            ingest_timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ranking (integer optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            merge_last_value (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_metric', 'timestamp_start',\n            'timestamp_end', 'ingest_timestamp_start',\n            'ingest_timestamp_end', 'database_timestamp_start',\n            'database_timestamp_end', 'status', 'ranking', 'description',\n            'null_fields', 'merge_last_value', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('uuid_metric'), params.get(\n            'timestamp_start'), params.get('timestamp_end'), params.get(\n            'ingest_timestamp_start'), params.get('ingest_timestamp_end'\n            ), params.get('database_timestamp_start'), params.get(\n            'database_timestamp_end'), params.get('status'), params.get(\n            'ranking'), params.get('description'), params.get('null_fields'\n            ), params.get('merge_last_value'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_status.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/ts_metric_status/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_metric_status_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Status Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n            merge_last_value (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end', 'merge_last_value']\n        params.get('ts_start'), params.get('ts_end'), params.get(\n            'merge_last_value')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_status_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_metric_status/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def ts_metric_status_delete(self, uuid_metric: str, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Delete Status Metric\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            timestamp (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['timestamp']\n        params.get('timestamp')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_status_delete.__name__,\n                params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_metric_status/{uuid_metric}', params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_status/#hive.cookbook.ts_metric_status.TsMetricStatus.ts_metric_status","title":"<code>ts_metric_status(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Status Metrics</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ingest_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ingest_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>merge_last_value</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_status.py</code> <pre><code>def ts_metric_status(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Status Metrics\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_metric (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        ingest_timestamp_start (string optional): additional filter - parameter\n        ingest_timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ranking (integer optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        merge_last_value (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_metric', 'timestamp_start',\n        'timestamp_end', 'ingest_timestamp_start',\n        'ingest_timestamp_end', 'database_timestamp_start',\n        'database_timestamp_end', 'status', 'ranking', 'description',\n        'null_fields', 'merge_last_value', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('uuid_metric'), params.get(\n        'timestamp_start'), params.get('timestamp_end'), params.get(\n        'ingest_timestamp_start'), params.get('ingest_timestamp_end'\n        ), params.get('database_timestamp_start'), params.get(\n        'database_timestamp_end'), params.get('status'), params.get(\n        'ranking'), params.get('description'), params.get('null_fields'\n        ), params.get('merge_last_value'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_status.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/ts_metric_status/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_status/#hive.cookbook.ts_metric_status.TsMetricStatus.ts_metric_status_bulk","title":"<code>ts_metric_status_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Status Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>merge_last_value</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_status.py</code> <pre><code>def ts_metric_status_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Status Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n        merge_last_value (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end', 'merge_last_value']\n    params.get('ts_start'), params.get('ts_end'), params.get(\n        'merge_last_value')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_status_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_metric_status/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_status/#hive.cookbook.ts_metric_status.TsMetricStatus.ts_metric_status_delete","title":"<code>ts_metric_status_delete(uuid_metric, kwargs=None, **params)</code>","text":"<p>Delete Status Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>timestamp</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_status.py</code> <pre><code>def ts_metric_status_delete(self, uuid_metric: str, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Delete Status Metric\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        timestamp (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['timestamp']\n    params.get('timestamp')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_status_delete.__name__,\n            params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_metric_status/{uuid_metric}', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_value/","title":"Hive.cookbook.ts metric value","text":""},{"location":"hive.cookbook.ts_metric_value/#hive.cookbook.ts_metric_value.TsMetricValue","title":"<code>TsMetricValue</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_metric_value APIs</p> Source code in <code>hive/cookbook/ts_metric_value.py</code> <pre><code>class TsMetricValue(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_metric_value APIs\"\"\"\n\n    def ts_metric_value(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Value Metrics\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_metric (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            ingest_timestamp_start (string optional): additional filter - parameter\n            ingest_timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            value (number optional): additional filter - parameter\n            merge_last_value (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n            'timestamp_start', 'timestamp_end', 'ingest_timestamp_start',\n            'ingest_timestamp_end', 'database_timestamp_start',\n            'database_timestamp_end', 'value', 'merge_last_value', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_metric'), params.get('timestamp_start'), params.get(\n            'timestamp_end'), params.get('ingest_timestamp_start'), params.get(\n            'ingest_timestamp_end'), params.get('database_timestamp_start'\n            ), params.get('database_timestamp_end'), params.get('value'\n            ), params.get('merge_last_value'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_value.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/ts_metric_value/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_metric_value_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Value Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n            merge_last_value (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end', 'merge_last_value']\n        params.get('ts_start'), params.get('ts_end'), params.get(\n            'merge_last_value')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_value_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/ts_metric_value/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def ts_metric_value_plot_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Plot Ts\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            title (string optional): additional filter - payload\n            filename (string optional): additional filter - payload\n            time_series (array required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['title', 'filename', 'time_series']\n        payload.get('title'), payload.get('filename'), payload.get(\n            'time_series')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_value_plot_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/ts_metric_value/plot/',\n            payload=payload, **kwargs)\n        return response\n\n    def ts_metric_value_delete(self, uuid_metric: str, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Delete Value Metric\n\n        Args:\n            uuid_metric (str, required): uuid_metric\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            timestamp (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['timestamp']\n        params.get('timestamp')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_metric_value_delete.__name__,\n                params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_metric_value/{uuid_metric}', params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_value/#hive.cookbook.ts_metric_value.TsMetricValue.ts_metric_value","title":"<code>ts_metric_value(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Value Metrics</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_metric</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ingest_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ingest_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>value</code> <code>number optional</code> <p>additional filter - parameter</p> <code>merge_last_value</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_value.py</code> <pre><code>def ts_metric_value(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Value Metrics\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_metric (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        ingest_timestamp_start (string optional): additional filter - parameter\n        ingest_timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        value (number optional): additional filter - parameter\n        merge_last_value (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_metric',\n        'timestamp_start', 'timestamp_end', 'ingest_timestamp_start',\n        'ingest_timestamp_end', 'database_timestamp_start',\n        'database_timestamp_end', 'value', 'merge_last_value', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_metric'), params.get('timestamp_start'), params.get(\n        'timestamp_end'), params.get('ingest_timestamp_start'), params.get(\n        'ingest_timestamp_end'), params.get('database_timestamp_start'\n        ), params.get('database_timestamp_end'), params.get('value'\n        ), params.get('merge_last_value'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_value.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/ts_metric_value/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_value/#hive.cookbook.ts_metric_value.TsMetricValue.ts_metric_value_bulk","title":"<code>ts_metric_value_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Value Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <code>merge_last_value</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_value.py</code> <pre><code>def ts_metric_value_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Value Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n        merge_last_value (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end', 'merge_last_value']\n    params.get('ts_start'), params.get('ts_end'), params.get(\n        'merge_last_value')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_value_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/ts_metric_value/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_value/#hive.cookbook.ts_metric_value.TsMetricValue.ts_metric_value_delete","title":"<code>ts_metric_value_delete(uuid_metric, kwargs=None, **params)</code>","text":"<p>Delete Value Metric</p> <p>Parameters:</p> Name Type Description Default <code>uuid_metric</code> <code>(str, required)</code> <p>uuid_metric</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>timestamp</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_value.py</code> <pre><code>def ts_metric_value_delete(self, uuid_metric: str, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Delete Value Metric\n\n    Args:\n        uuid_metric (str, required): uuid_metric\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        timestamp (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['timestamp']\n    params.get('timestamp')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_value_delete.__name__,\n            params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_metric_value/{uuid_metric}', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_metric_value/#hive.cookbook.ts_metric_value.TsMetricValue.ts_metric_value_plot_create","title":"<code>ts_metric_value_plot_create(kwargs=None, **payload)</code>","text":"<p>Plot Ts</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>title</code> <code>string optional</code> <p>additional filter - payload</p> <code>filename</code> <code>string optional</code> <p>additional filter - payload</p> <code>time_series</code> <code>array required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_metric_value.py</code> <pre><code>def ts_metric_value_plot_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Plot Ts\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        title (string optional): additional filter - payload\n        filename (string optional): additional filter - payload\n        time_series (array required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['title', 'filename', 'time_series']\n    payload.get('title'), payload.get('filename'), payload.get(\n        'time_series')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_metric_value_plot_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/ts_metric_value/plot/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/","title":"Hive.cookbook.ts ntop flows","text":""},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows","title":"<code>TsNtopFlows</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_ntop_flows APIs</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>class TsNtopFlows(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_ntop_flows APIs\"\"\"\n\n    def ts_ntop_flows(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Data\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            uuid_site_src (string optional): additional filter - parameter\n            uuid_site_dst (string optional): additional filter - parameter\n            l7_proto (string optional): additional filter - parameter\n            ip_src_addr (string optional): additional filter - parameter\n            ip_dst_addr (string optional): additional filter - parameter\n            l4_dst_port (integer optional): additional filter - parameter\n            fqdn_src_addr (string optional): additional filter - parameter\n            fqdn_dst_addr (string optional): additional filter - parameter\n            in_bytes (integer optional): additional filter - parameter\n            out_bytes (integer optional): additional filter - parameter\n            last_switched_start (string optional): additional filter - parameter\n            last_switched_end (string optional): additional filter - parameter\n            interface_id (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_service',\n            'uuid_site_src', 'uuid_site_dst', 'l7_proto', 'ip_src_addr',\n            'ip_dst_addr', 'l4_dst_port', 'fqdn_src_addr', 'fqdn_dst_addr',\n            'in_bytes', 'out_bytes', 'last_switched_start',\n            'last_switched_end', 'interface_id', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_service'), params.get('uuid_site_src'), params.get(\n            'uuid_site_dst'), params.get('l7_proto'), params.get('ip_src_addr'\n            ), params.get('ip_dst_addr'), params.get('l4_dst_port'\n            ), params.get('fqdn_src_addr'), params.get('fqdn_dst_addr'\n            ), params.get('in_bytes'), params.get('out_bytes'), params.get(\n            'last_switched_start'), params.get('last_switched_end'\n            ), params.get('interface_id'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_ntop_flows.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/ts_ntop_flows/', single_page\n            =single_page, page_size=page_size, warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def ts_ntop_flows_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Create Ts Ntop Flow\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_service\": \"string\", optional\n            \"uuid_site_src\": \"string\", optional\n            \"uuid_site_dst\": \"string\", optional\n            \"l7_proto\": \"string\", optional\n            \"l4_dst_port\": \"integer\", optional\n            \"ip_src_addr\": \"integer string string\", optional\n            \"ip_dst_addr\": \"integer string string\", optional\n            \"fqdn_src_addr\": \"string\", optional\n            \"fqdn_dst_addr\": \"string\", optional\n            \"in_bytes\": \"integer\", optional\n            \"out_bytes\": \"integer\", optional\n            \"last_switched\": \"string\", required\n            \"interface_id\": \"integer\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/ts_ntop_flows/bulk/create/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def ts_ntop_flows_top_protocols(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Top Protocols\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            uuid_site (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            data_interval_hours (integer optional): additional filter - parameter\n            list_interval_days (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['uuid_site', 'profile',\n            'data_interval_hours', 'list_interval_days', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('uuid_site'), params.get('profile'), params.get(\n            'data_interval_hours'), params.get('list_interval_days'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_ntop_flows_top_protocols.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_ntop_flows/top_protocols/{uuid_customer}', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def ts_ntop_flows_top_talkers(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Top Talkers\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            uuid_site (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            data_interval_hours (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['uuid_site', 'profile',\n            'data_interval_hours', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('uuid_site'), params.get('profile'), params.get(\n            'data_interval_hours'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_ntop_flows_top_talkers.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_ntop_flows/top_talkers/{uuid_customer}', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def ts_ntop_flows_top_receivers(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Top Receivers\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            uuid_site (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            data_interval_hours (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['uuid_site', 'profile',\n            'data_interval_hours', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('uuid_site'), params.get('profile'), params.get(\n            'data_interval_hours'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_ntop_flows_top_receivers.\n                __name__, params, official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_ntop_flows/top_receivers/{uuid_customer}', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def ts_ntop_flows_top_protocols_history(self, uuid_customer: str,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Get Top Used Protocols\n\n        Args:\n            uuid_customer (str, required): uuid_customer\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            uuid_site (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            data_interval_hours (integer optional): additional filter - parameter\n            list_interval_days (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['uuid_site', 'profile',\n            'data_interval_hours', 'list_interval_days', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('uuid_site'), params.get('profile'), params.get(\n            'data_interval_hours'), params.get('list_interval_days'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.\n                ts_ntop_flows_top_protocols_history.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=\n            f'/ts_ntop_flows/top_protocols_history/{uuid_customer}',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows.ts_ntop_flows","title":"<code>ts_ntop_flows(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Data</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site_src</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_site_dst</code> <code>string optional</code> <p>additional filter - parameter</p> <code>l7_proto</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ip_src_addr</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ip_dst_addr</code> <code>string optional</code> <p>additional filter - parameter</p> <code>l4_dst_port</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>fqdn_src_addr</code> <code>string optional</code> <p>additional filter - parameter</p> <code>fqdn_dst_addr</code> <code>string optional</code> <p>additional filter - parameter</p> <code>in_bytes</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>out_bytes</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>last_switched_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>last_switched_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>interface_id</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>def ts_ntop_flows(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Data\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        uuid_site_src (string optional): additional filter - parameter\n        uuid_site_dst (string optional): additional filter - parameter\n        l7_proto (string optional): additional filter - parameter\n        ip_src_addr (string optional): additional filter - parameter\n        ip_dst_addr (string optional): additional filter - parameter\n        l4_dst_port (integer optional): additional filter - parameter\n        fqdn_src_addr (string optional): additional filter - parameter\n        fqdn_dst_addr (string optional): additional filter - parameter\n        in_bytes (integer optional): additional filter - parameter\n        out_bytes (integer optional): additional filter - parameter\n        last_switched_start (string optional): additional filter - parameter\n        last_switched_end (string optional): additional filter - parameter\n        interface_id (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_service',\n        'uuid_site_src', 'uuid_site_dst', 'l7_proto', 'ip_src_addr',\n        'ip_dst_addr', 'l4_dst_port', 'fqdn_src_addr', 'fqdn_dst_addr',\n        'in_bytes', 'out_bytes', 'last_switched_start',\n        'last_switched_end', 'interface_id', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_service'), params.get('uuid_site_src'), params.get(\n        'uuid_site_dst'), params.get('l7_proto'), params.get('ip_src_addr'\n        ), params.get('ip_dst_addr'), params.get('l4_dst_port'\n        ), params.get('fqdn_src_addr'), params.get('fqdn_dst_addr'\n        ), params.get('in_bytes'), params.get('out_bytes'), params.get(\n        'last_switched_start'), params.get('last_switched_end'\n        ), params.get('interface_id'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_ntop_flows.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/ts_ntop_flows/', single_page\n        =single_page, page_size=page_size, warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows.ts_ntop_flows_create_bulk","title":"<code>ts_ntop_flows_create_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Create Ts Ntop Flow</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_service\": \"string\", optional     \"uuid_site_src\": \"string\", optional     \"uuid_site_dst\": \"string\", optional     \"l7_proto\": \"string\", optional     \"l4_dst_port\": \"integer\", optional     \"ip_src_addr\": \"integer string string\", optional     \"ip_dst_addr\": \"integer string string\", optional     \"fqdn_src_addr\": \"string\", optional     \"fqdn_dst_addr\": \"string\", optional     \"in_bytes\": \"integer\", optional     \"out_bytes\": \"integer\", optional     \"last_switched\": \"string\", required     \"interface_id\": \"integer\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>def ts_ntop_flows_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Create Ts Ntop Flow\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_service\": \"string\", optional\n        \"uuid_site_src\": \"string\", optional\n        \"uuid_site_dst\": \"string\", optional\n        \"l7_proto\": \"string\", optional\n        \"l4_dst_port\": \"integer\", optional\n        \"ip_src_addr\": \"integer string string\", optional\n        \"ip_dst_addr\": \"integer string string\", optional\n        \"fqdn_src_addr\": \"string\", optional\n        \"fqdn_dst_addr\": \"string\", optional\n        \"in_bytes\": \"integer\", optional\n        \"out_bytes\": \"integer\", optional\n        \"last_switched\": \"string\", required\n        \"interface_id\": \"integer\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/ts_ntop_flows/bulk/create/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows.ts_ntop_flows_top_protocols","title":"<code>ts_ntop_flows_top_protocols(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Top Protocols</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>data_interval_hours</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>list_interval_days</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>def ts_ntop_flows_top_protocols(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Top Protocols\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        uuid_site (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        data_interval_hours (integer optional): additional filter - parameter\n        list_interval_days (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['uuid_site', 'profile',\n        'data_interval_hours', 'list_interval_days', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('uuid_site'), params.get('profile'), params.get(\n        'data_interval_hours'), params.get('list_interval_days'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_ntop_flows_top_protocols.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_ntop_flows/top_protocols/{uuid_customer}', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows.ts_ntop_flows_top_protocols_history","title":"<code>ts_ntop_flows_top_protocols_history(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Top Used Protocols</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>data_interval_hours</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>list_interval_days</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>def ts_ntop_flows_top_protocols_history(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Top Used Protocols\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        uuid_site (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        data_interval_hours (integer optional): additional filter - parameter\n        list_interval_days (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['uuid_site', 'profile',\n        'data_interval_hours', 'list_interval_days', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('uuid_site'), params.get('profile'), params.get(\n        'data_interval_hours'), params.get('list_interval_days'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.\n            ts_ntop_flows_top_protocols_history.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_ntop_flows/top_protocols_history/{uuid_customer}',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows.ts_ntop_flows_top_receivers","title":"<code>ts_ntop_flows_top_receivers(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Top Receivers</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>data_interval_hours</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>def ts_ntop_flows_top_receivers(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Top Receivers\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        uuid_site (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        data_interval_hours (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['uuid_site', 'profile',\n        'data_interval_hours', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('uuid_site'), params.get('profile'), params.get(\n        'data_interval_hours'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_ntop_flows_top_receivers.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_ntop_flows/top_receivers/{uuid_customer}', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_ntop_flows/#hive.cookbook.ts_ntop_flows.TsNtopFlows.ts_ntop_flows_top_talkers","title":"<code>ts_ntop_flows_top_talkers(uuid_customer, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Get Top Talkers</p> <p>Parameters:</p> Name Type Description Default <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_site</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>data_interval_hours</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_ntop_flows.py</code> <pre><code>def ts_ntop_flows_top_talkers(self, uuid_customer: str,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Get Top Talkers\n\n    Args:\n        uuid_customer (str, required): uuid_customer\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        uuid_site (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        data_interval_hours (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['uuid_site', 'profile',\n        'data_interval_hours', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('uuid_site'), params.get('profile'), params.get(\n        'data_interval_hours'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_ntop_flows_top_talkers.\n            __name__, params, official_params_list)\n    response = self.execute('GET', path=\n        f'/ts_ntop_flows/top_talkers/{uuid_customer}', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/","title":"Hive.cookbook.ts service status","text":""},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus","title":"<code>TsServiceStatus</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_service_status APIs</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>class TsServiceStatus(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_service_status APIs\"\"\"\n\n    def ts_service_status(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Status Services\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            uuid_service (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ranking (integer optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            null_fields (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'uuid_service',\n            'timestamp_start', 'timestamp_end', 'database_timestamp_start',\n            'database_timestamp_end', 'status', 'ranking', 'description',\n            'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('uuid_service'), params.get(\n            'timestamp_start'), params.get('timestamp_end'), params.get(\n            'database_timestamp_start'), params.get('database_timestamp_end'\n            ), params.get('status'), params.get('ranking'), params.get(\n            'description'), params.get('null_fields'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_status.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_service_status/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_service_status_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Timeseries Service Status\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_service (string required): additional filter - payload\n            timestamp (string required): additional filter - payload\n            status ( optional): additional filter - payload\n            ranking (integer optional): additional filter - payload\n            description (string optional): additional filter - payload\n            extended_attributes (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_service', 'timestamp', 'status',\n            'ranking', 'description', 'extended_attributes']\n        payload.get('uuid_service'), payload.get('timestamp'), payload.get(\n            'status'), payload.get('ranking'), payload.get('description'\n            ), payload.get('extended_attributes')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_status_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/ts_service_status/',\n            payload=payload, **kwargs)\n        return response\n\n    def ts_service_status_delete(self, uuid_service: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Delete Timeseries Service Status\n\n        Args:\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_status_delete.__name__,\n                params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_service_status/{uuid_service}/', params=params, **kwargs)\n        return response\n\n    def ts_service_status_query(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Services\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_parent (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ts_description (string optional): additional filter - parameter\n            ts_status (string optional): additional filter - parameter\n            ts_timestamp_start (string optional): additional filter - parameter\n            ts_timestamp_end (string optional): additional filter - parameter\n            ts_ranking (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_parent',\n            'uuid_customer', 'profile', 'name', 'description', 'status',\n            'ts_description', 'ts_status', 'ts_timestamp_start',\n            'ts_timestamp_end', 'ts_ranking', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_parent'), params.get('uuid_customer'), params.get('profile'\n            ), params.get('name'), params.get('description'), params.get(\n            'status'), params.get('ts_description'), params.get('ts_status'\n            ), params.get('ts_timestamp_start'), params.get('ts_timestamp_end'\n            ), params.get('ts_ranking'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_status_query.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_service_status/query/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_service_status_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Status Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_status_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_service_status/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def ts_service_status_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Create Ts Service Status\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_service\": \"string\", required\n            \"timestamp\": \"string\", required\n            \"status\": \"\", optional\n            \"ranking\": \"integer\", optional\n            \"description\": \"string\", optional\n            \"extended_attributes\": \"array object\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/ts_service_status/bulk/create/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def ts_service_status_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Delete Ts Service Status\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_status_delete_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_service_status/bulk/delete/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status","title":"<code>ts_service_status(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Status Services</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Status Services\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        uuid_service (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ranking (integer optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        null_fields (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'uuid_service',\n        'timestamp_start', 'timestamp_end', 'database_timestamp_start',\n        'database_timestamp_end', 'status', 'ranking', 'description',\n        'null_fields', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('uuid_service'), params.get(\n        'timestamp_start'), params.get('timestamp_end'), params.get(\n        'database_timestamp_start'), params.get('database_timestamp_end'\n        ), params.get('status'), params.get('ranking'), params.get(\n        'description'), params.get('null_fields'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_status.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_service_status/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status_bulk","title":"<code>ts_service_status_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Read Status Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Status Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_status_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_service_status/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status_create","title":"<code>ts_service_status_create(kwargs=None, **payload)</code>","text":"<p>Create Timeseries Service Status</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_service</code> <code>string required</code> <p>additional filter - payload</p> <code>timestamp</code> <code>string required</code> <p>additional filter - payload</p> <code>status</code> <code>optional</code> <p>additional filter - payload</p> <code>ranking</code> <code>integer optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>extended_attributes</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Timeseries Service Status\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_service (string required): additional filter - payload\n        timestamp (string required): additional filter - payload\n        status ( optional): additional filter - payload\n        ranking (integer optional): additional filter - payload\n        description (string optional): additional filter - payload\n        extended_attributes (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_service', 'timestamp', 'status',\n        'ranking', 'description', 'extended_attributes']\n    payload.get('uuid_service'), payload.get('timestamp'), payload.get(\n        'status'), payload.get('ranking'), payload.get('description'\n        ), payload.get('extended_attributes')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_status_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/ts_service_status/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status_create_bulk","title":"<code>ts_service_status_create_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Create Ts Service Status</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_service\": \"string\", required     \"timestamp\": \"string\", required     \"status\": \"\", optional     \"ranking\": \"integer\", optional     \"description\": \"string\", optional     \"extended_attributes\": \"array object\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Create Ts Service Status\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_service\": \"string\", required\n        \"timestamp\": \"string\", required\n        \"status\": \"\", optional\n        \"ranking\": \"integer\", optional\n        \"description\": \"string\", optional\n        \"extended_attributes\": \"array object\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/ts_service_status/bulk/create/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status_delete","title":"<code>ts_service_status_delete(uuid_service, kwargs=None, **params)</code>","text":"<p>Delete Timeseries Service Status</p> <p>Parameters:</p> Name Type Description Default <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status_delete(self, uuid_service: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Delete Timeseries Service Status\n\n    Args:\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_status_delete.__name__,\n            params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_service_status/{uuid_service}/', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status_delete_bulk","title":"<code>ts_service_status_delete_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Delete Ts Service Status</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Delete Ts Service Status\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_status_delete_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_service_status/bulk/delete/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_status/#hive.cookbook.ts_service_status.TsServiceStatus.ts_service_status_query","title":"<code>ts_service_status_query(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Services</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_ranking</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_status.py</code> <pre><code>def ts_service_status_query(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Services\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_parent (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ts_description (string optional): additional filter - parameter\n        ts_status (string optional): additional filter - parameter\n        ts_timestamp_start (string optional): additional filter - parameter\n        ts_timestamp_end (string optional): additional filter - parameter\n        ts_ranking (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_parent',\n        'uuid_customer', 'profile', 'name', 'description', 'status',\n        'ts_description', 'ts_status', 'ts_timestamp_start',\n        'ts_timestamp_end', 'ts_ranking', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_parent'), params.get('uuid_customer'), params.get('profile'\n        ), params.get('name'), params.get('description'), params.get(\n        'status'), params.get('ts_description'), params.get('ts_status'\n        ), params.get('ts_timestamp_start'), params.get('ts_timestamp_end'\n        ), params.get('ts_ranking'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_status_query.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_service_status/query/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/","title":"Hive.cookbook.ts service value","text":""},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue","title":"<code>TsServiceValue</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata ts_service_value APIs</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>class TsServiceValue(ApiManager):\n    \"\"\"Class that handles all the XAutomata ts_service_value APIs\"\"\"\n\n    def ts_service_value(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Value Services\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_service (string optional): additional filter - parameter\n            timestamp_start (string optional): additional filter - parameter\n            timestamp_end (string optional): additional filter - parameter\n            database_timestamp_start (string optional): additional filter - parameter\n            database_timestamp_end (string optional): additional filter - parameter\n            unit (string optional): additional filter - parameter\n            value (number optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_service',\n            'timestamp_start', 'timestamp_end', 'database_timestamp_start',\n            'database_timestamp_end', 'unit', 'value', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_service'), params.get('timestamp_start'), params.get(\n            'timestamp_end'), params.get('database_timestamp_start'\n            ), params.get('database_timestamp_end'), params.get('unit'\n            ), params.get('value'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_value.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/ts_service_value/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_service_value_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Timeseries Service Value\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            uuid_service (string required): additional filter - payload\n            timestamp (string required): additional filter - payload\n            unit (string optional): additional filter - payload\n            value (number required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['uuid_service', 'timestamp', 'unit', 'value']\n        payload.get('uuid_service'), payload.get('timestamp'), payload.get(\n            'unit'), payload.get('value')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_value_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/ts_service_value/', payload\n            =payload, **kwargs)\n        return response\n\n    def ts_service_value_delete(self, uuid_service: str,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Delete Timeseries Service Value\n\n        Args:\n            uuid_service (str, required): uuid_service\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_value_delete.__name__,\n                params, official_params_list)\n        response = self.execute('DELETE', path=\n            f'/ts_service_value/{uuid_service}/', params=params, **kwargs)\n        return response\n\n    def ts_service_value_query(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Services\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            uuid_parent (string optional): additional filter - parameter\n            uuid_customer (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            ts_timestamp_start (string optional): additional filter - parameter\n            ts_timestamp_end (string optional): additional filter - parameter\n            ts_unit (string optional): additional filter - parameter\n            ts_value (number optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'uuid_parent',\n            'uuid_customer', 'profile', 'name', 'description', 'status',\n            'ts_timestamp_start', 'ts_timestamp_end', 'ts_unit', 'ts_value',\n            'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'uuid_parent'), params.get('uuid_customer'), params.get('profile'\n            ), params.get('name'), params.get('description'), params.get(\n            'status'), params.get('ts_timestamp_start'), params.get(\n            'ts_timestamp_end'), params.get('ts_unit'), params.get('ts_value'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_value_query.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/ts_service_value/query/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def ts_service_value_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Read Status Metrics\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_value_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_service_value/bulk/read/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def ts_service_value_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Create Ts Service Value\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"uuid_service\": \"string\", required\n            \"timestamp\": \"string\", required\n            \"unit\": \"string\", optional\n            \"value\": \"number\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/ts_service_value/bulk/create/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def ts_service_value_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Delete Ts Service Value\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            ts_start (string required): additional filter - parameter\n            ts_end (string required): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['ts_start', 'ts_end']\n        params.get('ts_start'), params.get('ts_end')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.ts_service_value_delete_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/ts_service_value/bulk/delete/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value","title":"<code>ts_service_value(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Value Services</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_service</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>database_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>value</code> <code>number optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Value Services\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_service (string optional): additional filter - parameter\n        timestamp_start (string optional): additional filter - parameter\n        timestamp_end (string optional): additional filter - parameter\n        database_timestamp_start (string optional): additional filter - parameter\n        database_timestamp_end (string optional): additional filter - parameter\n        unit (string optional): additional filter - parameter\n        value (number optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_service',\n        'timestamp_start', 'timestamp_end', 'database_timestamp_start',\n        'database_timestamp_end', 'unit', 'value', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_service'), params.get('timestamp_start'), params.get(\n        'timestamp_end'), params.get('database_timestamp_start'\n        ), params.get('database_timestamp_end'), params.get('unit'\n        ), params.get('value'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_value.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/ts_service_value/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value_bulk","title":"<code>ts_service_value_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Read Status Metrics</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Read Status Metrics\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_value_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_service_value/bulk/read/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value_create","title":"<code>ts_service_value_create(kwargs=None, **payload)</code>","text":"<p>Create Timeseries Service Value</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>uuid_service</code> <code>string required</code> <p>additional filter - payload</p> <code>timestamp</code> <code>string required</code> <p>additional filter - payload</p> <code>unit</code> <code>string optional</code> <p>additional filter - payload</p> <code>value</code> <code>number required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Timeseries Service Value\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        uuid_service (string required): additional filter - payload\n        timestamp (string required): additional filter - payload\n        unit (string optional): additional filter - payload\n        value (number required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['uuid_service', 'timestamp', 'unit', 'value']\n    payload.get('uuid_service'), payload.get('timestamp'), payload.get(\n        'unit'), payload.get('value')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_value_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/ts_service_value/', payload\n        =payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value_create_bulk","title":"<code>ts_service_value_create_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Create Ts Service Value</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"uuid_service\": \"string\", required     \"timestamp\": \"string\", required     \"unit\": \"string\", optional     \"value\": \"number\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Create Ts Service Value\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"uuid_service\": \"string\", required\n        \"timestamp\": \"string\", required\n        \"unit\": \"string\", optional\n        \"value\": \"number\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/ts_service_value/bulk/create/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value_delete","title":"<code>ts_service_value_delete(uuid_service, kwargs=None, **params)</code>","text":"<p>Delete Timeseries Service Value</p> <p>Parameters:</p> Name Type Description Default <code>uuid_service</code> <code>(str, required)</code> <p>uuid_service</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value_delete(self, uuid_service: str,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Delete Timeseries Service Value\n\n    Args:\n        uuid_service (str, required): uuid_service\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_value_delete.__name__,\n            params, official_params_list)\n    response = self.execute('DELETE', path=\n        f'/ts_service_value/{uuid_service}/', params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value_delete_bulk","title":"<code>ts_service_value_delete_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Delete Ts Service Value</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>ts_start</code> <code>string required</code> <p>additional filter - parameter</p> <code>ts_end</code> <code>string required</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Delete Ts Service Value\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        ts_start (string required): additional filter - parameter\n        ts_end (string required): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['ts_start', 'ts_end']\n    params.get('ts_start'), params.get('ts_end')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_value_delete_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/ts_service_value/bulk/delete/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.ts_service_value/#hive.cookbook.ts_service_value.TsServiceValue.ts_service_value_query","title":"<code>ts_service_value_query(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Services</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_parent</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_customer</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_timestamp_start</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_timestamp_end</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_unit</code> <code>string optional</code> <p>additional filter - parameter</p> <code>ts_value</code> <code>number optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/ts_service_value.py</code> <pre><code>def ts_service_value_query(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Services\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        uuid_parent (string optional): additional filter - parameter\n        uuid_customer (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        ts_timestamp_start (string optional): additional filter - parameter\n        ts_timestamp_end (string optional): additional filter - parameter\n        ts_unit (string optional): additional filter - parameter\n        ts_value (number optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'uuid_parent',\n        'uuid_customer', 'profile', 'name', 'description', 'status',\n        'ts_timestamp_start', 'ts_timestamp_end', 'ts_unit', 'ts_value',\n        'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'uuid_parent'), params.get('uuid_customer'), params.get('profile'\n        ), params.get('name'), params.get('description'), params.get(\n        'status'), params.get('ts_timestamp_start'), params.get(\n        'ts_timestamp_end'), params.get('ts_unit'), params.get('ts_value'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.ts_service_value_query.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/ts_service_value/query/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/","title":"Hive.cookbook.users","text":""},{"location":"hive.cookbook.users/#hive.cookbook.users.Users","title":"<code>Users</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata users APIs</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>class Users(ApiManager):\n    \"\"\"Class that handles all the XAutomata users APIs\"\"\"\n\n    def users_register_create(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Registration Form\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            app_id (string optional): additional filter - parameter\n            password (string required): additional filter - payload\n            name (string required): additional filter - payload\n            email (string required): additional filter - payload\n            phone (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['password', 'name', 'email', 'phone']\n        payload.get('password'), payload.get('name'), payload.get('email'\n            ), payload.get('phone')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_register_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/users/register', params=\n            params, payload=payload, **kwargs)\n        return response\n\n    def users_verify_email(self, warm_start: bool = False,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Verify Me\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            verification_code (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n            params=params.copy())\n        official_params_list = ['verification_code']\n        params.get('verification_code')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_verify_email.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/users/verify_email',\n            warm_start=warm_start, params=params, **kwargs)\n        return response\n\n    def users_password_reset_create(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Send Mail Password Reset\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            app_id (string optional): additional filter - parameter\n            username (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['username']\n        payload.get('username')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_password_reset_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/users/password_reset',\n            params=params, payload=payload, **kwargs)\n        return response\n\n    def users_password_reset_put(self, params: dict = False,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Reset Password\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            app_id (string optional): additional filter - parameter\n            verification_code (string required): additional filter - payload\n            new_password (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['verification_code', 'new_password']\n        payload.get('verification_code'), payload.get('new_password')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_password_reset_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/users/password_reset',\n            params=params, payload=payload, **kwargs)\n        return response\n\n    def users(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Users\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            email (string optional): additional filter - parameter\n            phone (string optional): additional filter - parameter\n            profile (string optional): additional filter - parameter\n            uuid_acl_override (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'name', 'active',\n            'email', 'phone', 'profile', 'uuid_acl_override', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('name'\n            ), params.get('active'), params.get('email'), params.get('phone'\n            ), params.get('profile'), params.get('uuid_acl_override'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/users/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def users_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create User\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            password (string required): additional filter - payload\n            phone (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            name (string required): additional filter - payload\n            email (string required): additional filter - payload\n            active (boolean required): additional filter - payload\n            acl (object required): additional filter - payload\n            uuid_acl_override (string optional): additional filter - payload\n            verified_email (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['password', 'phone', 'profile', 'name',\n            'email', 'active', 'acl', 'uuid_acl_override', 'verified_email']\n        payload.get('password'), payload.get('phone'), payload.get('profile'\n            ), payload.get('name'), payload.get('email'), payload.get('active'\n            ), payload.get('acl'), payload.get('uuid_acl_override'\n            ), payload.get('verified_email')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/users/', payload=payload,\n            **kwargs)\n        return response\n\n    def users_create_uuid_customer(self, uuid_customer: str,\n        params: dict = False, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create User Tenant\n\n        Args:\n            params (dict, optional): additional parameters for the API.\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            send_mail (boolean optional): additional filter - parameter\n            phone (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            name (string required): additional filter - payload\n            email (string required): additional filter - payload\n            active (boolean required): additional filter - payload\n            acl (object required): additional filter - payload\n            uuid_acl_override (string optional): additional filter - payload\n            verified_email (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['phone', 'profile', 'name', 'email',\n            'active', 'acl', 'uuid_acl_override', 'verified_email']\n        payload.get('phone'), payload.get('profile'), payload.get('name'\n            ), payload.get('email'), payload.get('active'), payload.get('acl'\n            ), payload.get('uuid_acl_override'), payload.get('verified_email')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/users/{uuid_customer}',\n            params=params, payload=payload, **kwargs)\n        return response\n\n    def user(self, name: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read User\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/users/{name}', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def users_put(self, name: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update User\n\n        Args:\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            password (string optional): additional filter - payload\n            phone (string optional): additional filter - payload\n            profile (string optional): additional filter - payload\n            email (string optional): additional filter - payload\n            stage (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n            acl (object optional): additional filter - payload\n            uuid_acl_override (string optional): additional filter - payload\n            verified_email (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['password', 'phone', 'profile', 'email',\n            'stage', 'active', 'acl', 'uuid_acl_override', 'verified_email']\n        payload.get('password'), payload.get('phone'), payload.get('profile'\n            ), payload.get('email'), payload.get('stage'), payload.get('active'\n            ), payload.get('acl'), payload.get('uuid_acl_override'\n            ), payload.get('verified_email')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/users/{name}', payload=\n            payload, **kwargs)\n        return response\n\n    def users_delete(self, name: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete User\n\n        Args:\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/users/{name}', **kwargs)\n        return response\n\n    def users_dashboards(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dashboards\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            dashboard_name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'dashboard_name', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('dashboard_name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_dashboards.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/users/{name}/dashboards',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def users_dashboards_create(self, name: str, uuid_dashboard: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Dashboard\n\n        Args:\n            name (str, required): name\n            uuid_dashboard (str, required): uuid_dashboard\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/dashboards/{uuid_dashboard}', **kwargs)\n        return response\n\n    def users_dashboards_delete(self, name: str, uuid_dashboard: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Dashboard\n\n        Args:\n            name (str, required): name\n            uuid_dashboard (str, required): uuid_dashboard\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/dashboards/{uuid_dashboard}', **kwargs)\n        return response\n\n    def users_groups(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'group_name', 'status', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('group_name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/users/{name}/groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def users_groups_create(self, name: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Group\n\n        Args:\n            name (str, required): name\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def users_groups_delete(self, name: str, uuid_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Group\n\n        Args:\n            name (str, required): name\n            uuid_group (str, required): uuid_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/groups/{uuid_group}', **kwargs)\n        return response\n\n    def users_virtual_domains(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Virtual Domains\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            domain_code (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'domain_code', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('domain_code'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_virtual_domains.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/users/{name}/virtual_domains', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def users_virtual_domains_create(self, name: str,\n        uuid_virtual_domain: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Add Virtual Domain\n\n        Args:\n            name (str, required): name\n            uuid_virtual_domain (str, required): uuid_virtual_domain\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/virtual_domains/{uuid_virtual_domain}', **kwargs)\n        return response\n\n    def users_virtual_domains_delete(self, name: str,\n        uuid_virtual_domain: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Virtual Domain\n\n        Args:\n            name (str, required): name\n            uuid_virtual_domain (str, required): uuid_virtual_domain\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/virtual_domains/{uuid_virtual_domain}', **kwargs)\n        return response\n\n    def users_customers(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Customers\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            company_name (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'company_name', 'status', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('company_name'), params.get('status'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_customers.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/users/{name}/customers',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def users_customers_create(self, name: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Customer\n\n        Args:\n            name (str, required): name\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/customers/{uuid_customer}', **kwargs)\n        return response\n\n    def users_customers_delete(self, name: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Customer\n\n        Args:\n            name (str, required): name\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/customers/{uuid_customer}', **kwargs)\n        return response\n\n    def users_starred_customers(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Starred Customers\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'status', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('status'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_starred_customers.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/users/{name}/starred_customers', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def users_starred_customers_create(self, name: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Mark Customer As Starred\n\n        Args:\n            name (str, required): name\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/starred_customers/{uuid_customer}', **kwargs)\n        return response\n\n    def users_starred_customers_delete(self, name: str, uuid_customer: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Mark Customer As Not Starred\n\n        Args:\n            name (str, required): name\n            uuid_customer (str, required): uuid_customer\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/starred_customers/{uuid_customer}', **kwargs)\n        return response\n\n    def users_widget_groups(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Widget Groups\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            group_name (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'group_name', 'active', 'skip',\n            'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('group_name'), params.get('active'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_widget_groups.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/users/{name}/widget_groups',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def users_widget_groups_create(self, name: str, uuid_widget_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Create Wg Relation\n\n        Args:\n            name (str, required): name\n            uuid_widget_group (str, required): uuid_widget_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/widget_groups/{uuid_widget_group}', **kwargs)\n        return response\n\n    def users_widget_groups_delete(self, name: str, uuid_widget_group: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Wg Relation\n\n        Args:\n            name (str, required): name\n            uuid_widget_group (str, required): uuid_widget_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/widget_groups/{uuid_widget_group}', **kwargs)\n        return response\n\n    def users_cost_views(self, name: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List User Cost Views\n\n        Args:\n            name (str, required): name\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_cost_views.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/users/{name}/cost_views',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def users_cost_views_create(self, name: str, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Create Association With Cost View\n\n        Args:\n            name (str, required): name\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/{name}/cost_views/{uuid}', **kwargs)\n        return response\n\n    def users_cost_views_delete(self, name: str, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Association With User\n\n        Args:\n            name (str, required): name\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users/{name}/cost_views/{uuid}', **kwargs)\n        return response\n\n    def users_customers_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Customers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_customer\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_customers_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/users/bulk/create/customers', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def users_customers_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Customers\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_customer\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/bulk/delete/customers', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def users_groups_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_groups_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/users/bulk/create/groups',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def users_groups_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_group\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/users/bulk/delete/groups',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def users_dashboards_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Dashboards\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_dashboard\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_dashboards_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/users/bulk/create/dashboards', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def users_dashboards_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Dashboards\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_dashboard\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/bulk/delete/dashboards', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def users_virtual_domains_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Virtual Domains\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_virtual_domains_create_bulk\n                .__name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/users/bulk/create/virtual_domains', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def users_virtual_domains_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Virtual Domains\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/users/bulk/delete/virtual_domains', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def users_send_email_template_create(self, template_name: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Send Email Template\n\n        Args:\n            template_name (str, required): template_name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            subject (string required): additional filter - payload\n            recipients (array required): additional filter - payload\n            ccn_recipients (array optional): additional filter - payload\n            attachments (array optional): additional filter - payload\n            template_parameters (object optional): additional filter - payload\n            domain (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['subject', 'recipients', 'ccn_recipients',\n            'attachments', 'template_parameters', 'domain']\n        payload.get('subject'), payload.get('recipients'), payload.get(\n            'ccn_recipients'), payload.get('attachments'), payload.get(\n            'template_parameters'), payload.get('domain')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_send_email_template_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/users/send_email_template/{template_name}', payload=payload,\n            **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.user","title":"<code>user(name, warm_start=False, kwargs=None)</code>","text":"<p>Read User</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def user(self, name: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read User\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/users/{name}', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users","title":"<code>users(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Users</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>email</code> <code>string optional</code> <p>additional filter - parameter</p> <code>phone</code> <code>string optional</code> <p>additional filter - parameter</p> <code>profile</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_acl_override</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Users\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        email (string optional): additional filter - parameter\n        phone (string optional): additional filter - parameter\n        profile (string optional): additional filter - parameter\n        uuid_acl_override (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'name', 'active',\n        'email', 'phone', 'profile', 'uuid_acl_override', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('name'\n        ), params.get('active'), params.get('email'), params.get('phone'\n        ), params.get('profile'), params.get('uuid_acl_override'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/users/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_cost_views","title":"<code>users_cost_views(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List User Cost Views</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_cost_views(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List User Cost Views\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_cost_views.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/users/{name}/cost_views',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_cost_views_create","title":"<code>users_cost_views_create(name, uuid, kwargs=None)</code>","text":"<p>Create Association With Cost View</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_cost_views_create(self, name: str, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Create Association With Cost View\n\n    Args:\n        name (str, required): name\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/cost_views/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_cost_views_delete","title":"<code>users_cost_views_delete(name, uuid, kwargs=None)</code>","text":"<p>Delete Association With User</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_cost_views_delete(self, name: str, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Association With User\n\n    Args:\n        name (str, required): name\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/cost_views/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_create","title":"<code>users_create(kwargs=None, **payload)</code>","text":"<p>Create User</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>password</code> <code>string required</code> <p>additional filter - payload</p> <code>phone</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>email</code> <code>string required</code> <p>additional filter - payload</p> <code>active</code> <code>boolean required</code> <p>additional filter - payload</p> <code>acl</code> <code>object required</code> <p>additional filter - payload</p> <code>uuid_acl_override</code> <code>string optional</code> <p>additional filter - payload</p> <code>verified_email</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create User\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        password (string required): additional filter - payload\n        phone (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        name (string required): additional filter - payload\n        email (string required): additional filter - payload\n        active (boolean required): additional filter - payload\n        acl (object required): additional filter - payload\n        uuid_acl_override (string optional): additional filter - payload\n        verified_email (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['password', 'phone', 'profile', 'name',\n        'email', 'active', 'acl', 'uuid_acl_override', 'verified_email']\n    payload.get('password'), payload.get('phone'), payload.get('profile'\n        ), payload.get('name'), payload.get('email'), payload.get('active'\n        ), payload.get('acl'), payload.get('uuid_acl_override'\n        ), payload.get('verified_email')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/users/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_create_uuid_customer","title":"<code>users_create_uuid_customer(uuid_customer, params=False, kwargs=None, **payload)</code>","text":"<p>Create User Tenant</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>send_mail</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>phone</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>email</code> <code>string required</code> <p>additional filter - payload</p> <code>active</code> <code>boolean required</code> <p>additional filter - payload</p> <code>acl</code> <code>object required</code> <p>additional filter - payload</p> <code>uuid_acl_override</code> <code>string optional</code> <p>additional filter - payload</p> <code>verified_email</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_create_uuid_customer(self, uuid_customer: str,\n    params: dict = False, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create User Tenant\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        send_mail (boolean optional): additional filter - parameter\n        phone (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        name (string required): additional filter - payload\n        email (string required): additional filter - payload\n        active (boolean required): additional filter - payload\n        acl (object required): additional filter - payload\n        uuid_acl_override (string optional): additional filter - payload\n        verified_email (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['phone', 'profile', 'name', 'email',\n        'active', 'acl', 'uuid_acl_override', 'verified_email']\n    payload.get('phone'), payload.get('profile'), payload.get('name'\n        ), payload.get('email'), payload.get('active'), payload.get('acl'\n        ), payload.get('uuid_acl_override'), payload.get('verified_email')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/users/{uuid_customer}',\n        params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_customers","title":"<code>users_customers(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Customers</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>company_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_customers(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Customers\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        company_name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'company_name', 'status', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('company_name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_customers.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/users/{name}/customers',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_customers_create","title":"<code>users_customers_create(name, uuid_customer, kwargs=None)</code>","text":"<p>Add Customer</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_customers_create(self, name: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Customer\n\n    Args:\n        name (str, required): name\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_customers_create_bulk","title":"<code>users_customers_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Customers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_customer\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_customers_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Customers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_customer\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_customers_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/users/bulk/create/customers', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_customers_delete","title":"<code>users_customers_delete(name, uuid_customer, kwargs=None)</code>","text":"<p>Remove Customer</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_customers_delete(self, name: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Customer\n\n    Args:\n        name (str, required): name\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_customers_delete_bulk","title":"<code>users_customers_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Customers</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_customer\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_customers_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Customers\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_customer\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/bulk/delete/customers', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_dashboards","title":"<code>users_dashboards(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>dashboard_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_dashboards(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dashboards\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        dashboard_name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'dashboard_name', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('dashboard_name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_dashboards.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/users/{name}/dashboards',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_dashboards_create","title":"<code>users_dashboards_create(name, uuid_dashboard, kwargs=None)</code>","text":"<p>Add Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_dashboard</code> <code>(str, required)</code> <p>uuid_dashboard</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_dashboards_create(self, name: str, uuid_dashboard: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Dashboard\n\n    Args:\n        name (str, required): name\n        uuid_dashboard (str, required): uuid_dashboard\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/dashboards/{uuid_dashboard}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_dashboards_create_bulk","title":"<code>users_dashboards_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_dashboard\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_dashboards_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Dashboards\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_dashboard\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_dashboards_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/users/bulk/create/dashboards', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_dashboards_delete","title":"<code>users_dashboards_delete(name, uuid_dashboard, kwargs=None)</code>","text":"<p>Remove Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_dashboard</code> <code>(str, required)</code> <p>uuid_dashboard</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_dashboards_delete(self, name: str, uuid_dashboard: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Dashboard\n\n    Args:\n        name (str, required): name\n        uuid_dashboard (str, required): uuid_dashboard\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/dashboards/{uuid_dashboard}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_dashboards_delete_bulk","title":"<code>users_dashboards_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_dashboard\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_dashboards_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Dashboards\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_dashboard\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/bulk/delete/dashboards', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_delete","title":"<code>users_delete(name, kwargs=None)</code>","text":"<p>Delete User</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_delete(self, name: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete User\n\n    Args:\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_groups","title":"<code>users_groups(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_groups(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'group_name', 'status', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('group_name'), params.get('status'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/users/{name}/groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_groups_create","title":"<code>users_groups_create(name, uuid_group, kwargs=None)</code>","text":"<p>Add Group</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_groups_create(self, name: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Group\n\n    Args:\n        name (str, required): name\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_groups_create_bulk","title":"<code>users_groups_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_groups_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_groups_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/users/bulk/create/groups',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_groups_delete","title":"<code>users_groups_delete(name, uuid_group, kwargs=None)</code>","text":"<p>Remove Group</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_group</code> <code>(str, required)</code> <p>uuid_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_groups_delete(self, name: str, uuid_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Group\n\n    Args:\n        name (str, required): name\n        uuid_group (str, required): uuid_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/groups/{uuid_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_groups_delete_bulk","title":"<code>users_groups_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_group\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_groups_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_group\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/users/bulk/delete/groups',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_password_reset_create","title":"<code>users_password_reset_create(params=False, kwargs=None, **payload)</code>","text":"<p>Send Mail Password Reset</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>username</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_password_reset_create(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Send Mail Password Reset\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        app_id (string optional): additional filter - parameter\n        username (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['username']\n    payload.get('username')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_password_reset_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/users/password_reset',\n        params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_password_reset_put","title":"<code>users_password_reset_put(params=False, kwargs=None, **payload)</code>","text":"<p>Reset Password</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>verification_code</code> <code>string required</code> <p>additional filter - payload</p> <code>new_password</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_password_reset_put(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Reset Password\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        app_id (string optional): additional filter - parameter\n        verification_code (string required): additional filter - payload\n        new_password (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['verification_code', 'new_password']\n    payload.get('verification_code'), payload.get('new_password')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_password_reset_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/users/password_reset',\n        params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_put","title":"<code>users_put(name, kwargs=None, **payload)</code>","text":"<p>Update User</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>password</code> <code>string optional</code> <p>additional filter - payload</p> <code>phone</code> <code>string optional</code> <p>additional filter - payload</p> <code>profile</code> <code>string optional</code> <p>additional filter - payload</p> <code>email</code> <code>string optional</code> <p>additional filter - payload</p> <code>stage</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>acl</code> <code>object optional</code> <p>additional filter - payload</p> <code>uuid_acl_override</code> <code>string optional</code> <p>additional filter - payload</p> <code>verified_email</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_put(self, name: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update User\n\n    Args:\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        password (string optional): additional filter - payload\n        phone (string optional): additional filter - payload\n        profile (string optional): additional filter - payload\n        email (string optional): additional filter - payload\n        stage (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n        acl (object optional): additional filter - payload\n        uuid_acl_override (string optional): additional filter - payload\n        verified_email (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['password', 'phone', 'profile', 'email',\n        'stage', 'active', 'acl', 'uuid_acl_override', 'verified_email']\n    payload.get('password'), payload.get('phone'), payload.get('profile'\n        ), payload.get('email'), payload.get('stage'), payload.get('active'\n        ), payload.get('acl'), payload.get('uuid_acl_override'\n        ), payload.get('verified_email')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/users/{name}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_register_create","title":"<code>users_register_create(params=False, kwargs=None, **payload)</code>","text":"<p>Registration Form</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>additional parameters for the API.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>app_id</code> <code>string optional</code> <p>additional filter - parameter</p> <code>password</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>email</code> <code>string required</code> <p>additional filter - payload</p> <code>phone</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_register_create(self, params: dict = False,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Registration Form\n\n    Args:\n        params (dict, optional): additional parameters for the API.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        app_id (string optional): additional filter - parameter\n        password (string required): additional filter - payload\n        name (string required): additional filter - payload\n        email (string required): additional filter - payload\n        phone (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['password', 'name', 'email', 'phone']\n    payload.get('password'), payload.get('name'), payload.get('email'\n        ), payload.get('phone')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_register_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/users/register', params=\n        params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_send_email_template_create","title":"<code>users_send_email_template_create(template_name, kwargs=None, **payload)</code>","text":"<p>Send Email Template</p> <p>Parameters:</p> Name Type Description Default <code>template_name</code> <code>(str, required)</code> <p>template_name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>subject</code> <code>string required</code> <p>additional filter - payload</p> <code>recipients</code> <code>array required</code> <p>additional filter - payload</p> <code>ccn_recipients</code> <code>array optional</code> <p>additional filter - payload</p> <code>attachments</code> <code>array optional</code> <p>additional filter - payload</p> <code>template_parameters</code> <code>object optional</code> <p>additional filter - payload</p> <code>domain</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_send_email_template_create(self, template_name: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Send Email Template\n\n    Args:\n        template_name (str, required): template_name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        subject (string required): additional filter - payload\n        recipients (array required): additional filter - payload\n        ccn_recipients (array optional): additional filter - payload\n        attachments (array optional): additional filter - payload\n        template_parameters (object optional): additional filter - payload\n        domain (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['subject', 'recipients', 'ccn_recipients',\n        'attachments', 'template_parameters', 'domain']\n    payload.get('subject'), payload.get('recipients'), payload.get(\n        'ccn_recipients'), payload.get('attachments'), payload.get(\n        'template_parameters'), payload.get('domain')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_send_email_template_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/users/send_email_template/{template_name}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_starred_customers","title":"<code>users_starred_customers(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Starred Customers</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_starred_customers(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Starred Customers\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'status', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('status'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_starred_customers.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/users/{name}/starred_customers', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_starred_customers_create","title":"<code>users_starred_customers_create(name, uuid_customer, kwargs=None)</code>","text":"<p>Mark Customer As Starred</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_starred_customers_create(self, name: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Mark Customer As Starred\n\n    Args:\n        name (str, required): name\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/starred_customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_starred_customers_delete","title":"<code>users_starred_customers_delete(name, uuid_customer, kwargs=None)</code>","text":"<p>Mark Customer As Not Starred</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_customer</code> <code>(str, required)</code> <p>uuid_customer</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_starred_customers_delete(self, name: str, uuid_customer: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Mark Customer As Not Starred\n\n    Args:\n        name (str, required): name\n        uuid_customer (str, required): uuid_customer\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/starred_customers/{uuid_customer}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_verify_email","title":"<code>users_verify_email(warm_start=False, kwargs=None, **params)</code>","text":"<p>Verify Me</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>verification_code</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_verify_email(self, warm_start: bool = False,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Verify Me\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        verification_code (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    kwargs, params = handling_single_page_methods(kwargs=kwargs.copy(),\n        params=params.copy())\n    official_params_list = ['verification_code']\n    params.get('verification_code')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_verify_email.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/users/verify_email',\n        warm_start=warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_virtual_domains","title":"<code>users_virtual_domains(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>domain_code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_virtual_domains(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Virtual Domains\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        domain_code (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'domain_code', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('domain_code'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_virtual_domains.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/users/{name}/virtual_domains', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_virtual_domains_create","title":"<code>users_virtual_domains_create(name, uuid_virtual_domain, kwargs=None)</code>","text":"<p>Add Virtual Domain</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_virtual_domain</code> <code>(str, required)</code> <p>uuid_virtual_domain</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_virtual_domains_create(self, name: str,\n    uuid_virtual_domain: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Add Virtual Domain\n\n    Args:\n        name (str, required): name\n        uuid_virtual_domain (str, required): uuid_virtual_domain\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/virtual_domains/{uuid_virtual_domain}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_virtual_domains_create_bulk","title":"<code>users_virtual_domains_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_virtual_domain\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_virtual_domains_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Virtual Domains\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_virtual_domains_create_bulk\n            .__name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/users/bulk/create/virtual_domains', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_virtual_domains_delete","title":"<code>users_virtual_domains_delete(name, uuid_virtual_domain, kwargs=None)</code>","text":"<p>Remove Virtual Domain</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_virtual_domain</code> <code>(str, required)</code> <p>uuid_virtual_domain</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_virtual_domains_delete(self, name: str,\n    uuid_virtual_domain: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Virtual Domain\n\n    Args:\n        name (str, required): name\n        uuid_virtual_domain (str, required): uuid_virtual_domain\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/virtual_domains/{uuid_virtual_domain}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_virtual_domains_delete_bulk","title":"<code>users_virtual_domains_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_virtual_domain\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_virtual_domains_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Virtual Domains\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/bulk/delete/virtual_domains', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_widget_groups","title":"<code>users_widget_groups(name, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Widget Groups</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>group_name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_widget_groups(self, name: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Widget Groups\n\n    Args:\n        name (str, required): name\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        group_name (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'group_name', 'active', 'skip',\n        'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('group_name'), params.get('active'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_widget_groups.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/users/{name}/widget_groups',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_widget_groups_create","title":"<code>users_widget_groups_create(name, uuid_widget_group, kwargs=None)</code>","text":"<p>Create Wg Relation</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_widget_group</code> <code>(str, required)</code> <p>uuid_widget_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_widget_groups_create(self, name: str, uuid_widget_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Create Wg Relation\n\n    Args:\n        name (str, required): name\n        uuid_widget_group (str, required): uuid_widget_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/users/{name}/widget_groups/{uuid_widget_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users/#hive.cookbook.users.Users.users_widget_groups_delete","title":"<code>users_widget_groups_delete(name, uuid_widget_group, kwargs=None)</code>","text":"<p>Delete Wg Relation</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>(str, required)</code> <p>name</p> required <code>uuid_widget_group</code> <code>(str, required)</code> <p>uuid_widget_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users.py</code> <pre><code>def users_widget_groups_delete(self, name: str, uuid_widget_group: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Wg Relation\n\n    Args:\n        name (str, required): name\n        uuid_widget_group (str, required): uuid_widget_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users/{name}/widget_groups/{uuid_widget_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users_notifications/","title":"Hive.cookbook.users notifications","text":""},{"location":"hive.cookbook.users_notifications/#hive.cookbook.users_notifications.UsersNotifications","title":"<code>UsersNotifications</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata users_notifications APIs</p> Source code in <code>hive/cookbook/users_notifications.py</code> <pre><code>class UsersNotifications(ApiManager):\n    \"\"\"Class that handles all the XAutomata users_notifications APIs\"\"\"\n\n    def users_notifications(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Notifications\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            username (string optional): additional filter - parameter\n            title (string optional): additional filter - parameter\n            body (string optional): additional filter - parameter\n            read (boolean optional): additional filter - parameter\n            sent (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'username',\n            'title', 'body', 'read', 'sent', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('username'\n            ), params.get('title'), params.get('body'), params.get('read'\n            ), params.get('sent'), params.get('skip'), params.get('limit'\n            ), params.get('like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_notifications.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/users_notifications/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def users_notifications_create(self, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Create Notification\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            username (string required): additional filter - payload\n            title (string required): additional filter - payload\n            body (array object optional): additional filter - payload\n            read (boolean optional): additional filter - payload\n            sent (boolean optional): additional filter - payload\n            timestamp (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['username', 'title', 'body', 'read',\n            'sent', 'timestamp']\n        payload.get('username'), payload.get('title'), payload.get('body'\n            ), payload.get('read'), payload.get('sent'), payload.get(\n            'timestamp')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_notifications_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=f'/users_notifications/',\n            payload=payload, **kwargs)\n        return response\n\n    def users_notifications_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Notification\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            title (string optional): additional filter - payload\n            body (array object optional): additional filter - payload\n            read (boolean optional): additional filter - payload\n            sent (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['title', 'body', 'read', 'sent']\n        payload.get('title'), payload.get('body'), payload.get('read'\n            ), payload.get('sent')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_notifications_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/users_notifications/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def users_notifications_delete(self, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Delete Notifcation\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/users_notifications/{uuid}', **kwargs)\n        return response\n\n    def users_notifications_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Create Bulk Notification\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"title\": \"string\", required\n            \"body\": \"array object\", optional\n            \"read\": \"boolean\", optional\n            \"sent\": \"boolean\", optional\n            \"timestamp\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.users_notifications_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/users_notifications/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.users_notifications/#hive.cookbook.users_notifications.UsersNotifications.users_notifications","title":"<code>users_notifications(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Notifications</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>username</code> <code>string optional</code> <p>additional filter - parameter</p> <code>title</code> <code>string optional</code> <p>additional filter - parameter</p> <code>body</code> <code>string optional</code> <p>additional filter - parameter</p> <code>read</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>sent</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users_notifications.py</code> <pre><code>def users_notifications(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Notifications\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        username (string optional): additional filter - parameter\n        title (string optional): additional filter - parameter\n        body (string optional): additional filter - parameter\n        read (boolean optional): additional filter - parameter\n        sent (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'username',\n        'title', 'body', 'read', 'sent', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('username'\n        ), params.get('title'), params.get('body'), params.get('read'\n        ), params.get('sent'), params.get('skip'), params.get('limit'\n        ), params.get('like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_notifications.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/users_notifications/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users_notifications/#hive.cookbook.users_notifications.UsersNotifications.users_notifications_create","title":"<code>users_notifications_create(kwargs=None, **payload)</code>","text":"<p>Create Notification</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>username</code> <code>string required</code> <p>additional filter - payload</p> <code>title</code> <code>string required</code> <p>additional filter - payload</p> <code>body</code> <code>array object optional</code> <p>additional filter - payload</p> <code>read</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>sent</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>timestamp</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users_notifications.py</code> <pre><code>def users_notifications_create(self, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Create Notification\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        username (string required): additional filter - payload\n        title (string required): additional filter - payload\n        body (array object optional): additional filter - payload\n        read (boolean optional): additional filter - payload\n        sent (boolean optional): additional filter - payload\n        timestamp (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['username', 'title', 'body', 'read',\n        'sent', 'timestamp']\n    payload.get('username'), payload.get('title'), payload.get('body'\n        ), payload.get('read'), payload.get('sent'), payload.get(\n        'timestamp')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_notifications_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=f'/users_notifications/',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users_notifications/#hive.cookbook.users_notifications.UsersNotifications.users_notifications_create_bulk","title":"<code>users_notifications_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Create Bulk Notification</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"title\": \"string\", required     \"body\": \"array object\", optional     \"read\": \"boolean\", optional     \"sent\": \"boolean\", optional     \"timestamp\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users_notifications.py</code> <pre><code>def users_notifications_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Create Bulk Notification\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"title\": \"string\", required\n        \"body\": \"array object\", optional\n        \"read\": \"boolean\", optional\n        \"sent\": \"boolean\", optional\n        \"timestamp\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_notifications_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/users_notifications/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users_notifications/#hive.cookbook.users_notifications.UsersNotifications.users_notifications_delete","title":"<code>users_notifications_delete(uuid, kwargs=None)</code>","text":"<p>Delete Notifcation</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/users_notifications.py</code> <pre><code>def users_notifications_delete(self, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Delete Notifcation\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/users_notifications/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.users_notifications/#hive.cookbook.users_notifications.UsersNotifications.users_notifications_put","title":"<code>users_notifications_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Notification</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>title</code> <code>string optional</code> <p>additional filter - payload</p> <code>body</code> <code>array object optional</code> <p>additional filter - payload</p> <code>read</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>sent</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/users_notifications.py</code> <pre><code>def users_notifications_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Notification\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        title (string optional): additional filter - payload\n        body (array object optional): additional filter - payload\n        read (boolean optional): additional filter - payload\n        sent (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['title', 'body', 'read', 'sent']\n    payload.get('title'), payload.get('body'), payload.get('read'\n        ), payload.get('sent')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.users_notifications_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/users_notifications/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/","title":"Hive.cookbook.virtual domains","text":""},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains","title":"<code>VirtualDomains</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata virtual_domains APIs</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>class VirtualDomains(ApiManager):\n    \"\"\"Class that handles all the XAutomata virtual_domains APIs\"\"\"\n\n    def virtual_domains(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Virtual Domains\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            status (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code',\n            'description', 'status', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('description'), params.get('status'), params.get(\n            'skip'), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/virtual_domains/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def virtual_domains_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Virtual Domain\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'status']\n        payload.get('code'), payload.get('description'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/virtual_domains/', payload=\n            payload, **kwargs)\n        return response\n\n    def virtual_domain(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Virtual Domain\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/virtual_domains/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def virtual_domains_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Virtual Domain\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            status (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'description', 'status']\n        payload.get('code'), payload.get('description'), payload.get('status')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/virtual_domains/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def virtual_domains_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Virtual Domain\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/virtual_domains/{uuid}',\n            **kwargs)\n        return response\n\n    def virtual_domains_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_groups.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/virtual_domains/{uuid}/groups', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def virtual_domains_probes(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Probes\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n        params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_probes.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/virtual_domains/{uuid}/probes', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def virtual_domains_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'active', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('active'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_users.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/virtual_domains/{uuid}/users', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def virtual_domains_users_create(self, uuid: str, name: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/virtual_domains/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def virtual_domains_users_delete(self, uuid: str, name: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/virtual_domains/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def virtual_domains_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Virtual Domains\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/virtual_domains/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def virtual_domains_read_by_bulk(self, payload: list,\n        warm_start: bool = False, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Read By Code\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"code\": \"string\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/virtual_domains/bulk/read_by/', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, payload=payload, **\n            kwargs)\n        return response\n\n    def virtual_domains_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Create Virtual Domains\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"code\": \"string\", required\n            \"description\": \"string\", optional\n            \"status\": \"string\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/virtual_domains/bulk/create/', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def virtual_domains_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Delete Virtual Domains\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/virtual_domains/bulk/delete/', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n\n    def virtual_domains_users_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.virtual_domains_users_create_bulk\n                .__name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/virtual_domains/bulk/create/users', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def virtual_domains_users_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Users\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n           {\n            \"username\": \"string\", required\n            \"uuid_virtual_domain\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/virtual_domains/bulk/delete/users', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domain","title":"<code>virtual_domain(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Virtual Domain</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domain(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Virtual Domain\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/virtual_domains/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains","title":"<code>virtual_domains(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>status</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Virtual Domains\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        status (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code',\n        'description', 'status', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('description'), params.get('status'), params.get(\n        'skip'), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/virtual_domains/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_bulk","title":"<code>virtual_domains_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Virtual Domains\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/virtual_domains/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_create","title":"<code>virtual_domains_create(kwargs=None, **payload)</code>","text":"<p>Create Virtual Domain</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Virtual Domain\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'status']\n    payload.get('code'), payload.get('description'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/virtual_domains/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_create_bulk","title":"<code>virtual_domains_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"code\": \"string\", required     \"description\": \"string\", optional     \"status\": \"string\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Create Virtual Domains\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"code\": \"string\", required\n        \"description\": \"string\", optional\n        \"status\": \"string\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/virtual_domains/bulk/create/', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_delete","title":"<code>virtual_domains_delete(uuid, kwargs=None)</code>","text":"<p>Delete Virtual Domain</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Virtual Domain\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/virtual_domains/{uuid}',\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_delete_bulk","title":"<code>virtual_domains_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Virtual Domains</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Delete Virtual Domains\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/virtual_domains/bulk/delete/', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_groups","title":"<code>virtual_domains_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_groups.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/virtual_domains/{uuid}/groups', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_probes","title":"<code>virtual_domains_probes(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Probes</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_probes(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Probes\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['skip', 'limit', 'like', 'join', 'count']\n    params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_probes.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/virtual_domains/{uuid}/probes', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_put","title":"<code>virtual_domains_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Virtual Domain</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>status</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Virtual Domain\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        status (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'description', 'status']\n    payload.get('code'), payload.get('description'), payload.get('status')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/virtual_domains/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_read_by_bulk","title":"<code>virtual_domains_read_by_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Read By Code</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"code\": \"string\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_read_by_bulk(self, payload: list,\n    warm_start: bool = False, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Read By Code\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"code\": \"string\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/virtual_domains/bulk/read_by/', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, payload=payload, **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_users","title":"<code>virtual_domains_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'active', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('active'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_users.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/virtual_domains/{uuid}/users', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_users_create","title":"<code>virtual_domains_users_create(uuid, name, kwargs=None)</code>","text":"<p>Add User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_users_create(self, uuid: str, name: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/virtual_domains/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_users_create_bulk","title":"<code>virtual_domains_users_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_virtual_domain\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_users_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.virtual_domains_users_create_bulk\n            .__name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/virtual_domains/bulk/create/users', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_users_delete","title":"<code>virtual_domains_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Remove User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_users_delete(self, uuid: str, name: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/virtual_domains/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.virtual_domains/#hive.cookbook.virtual_domains.VirtualDomains.virtual_domains_users_delete_bulk","title":"<code>virtual_domains_users_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Users</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[    {     \"username\": \"string\", required     \"uuid_virtual_domain\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/virtual_domains.py</code> <pre><code>def virtual_domains_users_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Users\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n       {\n        \"username\": \"string\", required\n        \"uuid_virtual_domain\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/virtual_domains/bulk/delete/users', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.webhooks/","title":"Hive.cookbook.webhooks","text":""},{"location":"hive.cookbook.webhooks/#hive.cookbook.webhooks.Webhooks","title":"<code>Webhooks</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata webhooks APIs</p> Source code in <code>hive/cookbook/webhooks.py</code> <pre><code>class Webhooks(ApiManager):\n    \"\"\"Class that handles all the XAutomata webhooks APIs\"\"\"\n\n    def webhooks(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Webhooks\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            webhook_type (string optional): additional filter - parameter\n            uuid_probe (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'webhook_type',\n            'uuid_probe', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get(\n            'webhook_type'), params.get('uuid_probe'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.webhooks.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/webhooks/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def webhooks_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Webhook\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            data_profile (array object optional): additional filter - payload\n            webhook_type (string required): additional filter - payload\n            auth_token (string required): additional filter - payload\n            uuid_probe (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['data_profile', 'webhook_type',\n            'auth_token', 'uuid_probe']\n        payload.get('data_profile'), payload.get('webhook_type'), payload.get(\n            'auth_token'), payload.get('uuid_probe')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.webhooks_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/webhooks/', payload=payload,\n            **kwargs)\n        return response\n\n    def webhook(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Webhook\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/webhooks/{uuid}', warm_start\n            =warm_start, **kwargs)\n        return response\n\n    def webhooks_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Webhook\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            data_profile (array object optional): additional filter - payload\n            webhook_type (string optional): additional filter - payload\n            auth_token (string optional): additional filter - payload\n            uuid_probe (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['data_profile', 'webhook_type',\n            'auth_token', 'uuid_probe']\n        payload.get('data_profile'), payload.get('webhook_type'), payload.get(\n            'auth_token'), payload.get('uuid_probe')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.webhooks_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/webhooks/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def webhooks_create_webhook_type(self, payload: list, webhook_type: str,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Post Webhook\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            webhook_type (str, required): webhook_type\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            xa-auth-token (string required): additional filter - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['xa-auth-token']\n        params.get('xa-auth-token')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.webhooks_create.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/webhooks/{webhook_type}',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.webhooks/#hive.cookbook.webhooks.Webhooks.webhook","title":"<code>webhook(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Webhook</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/webhooks.py</code> <pre><code>def webhook(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Webhook\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/webhooks/{uuid}', warm_start\n        =warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.webhooks/#hive.cookbook.webhooks.Webhooks.webhooks","title":"<code>webhooks(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Webhooks</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>webhook_type</code> <code>string optional</code> <p>additional filter - parameter</p> <code>uuid_probe</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/webhooks.py</code> <pre><code>def webhooks(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Webhooks\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        webhook_type (string optional): additional filter - parameter\n        uuid_probe (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'webhook_type',\n        'uuid_probe', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get(\n        'webhook_type'), params.get('uuid_probe'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.webhooks.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/webhooks/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.webhooks/#hive.cookbook.webhooks.Webhooks.webhooks_create","title":"<code>webhooks_create(kwargs=None, **payload)</code>","text":"<p>Create Webhook</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>webhook_type</code> <code>string required</code> <p>additional filter - payload</p> <code>auth_token</code> <code>string required</code> <p>additional filter - payload</p> <code>uuid_probe</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/webhooks.py</code> <pre><code>def webhooks_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Webhook\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        data_profile (array object optional): additional filter - payload\n        webhook_type (string required): additional filter - payload\n        auth_token (string required): additional filter - payload\n        uuid_probe (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['data_profile', 'webhook_type',\n        'auth_token', 'uuid_probe']\n    payload.get('data_profile'), payload.get('webhook_type'), payload.get(\n        'auth_token'), payload.get('uuid_probe')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.webhooks_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/webhooks/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.webhooks/#hive.cookbook.webhooks.Webhooks.webhooks_create_webhook_type","title":"<code>webhooks_create_webhook_type(payload, webhook_type, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Post Webhook</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>webhook_type</code> <code>(str, required)</code> <p>webhook_type</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>xa-auth-token</code> <code>string required</code> <p>additional filter - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/webhooks.py</code> <pre><code>def webhooks_create_webhook_type(self, payload: list, webhook_type: str,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Post Webhook\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        webhook_type (str, required): webhook_type\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        xa-auth-token (string required): additional filter - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['xa-auth-token']\n    params.get('xa-auth-token')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.webhooks_create.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/webhooks/{webhook_type}',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.webhooks/#hive.cookbook.webhooks.Webhooks.webhooks_put","title":"<code>webhooks_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Webhook</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>data_profile</code> <code>array object optional</code> <p>additional filter - payload</p> <code>webhook_type</code> <code>string optional</code> <p>additional filter - payload</p> <code>auth_token</code> <code>string optional</code> <p>additional filter - payload</p> <code>uuid_probe</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/webhooks.py</code> <pre><code>def webhooks_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Webhook\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        data_profile (array object optional): additional filter - payload\n        webhook_type (string optional): additional filter - payload\n        auth_token (string optional): additional filter - payload\n        uuid_probe (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['data_profile', 'webhook_type',\n        'auth_token', 'uuid_probe']\n    payload.get('data_profile'), payload.get('webhook_type'), payload.get(\n        'auth_token'), payload.get('uuid_probe')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.webhooks_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/webhooks/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/","title":"Hive.cookbook.widget groups","text":""},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups","title":"<code>WidgetGroups</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata widget_groups APIs</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>class WidgetGroups(ApiManager):\n    \"\"\"Class that handles all the XAutomata widget_groups APIs\"\"\"\n\n    def widget_groups(self, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Admin Widget Groups\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'name', 'code',\n            'description', 'active', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('name'\n            ), params.get('code'), params.get('description'), params.get(\n            'active'), params.get('skip'), params.get('limit'), params.get(\n            'like'), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widget_groups.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/widget_groups/', single_page\n            =single_page, page_size=page_size, warm_start=warm_start,\n            params=params, **kwargs)\n        return response\n\n    def widget_groups_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Widget Group\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n            code (string required): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'description', 'active', 'code']\n        payload.get('name'), payload.get('description'), payload.get('active'\n            ), payload.get('code')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widget_groups_create.__name__,\n                payload, official_payload_list)\n        response = self.execute('POST', path=f'/widget_groups/', payload=\n            payload, **kwargs)\n        return response\n\n    def widget_group(self, uuid: str, warm_start: bool = False,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Read Admin Widget Group\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/widget_groups/{uuid}',\n            warm_start=warm_start, **kwargs)\n        return response\n\n    def widget_groups_put(self, uuid: str, kwargs: dict = None, **payload\n        ) -&gt; list:\n        \"\"\"Update Widget Group\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n            code (string optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['name', 'description', 'active', 'code']\n        payload.get('name'), payload.get('description'), payload.get('active'\n            ), payload.get('code')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widget_groups_put.__name__,\n                payload, official_payload_list)\n        response = self.execute('PUT', path=f'/widget_groups/{uuid}',\n            payload=payload, **kwargs)\n        return response\n\n    def widget_groups_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Widget Group\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/widget_groups/{uuid}', **\n            kwargs)\n        return response\n\n    def widget_groups_widgets(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Widgets\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widget_groups_widgets.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/widget_groups/{uuid}/widgets', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def widget_groups_widgets_create(self, uuid: str, uuid_widget: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add Widget\n\n        Args:\n            uuid (str, required): uuid\n            uuid_widget (str, required): uuid_widget\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/widget_groups/{uuid}/widgets/{uuid_widget}', **kwargs)\n        return response\n\n    def widget_groups_widgets_delete(self, uuid: str, uuid_widget: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove Object\n\n        Args:\n            uuid (str, required): uuid\n            uuid_widget (str, required): uuid_widget\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/widget_groups/{uuid}/widgets/{uuid_widget}', **kwargs)\n        return response\n\n    def widget_groups_users(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Users\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'active', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('active'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widget_groups_users.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/widget_groups/{uuid}/users',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def widget_groups_users_create(self, uuid: str, name: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Add User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/widget_groups/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def widget_groups_users_delete(self, uuid: str, name: str,\n        kwargs: dict = None) -&gt; list:\n        \"\"\"Remove User\n\n        Args:\n            uuid (str, required): uuid\n            name (str, required): name\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/widget_groups/{uuid}/users/{name}', **kwargs)\n        return response\n\n    def widget_groups_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read Widget Groups\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widget_groups_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/widget_groups/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_group","title":"<code>widget_group(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Admin Widget Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_group(self, uuid: str, warm_start: bool = False,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Read Admin Widget Group\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/widget_groups/{uuid}',\n        warm_start=warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups","title":"<code>widget_groups(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Admin Widget Groups</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups(self, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Admin Widget Groups\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'name', 'code',\n        'description', 'active', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('name'\n        ), params.get('code'), params.get('description'), params.get(\n        'active'), params.get('skip'), params.get('limit'), params.get(\n        'like'), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widget_groups.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/widget_groups/', single_page\n        =single_page, page_size=page_size, warm_start=warm_start,\n        params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_bulk","title":"<code>widget_groups_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read Widget Groups</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read Widget Groups\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widget_groups_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/widget_groups/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_create","title":"<code>widget_groups_create(kwargs=None, **payload)</code>","text":"<p>Create Widget Group</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>code</code> <code>string required</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Widget Group\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n        code (string required): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'description', 'active', 'code']\n    payload.get('name'), payload.get('description'), payload.get('active'\n        ), payload.get('code')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widget_groups_create.__name__,\n            payload, official_payload_list)\n    response = self.execute('POST', path=f'/widget_groups/', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_delete","title":"<code>widget_groups_delete(uuid, kwargs=None)</code>","text":"<p>Delete Widget Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Widget Group\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/widget_groups/{uuid}', **\n        kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_put","title":"<code>widget_groups_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Widget Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_put(self, uuid: str, kwargs: dict = None, **payload\n    ) -&gt; list:\n    \"\"\"Update Widget Group\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n        code (string optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['name', 'description', 'active', 'code']\n    payload.get('name'), payload.get('description'), payload.get('active'\n        ), payload.get('code')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widget_groups_put.__name__,\n            payload, official_payload_list)\n    response = self.execute('PUT', path=f'/widget_groups/{uuid}',\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_users","title":"<code>widget_groups_users(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Users</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_users(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Users\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'active', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('active'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widget_groups_users.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/widget_groups/{uuid}/users',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_users_create","title":"<code>widget_groups_users_create(uuid, name, kwargs=None)</code>","text":"<p>Add User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_users_create(self, uuid: str, name: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/widget_groups/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_users_delete","title":"<code>widget_groups_users_delete(uuid, name, kwargs=None)</code>","text":"<p>Remove User</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>name</code> <code>(str, required)</code> <p>name</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_users_delete(self, uuid: str, name: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove User\n\n    Args:\n        uuid (str, required): uuid\n        name (str, required): name\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/widget_groups/{uuid}/users/{name}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_widgets","title":"<code>widget_groups_widgets(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Widgets</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_widgets(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Widgets\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widget_groups_widgets.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/widget_groups/{uuid}/widgets', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_widgets_create","title":"<code>widget_groups_widgets_create(uuid, uuid_widget, kwargs=None)</code>","text":"<p>Add Widget</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_widget</code> <code>(str, required)</code> <p>uuid_widget</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_widgets_create(self, uuid: str, uuid_widget: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Add Widget\n\n    Args:\n        uuid (str, required): uuid\n        uuid_widget (str, required): uuid_widget\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/widget_groups/{uuid}/widgets/{uuid_widget}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widget_groups/#hive.cookbook.widget_groups.WidgetGroups.widget_groups_widgets_delete","title":"<code>widget_groups_widgets_delete(uuid, uuid_widget, kwargs=None)</code>","text":"<p>Remove Object</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_widget</code> <code>(str, required)</code> <p>uuid_widget</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widget_groups.py</code> <pre><code>def widget_groups_widgets_delete(self, uuid: str, uuid_widget: str,\n    kwargs: dict = None) -&gt; list:\n    \"\"\"Remove Object\n\n    Args:\n        uuid (str, required): uuid\n        uuid_widget (str, required): uuid_widget\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/widget_groups/{uuid}/widgets/{uuid_widget}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/","title":"Hive.cookbook.widgets","text":""},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets","title":"<code>Widgets</code>","text":"<p>               Bases: <code>ApiManager</code></p> <p>Class that handles all the XAutomata widgets APIs</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>class Widgets(ApiManager):\n    \"\"\"Class that handles all the XAutomata widgets APIs\"\"\"\n\n    def widgets(self, warm_start: bool = False, single_page: bool = False,\n        page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Read Widgets\n\n        Args:\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n            null_fields (string optional): additional filter - parameter\n            code (string optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            description (string optional): additional filter - parameter\n            scope (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['sort_by', 'null_fields', 'code', 'name',\n            'description', 'scope', 'active', 'skip', 'limit', 'like',\n            'join', 'count']\n        params.get('sort_by'), params.get('null_fields'), params.get('code'\n            ), params.get('name'), params.get('description'), params.get(\n            'scope'), params.get('active'), params.get('skip'), params.get(\n            'limit'), params.get('like'), params.get('join'), params.get(\n            'count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets.__name__, params,\n                official_params_list)\n        response = self.execute('GET', path=f'/widgets/', single_page=\n            single_page, page_size=page_size, warm_start=warm_start, params\n            =params, **kwargs)\n        return response\n\n    def widgets_create(self, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Create Widget\n\n        Args:\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string required): additional filter - payload\n            name (string required): additional filter - payload\n            description (string optional): additional filter - payload\n            scope (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'name', 'description', 'scope',\n            'active']\n        payload.get('code'), payload.get('name'), payload.get('description'\n            ), payload.get('scope'), payload.get('active')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_create.__name__, payload,\n                official_payload_list)\n        response = self.execute('POST', path=f'/widgets/', payload=payload,\n            **kwargs)\n        return response\n\n    def widget(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Read Widget\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('GET', path=f'/widgets/{uuid}', warm_start=\n            warm_start, **kwargs)\n        return response\n\n    def widgets_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Update Widget\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            code (string optional): additional filter - payload\n            name (string optional): additional filter - payload\n            description (string optional): additional filter - payload\n            scope (string optional): additional filter - payload\n            active (boolean optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['code', 'name', 'description', 'scope',\n            'active']\n        payload.get('code'), payload.get('name'), payload.get('description'\n            ), payload.get('scope'), payload.get('active')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_put.__name__, payload,\n                official_payload_list)\n        response = self.execute('PUT', path=f'/widgets/{uuid}', payload=\n            payload, **kwargs)\n        return response\n\n    def widgets_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Delete Widget\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=f'/widgets/{uuid}', **kwargs)\n        return response\n\n    def widgets_dashboards(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Dashboards\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            index (integer optional): additional filter - parameter\n            width (integer optional): additional filter - parameter\n            height (integer optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'index', 'width',\n            'height', 'skip', 'limit', 'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('index'\n            ), params.get('width'), params.get('height'), params.get('skip'\n            ), params.get('limit'), params.get('like'), params.get('join'\n            ), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_dashboards.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=f'/widgets/{uuid}/dashboards',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, **kwargs)\n        return response\n\n    def widgets_dashboards_create(self, uuid: str, uuid_dashboard: str,\n        kwargs: dict = None, **payload) -&gt; list:\n        \"\"\"Add Dashboard\n\n        Args:\n            uuid (str, required): uuid\n            uuid_dashboard (str, required): uuid_dashboard\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            index (integer optional): additional filter - payload\n            width (integer optional): additional filter - payload\n            height (integer optional): additional filter - payload\n            grid_x (integer optional): additional filter - payload\n            grid_y (integer optional): additional filter - payload\n            settings (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['index', 'width', 'height', 'grid_x',\n            'grid_y', 'settings']\n        payload.get('index'), payload.get('width'), payload.get('height'\n            ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n            'settings')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_dashboards_create.\n                __name__, payload, official_payload_list)\n        response = self.execute('POST', path=\n            f'/widgets/{uuid}/dashboards/{uuid_dashboard}', payload=payload,\n            **kwargs)\n        return response\n\n    def widgets_dashboard_widget_put(self, uuid: str, kwargs: dict = None,\n        **payload) -&gt; list:\n        \"\"\"Update Dashboard Widget Association\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **payload: additional parameters for the API.\n\n        Keyword Args:\n            index (integer optional): additional filter - payload\n            width (integer optional): additional filter - payload\n            height (integer optional): additional filter - payload\n            grid_x (integer optional): additional filter - payload\n            grid_y (integer optional): additional filter - payload\n            settings (array object optional): additional filter - payload\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_payload_list = ['index', 'width', 'height', 'grid_x',\n            'grid_y', 'settings']\n        payload.get('index'), payload.get('width'), payload.get('height'\n            ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n            'settings')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_dashboard_widget_put.\n                __name__, payload, official_payload_list)\n        response = self.execute('PUT', path=\n            f'/widgets/dashboard_widget/{uuid}', payload=payload, **kwargs)\n        return response\n\n    def widgets_dashboard_widget_delete(self, uuid: str, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Remove Dashboard Widget Association\n\n        Args:\n            uuid (str, required): uuid\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/widgets/dashboard_widget/{uuid}', **kwargs)\n        return response\n\n    def widgets_widget_groups(self, uuid: str, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 5000,\n        kwargs: dict = None, **params) -&gt; list:\n        \"\"\"List Widget Groups\n\n        Args:\n            uuid (str, required): uuid\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            not_in (boolean optional): additional filter - parameter\n            name (string optional): additional filter - parameter\n            active (boolean optional): additional filter - parameter\n            skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n            limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n            like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n            count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['not_in', 'name', 'active', 'skip', 'limit',\n            'like', 'join', 'count']\n        params.get('not_in'), params.get('name'), params.get('active'\n            ), params.get('skip'), params.get('limit'), params.get('like'\n            ), params.get('join'), params.get('count')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_widget_groups.__name__,\n                params, official_params_list)\n        response = self.execute('GET', path=\n            f'/widgets/{uuid}/widget_groups', single_page=single_page,\n            page_size=page_size, warm_start=warm_start, params=params, **kwargs\n            )\n        return response\n\n    def widgets_widget_groups_create(self, uuid: str,\n        uuid_widget_group: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Add To A Widget Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_widget_group (str, required): uuid_widget_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/widgets/{uuid}/widget_groups/{uuid_widget_group}', **kwargs)\n        return response\n\n    def widgets_widget_groups_delete(self, uuid: str,\n        uuid_widget_group: str, kwargs: dict = None) -&gt; list:\n        \"\"\"Remove From Widget Group\n\n        Args:\n            uuid (str, required): uuid\n            uuid_widget_group (str, required): uuid_widget_group\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('DELETE', path=\n            f'/widgets/{uuid}/widget_groups/{uuid_widget_group}', **kwargs)\n        return response\n\n    def widgets_bulk(self, payload: list, warm_start: bool = False,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Read \n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['join']\n        params.get('join')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_bulk.__name__, params,\n                official_params_list)\n        response = self.execute('POST', path=f'/widgets/bulk/read/',\n            single_page=single_page, page_size=page_size, warm_start=\n            warm_start, params=params, payload=payload, **kwargs)\n        return response\n\n    def widgets_create_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n        \"\"\"Bulk Create Widgets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"code\": \"string\", required\n            \"name\": \"string\", required\n            \"description\": \"string\", optional\n            \"scope\": \"string\", optional\n            \"active\": \"boolean\", optional\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_create_bulk.__name__,\n                params, official_params_list)\n        response = self.execute('POST', path=f'/widgets/bulk/create/',\n            single_page=single_page, page_size=page_size, params=params,\n            payload=payload, **kwargs)\n        return response\n\n    def widgets_delete_bulk(self, payload: list, single_page: bool = False,\n        page_size: int = 50, kwargs: dict = None) -&gt; list:\n        \"\"\"Bulk Delete Widgets\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=f'/widgets/bulk/delete/',\n            single_page=single_page, page_size=page_size, payload=payload,\n            **kwargs)\n        return response\n\n    def widgets_dashboards_create_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n        **params) -&gt; list:\n        \"\"\"Bulk Link Dashboards\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n            **params: additional parameters for the API.\n\n        Keyword Args:\n            best_effort (boolean optional): additional filter - parameter\n\n        Examples:\n            payload = \n          [\n           {\n            \"index\": \"integer\", optional\n            \"width\": \"integer\", optional\n            \"height\": \"integer\", optional\n            \"grid_x\": \"integer\", optional\n            \"grid_y\": \"integer\", optional\n            \"settings\": \"array object\", optional\n            \"uuid_dashboard\": \"string\", required\n            \"uuid_widget\": \"string\", required\n           }\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        official_params_list = ['best_effort']\n        params.get('best_effort')\n        if not self._silence_warning:\n            warning_wrong_parameters(self.widgets_dashboards_create_bulk.\n                __name__, params, official_params_list)\n        response = self.execute('POST', path=\n            f'/widgets/bulk/create/dashboards', single_page=single_page,\n            page_size=page_size, params=params, payload=payload, **kwargs)\n        return response\n\n    def widgets_dashboards_delete_bulk(self, payload: list,\n        single_page: bool = False, page_size: int = 50, kwargs: dict = None\n        ) -&gt; list:\n        \"\"\"Bulk Unlink Dashboards\n\n        Args:\n            payload (list[dict], optional): List dict to create.\n            single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n            page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n            kwargs (dict, optional): additional parameters for execute. Default to None.\n\n        Examples:\n            payload = \n          [\n            \"uuid\": \"str\", required\n          ]\n\n        Returns: list\"\"\"\n        if kwargs is None:\n            kwargs = dict()\n        response = self.execute('POST', path=\n            f'/widgets/bulk/delete/dashboards', single_page=single_page,\n            page_size=page_size, payload=payload, **kwargs)\n        return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widget","title":"<code>widget(uuid, warm_start=False, kwargs=None)</code>","text":"<p>Read Widget</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widget(self, uuid: str, warm_start: bool = False, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Read Widget\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('GET', path=f'/widgets/{uuid}', warm_start=\n        warm_start, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets","title":"<code>widgets(warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>Read Widgets</p> <p>Parameters:</p> Name Type Description Default <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>sort_by</code> <code>string optional</code> <p>Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter</p> <code>null_fields</code> <code>string optional</code> <p>additional filter - parameter</p> <code>code</code> <code>string optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>description</code> <code>string optional</code> <p>additional filter - parameter</p> <code>scope</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets(self, warm_start: bool = False, single_page: bool = False,\n    page_size: int = 5000, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Read Widgets\n\n    Args:\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        sort_by (string optional): Stringa separata da virgole di campi su cui ordinare. Si indica uno o piu campi della risposta e si puo chiedere di ottenere i valori di quei campi in ordine ascendente o discendente. Esempio \"Customer:Desc\". Default to \"\". - parameter\n        null_fields (string optional): additional filter - parameter\n        code (string optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        description (string optional): additional filter - parameter\n        scope (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['sort_by', 'null_fields', 'code', 'name',\n        'description', 'scope', 'active', 'skip', 'limit', 'like',\n        'join', 'count']\n    params.get('sort_by'), params.get('null_fields'), params.get('code'\n        ), params.get('name'), params.get('description'), params.get(\n        'scope'), params.get('active'), params.get('skip'), params.get(\n        'limit'), params.get('like'), params.get('join'), params.get(\n        'count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets.__name__, params,\n            official_params_list)\n    response = self.execute('GET', path=f'/widgets/', single_page=\n        single_page, page_size=page_size, warm_start=warm_start, params\n        =params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_bulk","title":"<code>widgets_bulk(payload, warm_start=False, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Read </p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_bulk(self, payload: list, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Read \n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['join']\n    params.get('join')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_bulk.__name__, params,\n            official_params_list)\n    response = self.execute('POST', path=f'/widgets/bulk/read/',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_create","title":"<code>widgets_create(kwargs=None, **payload)</code>","text":"<p>Create Widget</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string required</code> <p>additional filter - payload</p> <code>name</code> <code>string required</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>scope</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_create(self, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Create Widget\n\n    Args:\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string required): additional filter - payload\n        name (string required): additional filter - payload\n        description (string optional): additional filter - payload\n        scope (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'name', 'description', 'scope',\n        'active']\n    payload.get('code'), payload.get('name'), payload.get('description'\n        ), payload.get('scope'), payload.get('active')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_create.__name__, payload,\n            official_payload_list)\n    response = self.execute('POST', path=f'/widgets/', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_create_bulk","title":"<code>widgets_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Create Widgets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"code\": \"string\", required     \"name\": \"string\", required     \"description\": \"string\", optional     \"scope\": \"string\", optional     \"active\": \"boolean\", optional    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_create_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None, **params) -&gt; list:\n    \"\"\"Bulk Create Widgets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"code\": \"string\", required\n        \"name\": \"string\", required\n        \"description\": \"string\", optional\n        \"scope\": \"string\", optional\n        \"active\": \"boolean\", optional\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_create_bulk.__name__,\n            params, official_params_list)\n    response = self.execute('POST', path=f'/widgets/bulk/create/',\n        single_page=single_page, page_size=page_size, params=params,\n        payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_dashboard_widget_delete","title":"<code>widgets_dashboard_widget_delete(uuid, kwargs=None)</code>","text":"<p>Remove Dashboard Widget Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_dashboard_widget_delete(self, uuid: str, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Remove Dashboard Widget Association\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/widgets/dashboard_widget/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_dashboard_widget_put","title":"<code>widgets_dashboard_widget_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Dashboard Widget Association</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>index</code> <code>integer optional</code> <p>additional filter - payload</p> <code>width</code> <code>integer optional</code> <p>additional filter - payload</p> <code>height</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_x</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_y</code> <code>integer optional</code> <p>additional filter - payload</p> <code>settings</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_dashboard_widget_put(self, uuid: str, kwargs: dict = None,\n    **payload) -&gt; list:\n    \"\"\"Update Dashboard Widget Association\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        index (integer optional): additional filter - payload\n        width (integer optional): additional filter - payload\n        height (integer optional): additional filter - payload\n        grid_x (integer optional): additional filter - payload\n        grid_y (integer optional): additional filter - payload\n        settings (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['index', 'width', 'height', 'grid_x',\n        'grid_y', 'settings']\n    payload.get('index'), payload.get('width'), payload.get('height'\n        ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n        'settings')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_dashboard_widget_put.\n            __name__, payload, official_payload_list)\n    response = self.execute('PUT', path=\n        f'/widgets/dashboard_widget/{uuid}', payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_dashboards","title":"<code>widgets_dashboards(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>index</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>width</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>height</code> <code>integer optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_dashboards(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Dashboards\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        index (integer optional): additional filter - parameter\n        width (integer optional): additional filter - parameter\n        height (integer optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'index', 'width',\n        'height', 'skip', 'limit', 'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('index'\n        ), params.get('width'), params.get('height'), params.get('skip'\n        ), params.get('limit'), params.get('like'), params.get('join'\n        ), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_dashboards.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=f'/widgets/{uuid}/dashboards',\n        single_page=single_page, page_size=page_size, warm_start=\n        warm_start, params=params, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_dashboards_create","title":"<code>widgets_dashboards_create(uuid, uuid_dashboard, kwargs=None, **payload)</code>","text":"<p>Add Dashboard</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_dashboard</code> <code>(str, required)</code> <p>uuid_dashboard</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>index</code> <code>integer optional</code> <p>additional filter - payload</p> <code>width</code> <code>integer optional</code> <p>additional filter - payload</p> <code>height</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_x</code> <code>integer optional</code> <p>additional filter - payload</p> <code>grid_y</code> <code>integer optional</code> <p>additional filter - payload</p> <code>settings</code> <code>array object optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_dashboards_create(self, uuid: str, uuid_dashboard: str,\n    kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Add Dashboard\n\n    Args:\n        uuid (str, required): uuid\n        uuid_dashboard (str, required): uuid_dashboard\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        index (integer optional): additional filter - payload\n        width (integer optional): additional filter - payload\n        height (integer optional): additional filter - payload\n        grid_x (integer optional): additional filter - payload\n        grid_y (integer optional): additional filter - payload\n        settings (array object optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['index', 'width', 'height', 'grid_x',\n        'grid_y', 'settings']\n    payload.get('index'), payload.get('width'), payload.get('height'\n        ), payload.get('grid_x'), payload.get('grid_y'), payload.get(\n        'settings')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_dashboards_create.\n            __name__, payload, official_payload_list)\n    response = self.execute('POST', path=\n        f'/widgets/{uuid}/dashboards/{uuid_dashboard}', payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_dashboards_create_bulk","title":"<code>widgets_dashboards_create_bulk(payload, single_page=False, page_size=50, kwargs=None, **params)</code>","text":"<p>Bulk Link Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>best_effort</code> <code>boolean optional</code> <p>additional filter - parameter</p> <p>Examples:</p> <p>payload = </p> <p>[    {     \"index\": \"integer\", optional     \"width\": \"integer\", optional     \"height\": \"integer\", optional     \"grid_x\": \"integer\", optional     \"grid_y\": \"integer\", optional     \"settings\": \"array object\", optional     \"uuid_dashboard\": \"string\", required     \"uuid_widget\": \"string\", required    }   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_dashboards_create_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None,\n    **params) -&gt; list:\n    \"\"\"Bulk Link Dashboards\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        best_effort (boolean optional): additional filter - parameter\n\n    Examples:\n        payload = \n      [\n       {\n        \"index\": \"integer\", optional\n        \"width\": \"integer\", optional\n        \"height\": \"integer\", optional\n        \"grid_x\": \"integer\", optional\n        \"grid_y\": \"integer\", optional\n        \"settings\": \"array object\", optional\n        \"uuid_dashboard\": \"string\", required\n        \"uuid_widget\": \"string\", required\n       }\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['best_effort']\n    params.get('best_effort')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_dashboards_create_bulk.\n            __name__, params, official_params_list)\n    response = self.execute('POST', path=\n        f'/widgets/bulk/create/dashboards', single_page=single_page,\n        page_size=page_size, params=params, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_dashboards_delete_bulk","title":"<code>widgets_dashboards_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Unlink Dashboards</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_dashboards_delete_bulk(self, payload: list,\n    single_page: bool = False, page_size: int = 50, kwargs: dict = None\n    ) -&gt; list:\n    \"\"\"Bulk Unlink Dashboards\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/widgets/bulk/delete/dashboards', single_page=single_page,\n        page_size=page_size, payload=payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_delete","title":"<code>widgets_delete(uuid, kwargs=None)</code>","text":"<p>Delete Widget</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_delete(self, uuid: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Delete Widget\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=f'/widgets/{uuid}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_delete_bulk","title":"<code>widgets_delete_bulk(payload, single_page=False, page_size=50, kwargs=None)</code>","text":"<p>Bulk Delete Widgets</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>list[dict]</code> <p>List dict to create.</p> required <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 50.</p> <code>50</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Examples:</p> <p>payload = </p> <p>[     \"uuid\": \"str\", required   ]</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_delete_bulk(self, payload: list, single_page: bool = False,\n    page_size: int = 50, kwargs: dict = None) -&gt; list:\n    \"\"\"Bulk Delete Widgets\n\n    Args:\n        payload (list[dict], optional): List dict to create.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 50.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Examples:\n        payload = \n      [\n        \"uuid\": \"str\", required\n      ]\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=f'/widgets/bulk/delete/',\n        single_page=single_page, page_size=page_size, payload=payload,\n        **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_put","title":"<code>widgets_put(uuid, kwargs=None, **payload)</code>","text":"<p>Update Widget</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**payload</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>code</code> <code>string optional</code> <p>additional filter - payload</p> <code>name</code> <code>string optional</code> <p>additional filter - payload</p> <code>description</code> <code>string optional</code> <p>additional filter - payload</p> <code>scope</code> <code>string optional</code> <p>additional filter - payload</p> <code>active</code> <code>boolean optional</code> <p>additional filter - payload</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_put(self, uuid: str, kwargs: dict = None, **payload) -&gt; list:\n    \"\"\"Update Widget\n\n    Args:\n        uuid (str, required): uuid\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **payload: additional parameters for the API.\n\n    Keyword Args:\n        code (string optional): additional filter - payload\n        name (string optional): additional filter - payload\n        description (string optional): additional filter - payload\n        scope (string optional): additional filter - payload\n        active (boolean optional): additional filter - payload\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_payload_list = ['code', 'name', 'description', 'scope',\n        'active']\n    payload.get('code'), payload.get('name'), payload.get('description'\n        ), payload.get('scope'), payload.get('active')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_put.__name__, payload,\n            official_payload_list)\n    response = self.execute('PUT', path=f'/widgets/{uuid}', payload=\n        payload, **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_widget_groups","title":"<code>widgets_widget_groups(uuid, warm_start=False, single_page=False, page_size=5000, kwargs=None, **params)</code>","text":"<p>List Widget Groups</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>warm_start</code> <code>bool</code> <p>salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.</p> <code>False</code> <code>single_page</code> <code>bool</code> <p>se False la risposta viene ottenuta a step per non appesantire le API. Default to False.</p> <code>False</code> <code>page_size</code> <code>int</code> <p>Numero di oggetti per pagina se single_page == False. Default to 5000.</p> <code>5000</code> <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <code>**params</code> <p>additional parameters for the API.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>not_in</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>name</code> <code>string optional</code> <p>additional filter - parameter</p> <code>active</code> <code>boolean optional</code> <p>additional filter - parameter</p> <code>skip</code> <code>integer optional</code> <p>numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter</p> <code>limit</code> <code>integer optional</code> <p>numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter</p> <code>like</code> <code>boolean optional</code> <p>Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter</p> <code>join</code> <code>boolean optional</code> <p>Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter</p> <code>count</code> <code>boolean optional</code> <p>Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter</p> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_widget_groups(self, uuid: str, warm_start: bool = False,\n    single_page: bool = False, page_size: int = 5000,\n    kwargs: dict = None, **params) -&gt; list:\n    \"\"\"List Widget Groups\n\n    Args:\n        uuid (str, required): uuid\n        warm_start (bool, optional): salva la risposta in un file e se viene richiamata la stessa funzione con gli stessi argomenti restituisce il contenuto del file. Default to False.\n        single_page (bool, optional): se False la risposta viene ottenuta a step per non appesantire le API. Default to False.\n        page_size (int, optional): Numero di oggetti per pagina se single_page == False. Default to 5000.\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n        **params: additional parameters for the API.\n\n    Keyword Args:\n        not_in (boolean optional): additional filter - parameter\n        name (string optional): additional filter - parameter\n        active (boolean optional): additional filter - parameter\n        skip (integer optional): numero di oggetti che si vogliono saltare nella risposta. Default to 0. - parameter\n        limit (integer optional): numero di oggetti massimi che si vogliono ottenere. Default to 1_000_000. - parameter\n        like (boolean optional): Se True, eventuali filtri richiesti dalla API vengono presi come porzioni di testo, se False il matching sul campo dei filtri deve essere esatto. Default to True. - parameter\n        join (boolean optional): Se join = true, ogni riga restituita conterra' chiavi aggiuntive che fanno riferimento ad altre entita', con cui la riga ha relazioni 1:1. Default to False - parameter\n        count (boolean optional): Se True nel header della risposta e' presente la dimensione massima a db della chiamata fatta, sconsigliabile perche raddoppia il tempo per chiamata. Default to False. - parameter\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    official_params_list = ['not_in', 'name', 'active', 'skip', 'limit',\n        'like', 'join', 'count']\n    params.get('not_in'), params.get('name'), params.get('active'\n        ), params.get('skip'), params.get('limit'), params.get('like'\n        ), params.get('join'), params.get('count')\n    if not self._silence_warning:\n        warning_wrong_parameters(self.widgets_widget_groups.__name__,\n            params, official_params_list)\n    response = self.execute('GET', path=\n        f'/widgets/{uuid}/widget_groups', single_page=single_page,\n        page_size=page_size, warm_start=warm_start, params=params, **kwargs\n        )\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_widget_groups_create","title":"<code>widgets_widget_groups_create(uuid, uuid_widget_group, kwargs=None)</code>","text":"<p>Add To A Widget Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_widget_group</code> <code>(str, required)</code> <p>uuid_widget_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_widget_groups_create(self, uuid: str,\n    uuid_widget_group: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Add To A Widget Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_widget_group (str, required): uuid_widget_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('POST', path=\n        f'/widgets/{uuid}/widget_groups/{uuid_widget_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.cookbook.widgets/#hive.cookbook.widgets.Widgets.widgets_widget_groups_delete","title":"<code>widgets_widget_groups_delete(uuid, uuid_widget_group, kwargs=None)</code>","text":"<p>Remove From Widget Group</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>(str, required)</code> <p>uuid</p> required <code>uuid_widget_group</code> <code>(str, required)</code> <p>uuid_widget_group</p> required <code>kwargs</code> <code>dict</code> <p>additional parameters for execute. Default to None.</p> <code>None</code> <p>Returns: list</p> Source code in <code>hive/cookbook/widgets.py</code> <pre><code>def widgets_widget_groups_delete(self, uuid: str,\n    uuid_widget_group: str, kwargs: dict = None) -&gt; list:\n    \"\"\"Remove From Widget Group\n\n    Args:\n        uuid (str, required): uuid\n        uuid_widget_group (str, required): uuid_widget_group\n        kwargs (dict, optional): additional parameters for execute. Default to None.\n\n    Returns: list\"\"\"\n    if kwargs is None:\n        kwargs = dict()\n    response = self.execute('DELETE', path=\n        f'/widgets/{uuid}/widget_groups/{uuid_widget_group}', **kwargs)\n    return response\n</code></pre>"},{"location":"hive.decorators/","title":"Hive.decorators","text":""},{"location":"hive.decorators/#hive.decorators.chunks","title":"<code>chunks(lst, n)</code>","text":"<p>metodo per suddividere una lista madre in una nuova lista composta di sotto liste piu piccole</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>list</code> <p>lista da suddividere</p> required <code>n</code> <code>int</code> <p>numero di componenti dentro ogni sotto suddivisione</p> required <p>Returns:</p> Name Type Description <code>chunked_list</code> <code>list[list]</code> <p>lista di liste, ogni elemento e' una lista con il numero di oggetti indicati provenienti dalla lista madre</p> Source code in <code>hive/decorators.py</code> <pre><code>def chunks(lst: list, n: int) -&gt; List[list]:\n    \"\"\"\n    metodo per suddividere una lista madre in una nuova lista composta di sotto liste piu piccole\n\n    Args:\n        lst (list): lista da suddividere\n        n (int): numero di componenti dentro ogni sotto suddivisione\n\n    Returns:\n        chunked_list (list[list]): lista di liste, ogni elemento e' una lista con il numero di oggetti indicati\n            provenienti dalla lista madre\n    \"\"\"\n    chunked_list = []\n    for i, ii in enumerate(range(0, len(lst), n)):\n        chunked_list.append(lst[ii:ii + n])\n    return chunked_list\n</code></pre>"},{"location":"hive.decorators/#hive.decorators.paginate","title":"<code>paginate(single_page, page_size, skip, limit, bulk)</code>","text":"<p>Questa funzione \u00e8 un decorator che abilita la paginazione per una funzione.</p> <p>Parameters:</p> Name Type Description Default <code>single_page</code> <code>bool</code> <p>se True, restituisce solo una singola \"pagina\" di risultati.</p> required <code>page_size</code> <code>int</code> <p>dimensione della pagina (numero massimo di elementi per chiamata).</p> required <code>skip</code> <code>int</code> <p>numero di elementi da saltare all'inizio.</p> required <code>limit</code> <code>int</code> <p>numero massimo di elementi da restituire.</p> required <code>bulk</code> <code>bool</code> <p>se True, gestisce il payload in modalit\u00e0 \"bulk\", suddividendolo in chunk.</p> required Source code in <code>hive/decorators.py</code> <pre><code>def paginate(single_page: bool, page_size: int, skip: int, limit: int, bulk: bool):\n    \"\"\"Questa funzione \u00e8 un decorator che abilita la paginazione per una funzione.\n\n    Args:\n        single_page: se True, restituisce solo una singola \"pagina\" di risultati.\n        page_size: dimensione della pagina (numero massimo di elementi per chiamata).\n        skip: numero di elementi da saltare all'inizio.\n        limit: numero massimo di elementi da restituire.\n        bulk: se True, gestisce il payload in modalit\u00e0 \"bulk\", suddividendolo in chunk.\n    \"\"\"\n    def attributes(func):\n        # Questo \u00e8 il decorator interno che avvolge la funzione passata (`func`).\n        @functools.wraps(func)\n        def behaviour(mode, url, headers, payload, params, **kwargs) -&gt; list:\n            # `behaviour` \u00e8 la funzione wrapper che implementa la logica di paginazione.\n            # Accetta i parametri della funzione originale (`func`) e aggiunge il supporto alla paginazione.\n            result = []  # Lista che conterr\u00e0 i risultati aggregati.\n\n            # se la chiamata \u00e8 bulk, il payload deve essere un lista e qui viene divisa in chunk e viene chiamata un\n            # chunk per volta, ogni chunk ha la dimensione del page_size\n            if bulk and not single_page:  # se la bulk viene richiesta in single_page, ricade nell'uso normale\n                # Divide il payload in chunk della dimensione specificata da `page_size`.\n                c_payload = chunks(payload, page_size)\n                # Per ogni chunk:\n                for c in c_payload:\n                    # Chiama la funzione originale (`func`) con il chunk corrente.\n                    # il codice che arriva dai decoratori prima non viene passato ai decoratori dopo\n                    result_partial, response_code = func(mode, url, headers, c, params, **kwargs)\n\n                    # se la chiamata e' un 204 e il contenuto e' None o stringa viene sostituito con una lista vuota\n                    if response_code == 204 and (result_partial is None or (isinstance(result_partial, str) and result_partial == '')):\n                        result_partial = []\n\n                    # Se il risultato non \u00e8 una lista, lo converte in una lista.\n                    if not isinstance(result_partial, list): result_partial = [result_partial]\n                    # Aggiunge i risultati parziali alla lista complessiva `result`.\n                    result += result_partial\n\n            else:  # Se non \u00e8 in modalit\u00e0 bulk o se \u00e8 richiesto single_page:\n                size = page_size if not single_page else limit  # Determina la dimensione della pagina.\n                params['skip'] = skip  # Imposta il valore iniziale di `skip` nei parametri.\n                params['limit'] = min(size, limit)  # Imposta il limite massimo per la pagina corrente.\n                while True:  # Ciclo per iterare attraverso le pagine.\n                    # Chiama la funzione originale (`func`) con i parametri della pagina corrente.\n                    # il codice che arriva dai decoratori prima non viene passato ai decoratori dopo\n                    result_partial, response_code = func(mode, url, headers, payload, params, **kwargs)\n\n                    # se la chiamata e' un 204 e il contenuto e' None o stringa viene sostituito con una lista vuota\n                    if response_code == 204 and (result_partial is None or (isinstance(result_partial, str) and result_partial == '')):\n                        result_partial = []\n\n                    # Se il risultato non \u00e8 una lista, lo converte in una lista.\n                    if not isinstance(result_partial, list): result_partial = [result_partial]\n                    # Aggiunge i risultati parziali alla lista complessiva `result`.\n                    result += result_partial\n                    # Aggiorna il valore di `skip` per passare alla pagina successiva.\n                    params['skip'] = params['skip'] + size\n                    # Interrompe il ciclo se:\n                    # - Non ci sono pi\u00f9 risultati (`result_partial` \u00e8 vuoto).\n                    # - Il numero di risultati \u00e8 inferiore alla dimensione della pagina.\n                    # - Il numero totale di risultati supera il limite specificato.\n                    # - \u00c8 richiesto il single_page.\n                    if not result_partial or len(result_partial) &lt; size or len(result) &gt; limit or single_page: break\n\n            return result\n\n        return behaviour\n\n    return attributes\n</code></pre>"},{"location":"hive.decorators/#hive.decorators.warmstart","title":"<code>warmstart(func=None, active=True, args_ex=None, kwargs_ex=None, verbose=False)</code>","text":"<p>decoratore che permette di scaricare in locale il risutato di una funzione o metodo e se ne gli argomenti ne il corpo della funzione cambiano vengono restituiti i risultati locali invece di calcolare la funzione. Se ci sono argomenti della funzione chiamata che cambiano ad ogni run ma non modificano il risultato, questi argomenti possono essere esclusi con i parametri args_ex e kwargs_ex.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>waste key, it is not to be filled</p> <code>None</code> <code>active</code> <code>bool</code> <p>if False the decorator does nothing, Default to True</p> <code>True</code> <code>args_ex</code> <code>list</code> <p>list of indexes of the function *args to be excluded for the evaluation of the rerun. Default to None.</p> <code>None</code> <code>kwargs_ex</code> <code>list</code> <p>list of keys of the function **kwargs to be excluded for the evaluation of the rerun. Default to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>if True print the status of the warm_start. Default to False</p> <code>False</code> <p>Returns: func result</p> Source code in <code>hive/decorators.py</code> <pre><code>def warmstart(func=None, active: bool = True, args_ex: list = None, kwargs_ex: list = None, verbose=False):\n    \"\"\"\n    decoratore che permette di scaricare in locale il risutato di una funzione o metodo e se ne gli argomenti\n    ne il corpo della funzione cambiano vengono restituiti i risultati locali invece di calcolare la funzione.\n    Se ci sono argomenti della funzione chiamata che cambiano ad ogni run ma non modificano il risultato, questi\n    argomenti possono essere esclusi con i parametri args_ex e kwargs_ex.\n\n    Args:\n        func: waste key, it is not to be filled\n        active (bool, optional): if False the decorator does nothing, Default to True\n        args_ex (list, optional): list of indexes of the function *args to be excluded for the evaluation of the rerun.\n            Default to None.\n        kwargs_ex (list, optional): list of keys of the function **kwargs to be excluded for the evaluation of the\n            rerun. Default to None.\n        verbose (bool, optional): if True print the status of the warm_start. Default to False\n\n    Returns: func result\n\n    \"\"\"\n    if not func:\n        return lambda f: warmstart(func=f, active=active, args_ex=args_ex, kwargs_ex=kwargs_ex, verbose=verbose)\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if active:\n            if verbose: print('warm start active')\n\n            directory = 'warmstart'\n            in_folder = True\n            # si controlla se esiste la cartella warmstart\n            if not os.path.isdir(directory):\n                # nel caso non si riuscisse a creare una cartella viene usata la posizione dello script per creare i file di warmstart\n                in_folder = False\n                try:\n                    # se non esiste provo a crearne una\n                    os.mkdir(directory)\n                    # se sono riuscito a creare una cartella da qui in poi viene usata la root della cartella\n                    in_folder = True\n                except:\n                    pass\n\n            # recupero il nome dei file nella cartella\n            files_available = os.listdir(directory) if in_folder else os.listdir()\n            # hash del corpo e del nome della funzione\n            body_and_name = hashlib.md5(inspect.getsource(func).encode()).hexdigest()\n            # vengono estratte dalle chiavi per l'hash gli args e kwargs che non devono essere considerati valido\n            # per quelle situazioni dove un elemento cambia tra una run e la successiva ma non modifica il risultato\n            args_key = list(args).copy()\n            kwargs_key = kwargs.copy()\n\n            if args_ex is not None:\n                args_val = [args_key[el] for el in args_ex]\n                for el in args_val:\n                    args_key.remove(el)\n\n            if kwargs_ex is not None:\n                for el in kwargs_ex:\n                    kwargs_key.pop(el)\n\n            # hash delle chiavi della funzione\n            arguments = hashlib.md5((str(kwargs_key) + str(args_key)).encode()).hexdigest()\n            # creao un nome che contiene i due hash\n            filename = 'temp_' + body_and_name + \"_\" + arguments + \".pkl\"\n            # verifico se quel nome e' presente nella cartella\n            if filename in files_available:\n                if in_folder: filename = './' + directory + '/' + filename\n                if verbose: print('read')\n                return read(filename)\n            else:\n                if in_folder: filename = './' + directory + '/' + filename\n                if verbose: print('write')\n                res = func(*args, **kwargs)\n                write(res, filename)\n                return res\n        else:\n            if verbose: print('warm start disabled')\n            return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"hive.exceptions/","title":"Hive.exceptions","text":""},{"location":"hive.infrastrucure_keys/","title":"Hive.infrastrucure keys","text":""},{"location":"hive.tools/","title":"Hive.tools","text":""},{"location":"hive.tools/#hive.tools.dict_by_request","title":"<code>dict_by_request(responce_list, univocal_keys)</code>","text":"<p>Given a responce list it turn the List[Dict] into a Dict[Dict] where the keys are the univocal_keys given in the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>responce_list</code> <code>list[dict]</code> <p>API responce</p> required <code>univocal_keys</code> <code>list[str]</code> <p>list of keys to use to identify the univocal arguments to be turned into the new dict keys</p> required <p>Returns: dict</p> Source code in <code>hive/tools.py</code> <pre><code>def dict_by_request(responce_list: list, univocal_keys: list) -&gt; dict:\n    \"\"\"\n    Given a responce list it turn the List[Dict] into a Dict[Dict] where the keys are the univocal_keys given in the arguments.\n\n    Args:\n        responce_list (list[dict]): API responce\n        univocal_keys (list[str]): list of keys to use to identify the univocal arguments to be turned into the new dict keys\n\n    Returns: dict\n    \"\"\"\n    responce_dict = dict()\n    for cont in responce_list:\n        chiave = tuple(cont[k] for k in univocal_keys)\n        responce_dict[chiave] = cont\n    return responce_dict\n</code></pre>"},{"location":"hive.tools/#hive.tools.order_by_request","title":"<code>order_by_request(params_list, responce_list, univocal_keys)</code>","text":"<p>Given a API responce, its univocal keys and the params list used to get that responce, a new Args:     params_list: params given to the API     responce_list: API responce     univocal_keys: keys that represents the univocal field of the responce</p> <p>Returns: List</p> Source code in <code>hive/tools.py</code> <pre><code>def order_by_request(params_list, responce_list, univocal_keys) -&gt; list:\n    \"\"\"\n    Given a API responce, its univocal keys and the params list used to get that responce, a new\n    Args:\n        params_list: params given to the API\n        responce_list: API responce\n        univocal_keys: keys that represents the univocal field of the responce\n\n    Returns: List\n\n    \"\"\"\n    responce_dict = dict_by_request(responce_list, univocal_keys)\n    response_content = [None for _ in range(len(params_list))]\n    for i, ele in enumerate(params_list):\n        chiave = tuple(ele[k] for k in univocal_keys)\n        if chiave in responce_dict:\n            response_content[i] = responce_dict[chiave]\n        else:\n            response_content[i] = None\n    return response_content\n</code></pre>"},{"location":"hive.version/","title":"Hive.version","text":""},{"location":"info/","title":"Come e' organizzato XA","text":"<p>La struttura di XA e' complessa e mescola assieme elementi di una gerarchia ad albero con elenedi da grafo, ma se ci si limita all'interazione con gli elementi dell'asset di un cliente la complessita si riduce un minimo.</p> <p>Possiamo immaginare di avere l'asset di un cliente e una serie di servizzi che puntano all'asset, andando ad arricchire l'informazione li presente, oppure aggiungendo funzionalita.</p>"},{"location":"info/#lasset","title":"L'asset","text":"<p>Come asset definiamo tutto cio' che costituisce il perimetro fisico del cliente. L'asset e' definito in modo gerarchico dalle seguenti componenti (in ordine gerarchica decrescente: - Customer - Site - Group - Object - Metric_type - Metric - Service</p> <p>Ogniuno di questi livelli contiene informazione, il customer definisce il cliente, i siti definiscono le filiali del cliente, etc. Ogni livelli e' connesso con un legame uno a molti con il livello sottostante, quindi un sito ha dei gruppi al suo interno, ma un gruppo non puo essere in piu siti. Esiste un eccezione che sono i gruppi, per la maggior parte del loro uso mantengono una relazione uno a molti con i metric_type, ma un oogetto puo essere contenuto in piu gruppi. Quindi diciamo che tra i gruppi e gli oggetti c'e' una relazione molti a molti.</p> <p>Ogni elemento puo essere identificato da una serie di chiavi primarie che comprendono anche lo uuid del suo livello superiore. Questo ovviamente non e' vero per gli oggetti per via della natura molti a molti con i gruppi.</p> <p>I servizzi che chiudono la fila, sono una seconda eccezione: hanno una importanza gerarchica simile alle metriche, possono essere legate alle metriche con legame molti a molti ma possono anche non essere legate alle metriche e vivere completamente slegate dall'asset. I servizzi rappresentano informazione aggiuntiva calcolata partendo da valori del cliente o altri dati, non necessariamente sono legate all'asset. Se sono legate all'asset lo sono tramite le metriche, in questi casi esiste un puntamento verso tutte le metriche che hanno contribuito a formare il servizio.</p> <p>La struttura dal customer al servizio rappresenta l'asset e viene chiamato albero.</p> <p>Per navigare l'albero esistono API che permettono di ottenere le informazioni di legame di un layer con gli altri. Per fare un esempio, se conosco una metric e voglio sapere in quale object questa e' contenuta, nei dati della metric stessa e' presente lo uuid del metric_type che la contiene. Con quel uuid, posso ricavare i dettagli del metric_type in cui e' presente lo uuid del object che lo contiene. Con quel uuid posso andare a chiedere i dettagli dell'object che mi interessava conoscere.</p> <p>E' altrettando vero nell'altra direzione, noto un objetc posso sapere tutti gli metric_type che lo compongono, sceltone uno posso chiedere tutte le metrics che lo compongono.</p> <p>Questo modo di navigare l'albero trova alcune variazioni quando si cerca di superare i layer con relazioni molti a molti. Per conoscere quali groups contengono un object e viceversa, ci sono API apposta che dato uno dei due layer, ti restituisce il secondo. Questo vale anche per i services avengo la stessa natura molti a molti.</p> <p>Esistono scorciatoie per navigare l'albero, queste scorciatorie vanno sotto forma del set di API tree_hierarchy. Questa API sono disegnate per recuperare un elemento nell'albero con tutti i suoi legami con i layer superiori.</p>"},{"location":"info/#time-series","title":"Time series","text":"<p>L'asset rapresenta gli oggetti che producono dati, ma i dati stessi vengono raccolti in un posto diverso. Nello specifico nelle tabelle delle serie temporali. Tali serie si dividono in due tipologie, serie di stato e serie di valore.</p> <p>Le serie di stato sono una successione di informazioni raccolte in dizionari, possono contenere ogni tipo di informazione e portano con se un indice di gravita. Le serie di valore sono successioni di numeri, ideali per raccogliere dati numerici come temperatura, velocita etc.</p> <p>Le metrics sono il layer in cui vengono salvate queste serie. Ogni metric e' legata direttamente ad una e una sola serie temporale, sia essa di stato o di valore.</p> <p>I services possono essere legati a serie temporali a loro volta, e , a differenza delle metrics possono puntare conemporaneamente sia a serie di valore che di stato.</p>"},{"location":"info/#informazioni-aggiuntive","title":"Informazioni aggiuntive","text":"<p>Le ralazioni non finiscono con l'asset, esistono una miriade di informazioni aggiuntive esplorabili, come gli user, le dashboard e cosi via. Il modo di navigare questi legami e' pero lo stesso con cui si naviga l'albero.</p> <p>La completa connessione tra tutti gli elementi richiamabili con API e' presentata nello schema qui di seguito</p> <p></p>"},{"location":"installation/","title":"Installazione","text":"<p>Il pacchetto si installa come un qualsiasi pacchetto python <pre><code>pip install xautomata-hive\n</code></pre></p> <p>L'uso interno poi deve essere fatto con il solo nome hive <pre><code>import hive\n</code></pre></p>"},{"location":"user_guide/","title":"Manuale d'uso","text":"<p>La libreria hive \u00e8 stata pensata per facilitare l'interazione con le API di XAutomata. Di seguito si trova un esempio dove viene chiesta la lista dei customers con codice DEMO, e si chiede di ottere il  risultato paginato di 50 elementi per volta. Il risultato ottenuto (ricompattato in un unica lista) vine poi usato per estrarre lo uuid del primo customer per chiedere tutti i siti attivi di quel customer scelto.</p> <p>L'uso di questa libreria garantisce una serie di feature aggiuntive automatiche, gestite dietro le quinte, di cui l'operatore non deve preoccuparsi: - warmstart: gestione di una cache locale per non rifare piu volte la stessa chiamata se non serve. - ratelimiter: vengono limitate le chiamate massime al minuto che si possono fare, garantendo l'impossibilita di dare fastidio al server inavvertitamente. - riautenticazione: se l'autenticazione usata scade per il troppo tempo passato, viene gestita in automatico la riatuenticazione. - paginazione: le chiamate troppo grandi vengono suddivise in automatico in sottochiamate per non chiedere tutto assieme. - richiamate: se una chiamata fallisce vengono fatti una serie di tentativi prima di restituire un errore.</p> <p>Ogni metodo usato restituisce sempre una lista di elementi.</p> <p>Le API trovate sullo swagger del proprio ambiente XAUTOMATA sono chiamabili in maniera semplificata come metodi della libreria XautomataAPI. In alternativa si puo usare una metodologia piu simile alla libreria request che richiede l'url dell'API. Di seguito i due tipi di approccio.</p>"},{"location":"user_guide/#api-come-metodi","title":"API come metodi","text":"<pre><code>from hive.api import XautomataApi\n\nroot = ''\npassw = ''\nuser = ''\n\nxa = XautomataApi(root=root, user=user, password=passw)\n\ncustomers = xa.customers(code='DEMO', like=True, page_size=50)\n\nuuid_c = customers[0]['uuid']\n\nsites = xa.sites(uuid_customer=uuid_c, status='A')\n</code></pre> <p>Si puo vedere come le chiamate alle API hanno la stessa terminologie trovata sullo swagger cosi come tutti i parametri di filtro evidenziati dentro lo swagger. Suddetti filtri vengono selezionati semplicemente aggiungendo la chiave:valore nel metodo scelto. In aggiunta ai filtri degli specifici endpoint sono presenti in aggiunta: - single_page: XautomataApi pagina sempre la chiamata, ma se impostato a single_page=True, la paginazione viene inibita - page_size: paginando in automatico, \u00e8 sempre presente un valore di elementi per pagina. Importante ricordare che il risultato non viene restituito paginato ma sempre ricompattato in una unica risposta. - warm_start: per le chiamate in lettura \u00e8 sempre possibile attivare la modalita warmstart che crea una hard cache locale, salvado la risposta in un file. Ogni volta che viene rifatta la stessa chiamata con gli stessi parametri (se in modalita warm_start), il risultato viene preso dal file locale invece che fare la chiamata al server. - kwargs: questa chiave prevede di ricevere un dizionario e sono valori vengono passati direttamente a request. Utile sono a chi sa cosa sta facendo e vuole un comportamento di request diverso dal default.</p> <p>L'uso di ogni API \u00e8 specializzato ai parametri specifici di quel API, per avere un dettaglio dei parametri usabili si puo consultare sia il docstring di ogni metodo, che contiene il dettaglio dei parametri usabili, cosi come lo swagger stesso. Ogni parametro presente nello swagger \u00e8 riportato un modo speculare nei parametri di XautomataApi.</p> <p>Nelle situazioni in cui viene richiesto un corpo delle API sotto forma di una lista di oggetti, la lista deve essere fornita per intero, come nell'esempio che segue:</p> <pre><code>from hive.api import XautomataApi\nxa = XautomataApi(root='root', user='user', password='passw')\n\nlista_uuid = ['uuid1', 'uuid2', 'uuid3']\n\ncustomers = xa.sites_bulk(payload=lista_uuid)\n</code></pre>"},{"location":"user_guide/#chiamate-in-modalita-multi","title":"chiamate in modalita multi","text":"<p>E' anche possibile iterare un metodo sopra una lista di chiavi con il metodo multi built-in. Questo metodo esegue un semplice for su ogni chiave della lista che si vuole investigare, ma a differenza di un ciclo normale, gestisce l'eventuale paginazione e warm_start come fosse un unica chiamata, rendendo il tutto piu efficiente. Un esempio di uso e' il seguente:</p> <p><pre><code>from hive.api import XautomataApi\nxa = XautomataApi(root='root', user='user', password='passw')\n\nlista_uuid = ['uuid1', 'uuid2', 'uuid3']\n\nuuid_objects_w_probes = xa.multi_method(method=xa.metric, name_to_cicle='uuid',\n                                        multi_uuid=lista_uuid, warm_start=True)\n</code></pre> In questo esempio vengono chiesti gli uuid di piu metriche in un ciclo che chiama l'API metric per ciascun uuid. In casi dove il risultato puo essere ottenuto anche con un metodo bulk, il metodo bulk e' preferibile sia per performance che rapidita di esecuzione.</p>"},{"location":"user_guide/#chiamate-in-modalita-get_post","title":"chiamate in modalita get_post","text":"<p>Questo metodo permette di chiamare un endpoint in forma di GET, se si riceve una risposta ma il contenuto e' parzialmente diverso da quello usato viene fatta automaticamente una PUT, mentre se non e' presente viene eseguita automaticamente una POST. Esistono due versioni di questo metodo, una versione singola get_post ed una versione bulk get_post_bulk. La versione bulk permette di fornire una lista di elementi da verificare tutti assieme.</p> <p>L'uso e' mostrato nell'esempio sottostante</p> <pre><code>from hive.api import XautomataApi\nxa = XautomataApi(root='root', user='user', password='passw')\n\nnewgroup = {\n    \"uuid_site\": '000',\n    \"uuid_virtual_domain\": '000',\n    \"type\": 'IT',\n    \"name\": 'name',\n    \"description\": \"description group\",\n    \"status\": \"A\"\n}\n\ngetgroup = {\n    \"uuid_site\": '000',\n    \"uuid_virtual_domain\": '000',\n    \"name\": 'name'\n}\n\nuuid, get_count, post_count, put_count = xa.get_post(url_get='/groups/', get_params=getgroup, post_params=newgroup)\n</code></pre> <p>Il modo migliore di usare i parametri della get e' usando solo quelli obligatori lasciando quelli optionali nella post, cosi se avviene un cambiamento dei parametri optionali l'oggetto viene ugualmente trovato. Se la post avviene su un url diverso, puo essere usata la chiave url_post. Se l'api in scrittura chiede dei parametri aggiuntivi (come il site per la geolocalizzazione), questi possono essere aggiunti con la chiave add_post_params.</p> <p>Nella risposta del metodo viene dato l'uuid dell'elemento e un valore intero che dice se l'uuid e' stato ottenuto con una GET, PUT o POST.</p> <p>La versione bulk deve essere scritta come segue:</p> <pre><code>from hive.api import XautomataApi\nxa = XautomataApi(root='root', user='user', password='passw')\n\ngroups = [\n    {\n        \"uuid_site\": '000',\n        \"uuid_virtual_domain\": '000',\n        \"type\": 'IT',\n        \"name\": 'name0',\n        \"description\": \"description group0\",\n        \"status\": \"A\"\n    },\n    {\n        \"uuid_site\": '111',\n        \"uuid_virtual_domain\": '111',\n        \"type\": 'TLC',\n        \"name\": 'name1',\n        \"description\": \"description group1\",\n        \"status\": \"A\"\n    }\n]\n\nuuid, get_count, post_count, put_count = xa.spell.get_post_bulk(url_get=\"groups\", post_params=groups)\n</code></pre> <p>La versione bulk e' piu diretta e semplica da usare. Puo essere dato il solo url della get se la post usa lo stesso nome. Si usano solo i parametri della post, e' il metodo internamente che nella get opera con i soli parametri obligatori. Se necessario possono essere aggiunti parametri alle API con le chiavi add_get_params e add_post_params. La risposta e' una lista di uuid restituita nello stesso ordine degli elementi dati in ingresso. I conteggi di get, put e post sono il numero totale di quanti ne sono avvenuti.</p>"},{"location":"user_guide/#uso-della-documentazione-delle-api","title":"Uso della documentazione delle API","text":"<p>Su questo sito di documentazione e' anche presente la documentazione dettagliata di ogni metodo creato. La documentazione e' stata scritta con delle linee guida: - le chiavi payload e params sono usate come contenitori di piu parametri. I parametri usabili tramite queste due chiavi sono descritti nella sezione Kyeword Args. Ciascun parametro porta alla fine della sua descrizione la parola payload o params per aiutare a distinguere a quale chiave appartiene. - se un metodo e' di write, delete o update, sara esplicitato nel nome del metodo stesso. Mentre se il metodo e' di sola lettura, non sara espicitato nulla nel nome. - tutti i metodi bulk richiedono la costruzione di una lista con dei dizionari dentro e in tutti i casi questo oggetto va dentro a payload indipendetemente se e' GET, POST, DELETE - Non esistono metodi bulk PUT - Gli schema dei dati che si possono mettere dentro al payload viene riportato negli Examples - Se un metodo ha piu di uno schema dei dati che si possono inviare, le chiavi appartenenti ai diversi schema hanno un postilla numerica che rappresenta lo schema di appartenenza: uuid_1, name_1, uuid_2, status_2 - in questo esempio lo schema 1 contiene uuid e name, mentre lo schema 2 contiene uuid e status - Se sono presenti sia payload che params solo uno dei due sara nella versione kwargs (esempio params), l'altro dovra essere scritto come oggetto unico non scomponibile, con la tipologia indicata nella documentazione, tipicamente o dizionario o lista</p>"},{"location":"user_guide/#api-come-url","title":"API come url","text":"<p>In alternativa e' possibile usare XautomataApi tramite l'url dell'endpoint. La differenza chiave sul passare tramite questo approccio e' che si possono chiamare anche API non ancora implemetate in modalita metodi, o manipolare in modo piu diretto cosa viene passato alla chiamata. Resta ugualmente preferibile usare XautomataApi rispetto a request perche anche tramite la chiamta url vengono mantenute le proprieta di paginazione, cache, riautenticazione etc.</p> <p>Qui di seguito si puo vedere la chiamata fatta per ottenere i clienti con codice 'DEMO' in modalita url.</p> <pre><code>from hive.api import XautomataApi\nxa = XautomataApi(root='root', user='user', password='passw')\n\nparams = {'code': 'DEMO',\n          'like': True}\n\ncustomers = xa.execute(mode='GET', path='/customers/', params=params, page_size=50)\n</code></pre> <p>a differenza della modalita per metodi, in questo caso i parametri devono essere inseriti all'interno di un dizionario che viene passato a params se si sta fornendo un parametri, e a payload se si sta fornendo un corpo (tipicamente usato per le post)</p>"},{"location":"user_guide/#tips-and-tricks","title":"tips and tricks","text":"<p>esiste un parametri privato _get_only che se forzato a True impedisce di usare API di POST/PUT/DELETE. Fatta eccezione delle bulk e query dove vengono inibite solo le chiamtate che andrebbero ad apportare modifiche al db</p> <pre><code>from hive.api import XautomataApi\nxa = XautomataApi(root='root', user='user', password='passw')\nxa._get_only = True\n</code></pre> <p>con il parametro privato _timeout_retry si possono impostare un numero di retry per le situazioni in cui si fallisca le request in caso di timeout, e il tempo tra un retry e quello successivo e' impostabile con _timeout_sleep_time.</p> <p>con il parametro privato _timeout_get_session_retry si possono impostare un numero di retry per la libreria request su errori noti, e il tempo tra un retry e quello successivo e' impostabile con una formula basata sul valore  _timeout_get_session_backoff_factor. Di default _timeout_get_session_retry = 5 e _timeout_get_session_backoff_factor = 5.</p>"}]}